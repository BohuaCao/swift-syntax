// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 8)
//// Automatically Generated From SyntaxNodes.swift.gyb.
//// Do Not Edit Directly!
//===------------ SyntaxNodes.swift - Syntax Node definitions -------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2017 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 41)

/// A wrapper around a raw Syntax layout.
public struct UnknownSyntax: _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates an `UnknownSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 63)
public protocol DeclSyntax: Syntax {}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 63)
public protocol ExprSyntax: Syntax {}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 63)
public protocol StmtSyntax: Syntax {}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 63)
public protocol TypeSyntax: Syntax {}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 63)
public protocol PatternSyntax: Syntax {}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct UnknownDeclSyntax: DeclSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `UnknownDeclSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `UnknownDeclSyntax` nodes are equal to each other.
  public static func ==(lhs: UnknownDeclSyntax, rhs: UnknownDeclSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct UnknownExprSyntax: ExprSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `UnknownExprSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `UnknownExprSyntax` nodes are equal to each other.
  public static func ==(lhs: UnknownExprSyntax, rhs: UnknownExprSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct UnknownStmtSyntax: StmtSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `UnknownStmtSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `UnknownStmtSyntax` nodes are equal to each other.
  public static func ==(lhs: UnknownStmtSyntax, rhs: UnknownStmtSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct UnknownTypeSyntax: TypeSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `UnknownTypeSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `UnknownTypeSyntax` nodes are equal to each other.
  public static func ==(lhs: UnknownTypeSyntax, rhs: UnknownTypeSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct UnknownPatternSyntax: PatternSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `UnknownPatternSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `UnknownPatternSyntax` nodes are equal to each other.
  public static func ==(lhs: UnknownPatternSyntax, rhs: UnknownPatternSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 70)
/// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 70)
/// A CodeBlockItem is any Syntax node that appears on its own line inside
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 70)
/// a CodeBlock.
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 70)
/// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct CodeBlockItemSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case item
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case semicolon
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case errorTokens
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `CodeBlockItemSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 3)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _item = raw[Cursor.syntax]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_item.kind == .syntax,
                 "expected child of kind .syntax, " +
                 "got \(_item.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _semicolon = raw[Cursor.semicolonToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _semicolonTokenKind = _semicolon.tokenKind else {
      fatalError("expected token child, got \(_semicolon.kind)")
    }
    precondition([.semicolon].contains(_semicolonTokenKind),
      "expected one of [.semicolon] for 'semicolon' " + 
      "in node of kind codeBlockItem")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _errorTokens = raw[Cursor.syntax]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_errorTokens.kind == .syntax,
                 "expected child of kind .syntax, " +
                 "got \(_errorTokens.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// The underlying node inside the code block.
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var item: Syntax {
    let child = data.cachedChild(at: Cursor.item)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) 
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `item` replaced.
  /// - param newChild: The new `item` to replace the node's
  ///                   current `item`, if present.
  public func withItem(
    _ newChild: Syntax?) -> CodeBlockItemSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.unknown)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.item)
    return CodeBlockItemSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// If present, the trailing semicolon at the end of the item.
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var semicolon: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.semicolon)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `semicolon` replaced.
  /// - param newChild: The new `semicolon` to replace the node's
  ///                   current `semicolon`, if present.
  public func withSemicolon(
    _ newChild: TokenSyntax?) -> CodeBlockItemSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.semicolon)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.semicolon)
    return CodeBlockItemSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var errorTokens: Syntax? {
    let child = data.cachedChild(at: Cursor.errorTokens)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) 
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `errorTokens` replaced.
  /// - param newChild: The new `errorTokens` to replace the node's
  ///                   current `errorTokens`, if present.
  public func withErrorTokens(
    _ newChild: Syntax?) -> CodeBlockItemSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.unknown)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.errorTokens)
    return CodeBlockItemSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `CodeBlockItemSyntax` nodes are equal to each other.
  public static func ==(lhs: CodeBlockItemSyntax, rhs: CodeBlockItemSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct CodeBlockSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case leftBrace
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case statements
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case rightBrace
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `CodeBlockSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 3)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _leftBrace = raw[Cursor.leftBraceToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _leftBraceTokenKind = _leftBrace.tokenKind else {
      fatalError("expected token child, got \(_leftBrace.kind)")
    }
    precondition([.leftBrace].contains(_leftBraceTokenKind),
      "expected one of [.leftBrace] for 'leftBrace' " + 
      "in node of kind codeBlock")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _statements = raw[Cursor.codeBlockItemList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_statements.kind == .codeBlockItemList,
                 "expected child of kind .codeBlockItemList, " +
                 "got \(_statements.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _rightBrace = raw[Cursor.rightBraceToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _rightBraceTokenKind = _rightBrace.tokenKind else {
      fatalError("expected token child, got \(_rightBrace.kind)")
    }
    precondition([.rightBrace].contains(_rightBraceTokenKind),
      "expected one of [.rightBrace] for 'rightBrace' " + 
      "in node of kind codeBlock")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var leftBrace: TokenSyntax {
    let child = data.cachedChild(at: Cursor.leftBrace)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `leftBrace` replaced.
  /// - param newChild: The new `leftBrace` to replace the node's
  ///                   current `leftBrace`, if present.
  public func withLeftBrace(
    _ newChild: TokenSyntax?) -> CodeBlockSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftBrace)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.leftBrace)
    return CodeBlockSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var statements: CodeBlockItemListSyntax {
    let child = data.cachedChild(at: Cursor.statements)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! CodeBlockItemListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `CodeBlockItem` to the node's `statements`
  /// collection.
  /// - param element: The new `CodeBlockItem` to add to the node's
  ///                  `statements` collection.
  /// - returns: A copy of the receiver with the provided `CodeBlockItem`
  ///            appended to its `statements` collection.
  public func addCodeBlockItem(_ element: CodeBlockItemSyntax) -> CodeBlockSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.statements] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.codeBlockItemList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.statements)
    return CodeBlockSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `statements` replaced.
  /// - param newChild: The new `statements` to replace the node's
  ///                   current `statements`, if present.
  public func withStatements(
    _ newChild: CodeBlockItemListSyntax?) -> CodeBlockSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.codeBlockItemList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.statements)
    return CodeBlockSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var rightBrace: TokenSyntax {
    let child = data.cachedChild(at: Cursor.rightBrace)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `rightBrace` replaced.
  /// - param newChild: The new `rightBrace` to replace the node's
  ///                   current `rightBrace`, if present.
  public func withRightBrace(
    _ newChild: TokenSyntax?) -> CodeBlockSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightBrace)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.rightBrace)
    return CodeBlockSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `CodeBlockSyntax` nodes are equal to each other.
  public static func ==(lhs: CodeBlockSyntax, rhs: CodeBlockSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct InOutExprSyntax: ExprSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case ampersand
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case expression
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `InOutExprSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 2)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _ampersand = raw[Cursor.prefixAmpersandToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _ampersandTokenKind = _ampersand.tokenKind else {
      fatalError("expected token child, got \(_ampersand.kind)")
    }
    precondition([.prefixAmpersand].contains(_ampersandTokenKind),
      "expected one of [.prefixAmpersand] for 'ampersand' " + 
      "in node of kind inOutExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _expression = raw[Cursor.expr]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_expression.kind == .expr,
                 "expected child of kind .expr, " +
                 "got \(_expression.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var ampersand: TokenSyntax {
    let child = data.cachedChild(at: Cursor.ampersand)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `ampersand` replaced.
  /// - param newChild: The new `ampersand` to replace the node's
  ///                   current `ampersand`, if present.
  public func withAmpersand(
    _ newChild: TokenSyntax?) -> InOutExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.prefixAmpersand)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.ampersand)
    return InOutExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var expression: ExprSyntax {
    let child = data.cachedChild(at: Cursor.expression)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! ExprSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `expression` replaced.
  /// - param newChild: The new `expression` to replace the node's
  ///                   current `expression`, if present.
  public func withExpression(
    _ newChild: ExprSyntax?) -> InOutExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.expression)
    return InOutExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `InOutExprSyntax` nodes are equal to each other.
  public static func ==(lhs: InOutExprSyntax, rhs: InOutExprSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct PoundColumnExprSyntax: ExprSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case poundColumn
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `PoundColumnExprSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 1)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _poundColumn = raw[Cursor.poundColumnToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _poundColumnTokenKind = _poundColumn.tokenKind else {
      fatalError("expected token child, got \(_poundColumn.kind)")
    }
    precondition([.poundColumnKeyword].contains(_poundColumnTokenKind),
      "expected one of [.poundColumnKeyword] for 'poundColumn' " + 
      "in node of kind poundColumnExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var poundColumn: TokenSyntax {
    let child = data.cachedChild(at: Cursor.poundColumn)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `poundColumn` replaced.
  /// - param newChild: The new `poundColumn` to replace the node's
  ///                   current `poundColumn`, if present.
  public func withPoundColumn(
    _ newChild: TokenSyntax?) -> PoundColumnExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.poundColumnKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.poundColumn)
    return PoundColumnExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `PoundColumnExprSyntax` nodes are equal to each other.
  public static func ==(lhs: PoundColumnExprSyntax, rhs: PoundColumnExprSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct TryExprSyntax: ExprSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case tryKeyword
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case questionOrExclamationMark
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case expression
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `TryExprSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 3)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _tryKeyword = raw[Cursor.tryToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _tryKeywordTokenKind = _tryKeyword.tokenKind else {
      fatalError("expected token child, got \(_tryKeyword.kind)")
    }
    precondition([.tryKeyword].contains(_tryKeywordTokenKind),
      "expected one of [.tryKeyword] for 'tryKeyword' " + 
      "in node of kind tryExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _questionOrExclamationMark = raw[Cursor.token]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _questionOrExclamationMarkTokenKind = _questionOrExclamationMark.tokenKind else {
      fatalError("expected token child, got \(_questionOrExclamationMark.kind)")
    }
    precondition([.postfixQuestionMark, .exclamationMark].contains(_questionOrExclamationMarkTokenKind),
      "expected one of [.postfixQuestionMark, .exclamationMark] for 'questionOrExclamationMark' " + 
      "in node of kind tryExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _expression = raw[Cursor.expr]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_expression.kind == .expr,
                 "expected child of kind .expr, " +
                 "got \(_expression.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var tryKeyword: TokenSyntax {
    let child = data.cachedChild(at: Cursor.tryKeyword)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `tryKeyword` replaced.
  /// - param newChild: The new `tryKeyword` to replace the node's
  ///                   current `tryKeyword`, if present.
  public func withTryKeyword(
    _ newChild: TokenSyntax?) -> TryExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.tryKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.tryKeyword)
    return TryExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var questionOrExclamationMark: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.questionOrExclamationMark)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `questionOrExclamationMark` replaced.
  /// - param newChild: The new `questionOrExclamationMark` to replace the node's
  ///                   current `questionOrExclamationMark`, if present.
  public func withQuestionOrExclamationMark(
    _ newChild: TokenSyntax?) -> TryExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.postfixQuestionMark)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.questionOrExclamationMark)
    return TryExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var expression: ExprSyntax {
    let child = data.cachedChild(at: Cursor.expression)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! ExprSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `expression` replaced.
  /// - param newChild: The new `expression` to replace the node's
  ///                   current `expression`, if present.
  public func withExpression(
    _ newChild: ExprSyntax?) -> TryExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.expression)
    return TryExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `TryExprSyntax` nodes are equal to each other.
  public static func ==(lhs: TryExprSyntax, rhs: TryExprSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct DeclNameArgumentSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case name
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case colon
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `DeclNameArgumentSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 2)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _name = raw[Cursor.token]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_name.kind == .token,
                 "expected child of kind .token, " +
                 "got \(_name.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _colon = raw[Cursor.colonToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _colonTokenKind = _colon.tokenKind else {
      fatalError("expected token child, got \(_colon.kind)")
    }
    precondition([.colon].contains(_colonTokenKind),
      "expected one of [.colon] for 'colon' " + 
      "in node of kind declNameArgument")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var name: TokenSyntax {
    let child = data.cachedChild(at: Cursor.name)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `name` replaced.
  /// - param newChild: The new `name` to replace the node's
  ///                   current `name`, if present.
  public func withName(
    _ newChild: TokenSyntax?) -> DeclNameArgumentSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.unknown(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.name)
    return DeclNameArgumentSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var colon: TokenSyntax {
    let child = data.cachedChild(at: Cursor.colon)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `colon` replaced.
  /// - param newChild: The new `colon` to replace the node's
  ///                   current `colon`, if present.
  public func withColon(
    _ newChild: TokenSyntax?) -> DeclNameArgumentSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.colon)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.colon)
    return DeclNameArgumentSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `DeclNameArgumentSyntax` nodes are equal to each other.
  public static func ==(lhs: DeclNameArgumentSyntax, rhs: DeclNameArgumentSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct DeclNameArgumentsSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case leftParen
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case arguments
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case rightParen
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `DeclNameArgumentsSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 3)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _leftParen = raw[Cursor.leftParenToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _leftParenTokenKind = _leftParen.tokenKind else {
      fatalError("expected token child, got \(_leftParen.kind)")
    }
    precondition([.leftParen].contains(_leftParenTokenKind),
      "expected one of [.leftParen] for 'leftParen' " + 
      "in node of kind declNameArguments")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _arguments = raw[Cursor.declNameArgumentList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_arguments.kind == .declNameArgumentList,
                 "expected child of kind .declNameArgumentList, " +
                 "got \(_arguments.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _rightParen = raw[Cursor.rightParenToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _rightParenTokenKind = _rightParen.tokenKind else {
      fatalError("expected token child, got \(_rightParen.kind)")
    }
    precondition([.rightParen].contains(_rightParenTokenKind),
      "expected one of [.rightParen] for 'rightParen' " + 
      "in node of kind declNameArguments")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var leftParen: TokenSyntax {
    let child = data.cachedChild(at: Cursor.leftParen)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `leftParen` replaced.
  /// - param newChild: The new `leftParen` to replace the node's
  ///                   current `leftParen`, if present.
  public func withLeftParen(
    _ newChild: TokenSyntax?) -> DeclNameArgumentsSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftParen)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.leftParen)
    return DeclNameArgumentsSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var arguments: DeclNameArgumentListSyntax {
    let child = data.cachedChild(at: Cursor.arguments)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! DeclNameArgumentListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `DeclNameArgument` to the node's `arguments`
  /// collection.
  /// - param element: The new `DeclNameArgument` to add to the node's
  ///                  `arguments` collection.
  /// - returns: A copy of the receiver with the provided `DeclNameArgument`
  ///            appended to its `arguments` collection.
  public func addDeclNameArgument(_ element: DeclNameArgumentSyntax) -> DeclNameArgumentsSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.arguments] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.declNameArgumentList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.arguments)
    return DeclNameArgumentsSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `arguments` replaced.
  /// - param newChild: The new `arguments` to replace the node's
  ///                   current `arguments`, if present.
  public func withArguments(
    _ newChild: DeclNameArgumentListSyntax?) -> DeclNameArgumentsSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.declNameArgumentList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.arguments)
    return DeclNameArgumentsSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var rightParen: TokenSyntax {
    let child = data.cachedChild(at: Cursor.rightParen)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `rightParen` replaced.
  /// - param newChild: The new `rightParen` to replace the node's
  ///                   current `rightParen`, if present.
  public func withRightParen(
    _ newChild: TokenSyntax?) -> DeclNameArgumentsSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightParen)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.rightParen)
    return DeclNameArgumentsSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `DeclNameArgumentsSyntax` nodes are equal to each other.
  public static func ==(lhs: DeclNameArgumentsSyntax, rhs: DeclNameArgumentsSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct IdentifierExprSyntax: ExprSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case identifier
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case declNameArguments
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `IdentifierExprSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 2)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _identifier = raw[Cursor.token]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _identifierTokenKind = _identifier.tokenKind else {
      fatalError("expected token child, got \(_identifier.kind)")
    }
    precondition([.identifier, .selfKeyword, .capitalSelfKeyword, .dollarIdentifier, .spacedBinaryOperator].contains(_identifierTokenKind),
      "expected one of [.identifier, .selfKeyword, .capitalSelfKeyword, .dollarIdentifier, .spacedBinaryOperator] for 'identifier' " + 
      "in node of kind identifierExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _declNameArguments = raw[Cursor.declNameArguments]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_declNameArguments.kind == .declNameArguments,
                 "expected child of kind .declNameArguments, " +
                 "got \(_declNameArguments.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var identifier: TokenSyntax {
    let child = data.cachedChild(at: Cursor.identifier)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `identifier` replaced.
  /// - param newChild: The new `identifier` to replace the node's
  ///                   current `identifier`, if present.
  public func withIdentifier(
    _ newChild: TokenSyntax?) -> IdentifierExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.identifier)
    return IdentifierExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var declNameArguments: DeclNameArgumentsSyntax? {
    let child = data.cachedChild(at: Cursor.declNameArguments)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? DeclNameArgumentsSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `declNameArguments` replaced.
  /// - param newChild: The new `declNameArguments` to replace the node's
  ///                   current `declNameArguments`, if present.
  public func withDeclNameArguments(
    _ newChild: DeclNameArgumentsSyntax?) -> IdentifierExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.declNameArguments)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.declNameArguments)
    return IdentifierExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `IdentifierExprSyntax` nodes are equal to each other.
  public static func ==(lhs: IdentifierExprSyntax, rhs: IdentifierExprSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct SuperRefExprSyntax: ExprSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case superKeyword
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `SuperRefExprSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 1)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _superKeyword = raw[Cursor.superToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _superKeywordTokenKind = _superKeyword.tokenKind else {
      fatalError("expected token child, got \(_superKeyword.kind)")
    }
    precondition([.superKeyword].contains(_superKeywordTokenKind),
      "expected one of [.superKeyword] for 'superKeyword' " + 
      "in node of kind superRefExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var superKeyword: TokenSyntax {
    let child = data.cachedChild(at: Cursor.superKeyword)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `superKeyword` replaced.
  /// - param newChild: The new `superKeyword` to replace the node's
  ///                   current `superKeyword`, if present.
  public func withSuperKeyword(
    _ newChild: TokenSyntax?) -> SuperRefExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.superKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.superKeyword)
    return SuperRefExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `SuperRefExprSyntax` nodes are equal to each other.
  public static func ==(lhs: SuperRefExprSyntax, rhs: SuperRefExprSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct NilLiteralExprSyntax: ExprSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case nilKeyword
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `NilLiteralExprSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 1)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _nilKeyword = raw[Cursor.nilToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _nilKeywordTokenKind = _nilKeyword.tokenKind else {
      fatalError("expected token child, got \(_nilKeyword.kind)")
    }
    precondition([.nilKeyword].contains(_nilKeywordTokenKind),
      "expected one of [.nilKeyword] for 'nilKeyword' " + 
      "in node of kind nilLiteralExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var nilKeyword: TokenSyntax {
    let child = data.cachedChild(at: Cursor.nilKeyword)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `nilKeyword` replaced.
  /// - param newChild: The new `nilKeyword` to replace the node's
  ///                   current `nilKeyword`, if present.
  public func withNilKeyword(
    _ newChild: TokenSyntax?) -> NilLiteralExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.nilKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.nilKeyword)
    return NilLiteralExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `NilLiteralExprSyntax` nodes are equal to each other.
  public static func ==(lhs: NilLiteralExprSyntax, rhs: NilLiteralExprSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct DiscardAssignmentExprSyntax: ExprSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case wildcard
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `DiscardAssignmentExprSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 1)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _wildcard = raw[Cursor.wildcardToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _wildcardTokenKind = _wildcard.tokenKind else {
      fatalError("expected token child, got \(_wildcard.kind)")
    }
    precondition([.wildcardKeyword].contains(_wildcardTokenKind),
      "expected one of [.wildcardKeyword] for 'wildcard' " + 
      "in node of kind discardAssignmentExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var wildcard: TokenSyntax {
    let child = data.cachedChild(at: Cursor.wildcard)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `wildcard` replaced.
  /// - param newChild: The new `wildcard` to replace the node's
  ///                   current `wildcard`, if present.
  public func withWildcard(
    _ newChild: TokenSyntax?) -> DiscardAssignmentExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.wildcardKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.wildcard)
    return DiscardAssignmentExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `DiscardAssignmentExprSyntax` nodes are equal to each other.
  public static func ==(lhs: DiscardAssignmentExprSyntax, rhs: DiscardAssignmentExprSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct AssignmentExprSyntax: ExprSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case assignToken
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `AssignmentExprSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 1)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _assignToken = raw[Cursor.equalToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _assignTokenTokenKind = _assignToken.tokenKind else {
      fatalError("expected token child, got \(_assignToken.kind)")
    }
    precondition([.equal].contains(_assignTokenTokenKind),
      "expected one of [.equal] for 'assignToken' " + 
      "in node of kind assignmentExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var assignToken: TokenSyntax {
    let child = data.cachedChild(at: Cursor.assignToken)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `assignToken` replaced.
  /// - param newChild: The new `assignToken` to replace the node's
  ///                   current `assignToken`, if present.
  public func withAssignToken(
    _ newChild: TokenSyntax?) -> AssignmentExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.equal)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.assignToken)
    return AssignmentExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `AssignmentExprSyntax` nodes are equal to each other.
  public static func ==(lhs: AssignmentExprSyntax, rhs: AssignmentExprSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct SequenceExprSyntax: ExprSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case elements
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `SequenceExprSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 1)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _elements = raw[Cursor.exprList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_elements.kind == .exprList,
                 "expected child of kind .exprList, " +
                 "got \(_elements.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var elements: ExprListSyntax {
    let child = data.cachedChild(at: Cursor.elements)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! ExprListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `Expression` to the node's `elements`
  /// collection.
  /// - param element: The new `Expression` to add to the node's
  ///                  `elements` collection.
  /// - returns: A copy of the receiver with the provided `Expression`
  ///            appended to its `elements` collection.
  public func addExpression(_ element: ExprSyntax) -> SequenceExprSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.elements] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.exprList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.elements)
    return SequenceExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `elements` replaced.
  /// - param newChild: The new `elements` to replace the node's
  ///                   current `elements`, if present.
  public func withElements(
    _ newChild: ExprListSyntax?) -> SequenceExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.exprList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.elements)
    return SequenceExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `SequenceExprSyntax` nodes are equal to each other.
  public static func ==(lhs: SequenceExprSyntax, rhs: SequenceExprSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct PoundLineExprSyntax: ExprSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case poundLine
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `PoundLineExprSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 1)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _poundLine = raw[Cursor.poundLineToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _poundLineTokenKind = _poundLine.tokenKind else {
      fatalError("expected token child, got \(_poundLine.kind)")
    }
    precondition([.poundLineKeyword].contains(_poundLineTokenKind),
      "expected one of [.poundLineKeyword] for 'poundLine' " + 
      "in node of kind poundLineExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var poundLine: TokenSyntax {
    let child = data.cachedChild(at: Cursor.poundLine)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `poundLine` replaced.
  /// - param newChild: The new `poundLine` to replace the node's
  ///                   current `poundLine`, if present.
  public func withPoundLine(
    _ newChild: TokenSyntax?) -> PoundLineExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.poundLineKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.poundLine)
    return PoundLineExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `PoundLineExprSyntax` nodes are equal to each other.
  public static func ==(lhs: PoundLineExprSyntax, rhs: PoundLineExprSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct PoundFileExprSyntax: ExprSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case poundFile
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `PoundFileExprSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 1)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _poundFile = raw[Cursor.poundFileToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _poundFileTokenKind = _poundFile.tokenKind else {
      fatalError("expected token child, got \(_poundFile.kind)")
    }
    precondition([.poundFileKeyword].contains(_poundFileTokenKind),
      "expected one of [.poundFileKeyword] for 'poundFile' " + 
      "in node of kind poundFileExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var poundFile: TokenSyntax {
    let child = data.cachedChild(at: Cursor.poundFile)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `poundFile` replaced.
  /// - param newChild: The new `poundFile` to replace the node's
  ///                   current `poundFile`, if present.
  public func withPoundFile(
    _ newChild: TokenSyntax?) -> PoundFileExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.poundFileKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.poundFile)
    return PoundFileExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `PoundFileExprSyntax` nodes are equal to each other.
  public static func ==(lhs: PoundFileExprSyntax, rhs: PoundFileExprSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct PoundFunctionExprSyntax: ExprSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case poundFunction
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `PoundFunctionExprSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 1)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _poundFunction = raw[Cursor.poundFunctionToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _poundFunctionTokenKind = _poundFunction.tokenKind else {
      fatalError("expected token child, got \(_poundFunction.kind)")
    }
    precondition([.poundFunctionKeyword].contains(_poundFunctionTokenKind),
      "expected one of [.poundFunctionKeyword] for 'poundFunction' " + 
      "in node of kind poundFunctionExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var poundFunction: TokenSyntax {
    let child = data.cachedChild(at: Cursor.poundFunction)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `poundFunction` replaced.
  /// - param newChild: The new `poundFunction` to replace the node's
  ///                   current `poundFunction`, if present.
  public func withPoundFunction(
    _ newChild: TokenSyntax?) -> PoundFunctionExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.poundFunctionKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.poundFunction)
    return PoundFunctionExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `PoundFunctionExprSyntax` nodes are equal to each other.
  public static func ==(lhs: PoundFunctionExprSyntax, rhs: PoundFunctionExprSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct PoundDsohandleExprSyntax: ExprSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case poundDsohandle
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `PoundDsohandleExprSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 1)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _poundDsohandle = raw[Cursor.poundDsohandleToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _poundDsohandleTokenKind = _poundDsohandle.tokenKind else {
      fatalError("expected token child, got \(_poundDsohandle.kind)")
    }
    precondition([.poundDsohandleKeyword].contains(_poundDsohandleTokenKind),
      "expected one of [.poundDsohandleKeyword] for 'poundDsohandle' " + 
      "in node of kind poundDsohandleExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var poundDsohandle: TokenSyntax {
    let child = data.cachedChild(at: Cursor.poundDsohandle)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `poundDsohandle` replaced.
  /// - param newChild: The new `poundDsohandle` to replace the node's
  ///                   current `poundDsohandle`, if present.
  public func withPoundDsohandle(
    _ newChild: TokenSyntax?) -> PoundDsohandleExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.poundDsohandleKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.poundDsohandle)
    return PoundDsohandleExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `PoundDsohandleExprSyntax` nodes are equal to each other.
  public static func ==(lhs: PoundDsohandleExprSyntax, rhs: PoundDsohandleExprSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct SymbolicReferenceExprSyntax: ExprSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case identifier
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case genericArgumentClause
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `SymbolicReferenceExprSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 2)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _identifier = raw[Cursor.identifierToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _identifierTokenKind = _identifier.tokenKind else {
      fatalError("expected token child, got \(_identifier.kind)")
    }
    precondition([.identifier].contains(_identifierTokenKind),
      "expected one of [.identifier] for 'identifier' " + 
      "in node of kind symbolicReferenceExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _genericArgumentClause = raw[Cursor.genericArgumentClause]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_genericArgumentClause.kind == .genericArgumentClause,
                 "expected child of kind .genericArgumentClause, " +
                 "got \(_genericArgumentClause.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var identifier: TokenSyntax {
    let child = data.cachedChild(at: Cursor.identifier)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `identifier` replaced.
  /// - param newChild: The new `identifier` to replace the node's
  ///                   current `identifier`, if present.
  public func withIdentifier(
    _ newChild: TokenSyntax?) -> SymbolicReferenceExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.identifier)
    return SymbolicReferenceExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var genericArgumentClause: GenericArgumentClauseSyntax? {
    let child = data.cachedChild(at: Cursor.genericArgumentClause)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? GenericArgumentClauseSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `genericArgumentClause` replaced.
  /// - param newChild: The new `genericArgumentClause` to replace the node's
  ///                   current `genericArgumentClause`, if present.
  public func withGenericArgumentClause(
    _ newChild: GenericArgumentClauseSyntax?) -> SymbolicReferenceExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.genericArgumentClause)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.genericArgumentClause)
    return SymbolicReferenceExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `SymbolicReferenceExprSyntax` nodes are equal to each other.
  public static func ==(lhs: SymbolicReferenceExprSyntax, rhs: SymbolicReferenceExprSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct PrefixOperatorExprSyntax: ExprSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case operatorToken
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case postfixExpression
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `PrefixOperatorExprSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 2)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _operatorToken = raw[Cursor.prefixOperatorToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _operatorTokenTokenKind = _operatorToken.tokenKind else {
      fatalError("expected token child, got \(_operatorToken.kind)")
    }
    precondition([.prefixOperator].contains(_operatorTokenTokenKind),
      "expected one of [.prefixOperator] for 'operatorToken' " + 
      "in node of kind prefixOperatorExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _postfixExpression = raw[Cursor.expr]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_postfixExpression.kind == .expr,
                 "expected child of kind .expr, " +
                 "got \(_postfixExpression.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var operatorToken: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.operatorToken)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `operatorToken` replaced.
  /// - param newChild: The new `operatorToken` to replace the node's
  ///                   current `operatorToken`, if present.
  public func withOperatorToken(
    _ newChild: TokenSyntax?) -> PrefixOperatorExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.prefixOperator(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.operatorToken)
    return PrefixOperatorExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var postfixExpression: ExprSyntax {
    let child = data.cachedChild(at: Cursor.postfixExpression)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! ExprSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `postfixExpression` replaced.
  /// - param newChild: The new `postfixExpression` to replace the node's
  ///                   current `postfixExpression`, if present.
  public func withPostfixExpression(
    _ newChild: ExprSyntax?) -> PrefixOperatorExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.postfixExpression)
    return PrefixOperatorExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `PrefixOperatorExprSyntax` nodes are equal to each other.
  public static func ==(lhs: PrefixOperatorExprSyntax, rhs: PrefixOperatorExprSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct BinaryOperatorExprSyntax: ExprSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case operatorToken
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `BinaryOperatorExprSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 1)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _operatorToken = raw[Cursor.binaryOperatorToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_operatorToken.kind == .binaryOperatorToken,
                 "expected child of kind .binaryOperatorToken, " +
                 "got \(_operatorToken.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var operatorToken: TokenSyntax {
    let child = data.cachedChild(at: Cursor.operatorToken)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `operatorToken` replaced.
  /// - param newChild: The new `operatorToken` to replace the node's
  ///                   current `operatorToken`, if present.
  public func withOperatorToken(
    _ newChild: TokenSyntax?) -> BinaryOperatorExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.unknown(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.operatorToken)
    return BinaryOperatorExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `BinaryOperatorExprSyntax` nodes are equal to each other.
  public static func ==(lhs: BinaryOperatorExprSyntax, rhs: BinaryOperatorExprSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct ArrowExprSyntax: ExprSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case throwsToken
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case arrowToken
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `ArrowExprSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 2)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _throwsToken = raw[Cursor.throwsToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _throwsTokenTokenKind = _throwsToken.tokenKind else {
      fatalError("expected token child, got \(_throwsToken.kind)")
    }
    precondition([.throwsKeyword].contains(_throwsTokenTokenKind),
      "expected one of [.throwsKeyword] for 'throwsToken' " + 
      "in node of kind arrowExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _arrowToken = raw[Cursor.arrowToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _arrowTokenTokenKind = _arrowToken.tokenKind else {
      fatalError("expected token child, got \(_arrowToken.kind)")
    }
    precondition([.arrow].contains(_arrowTokenTokenKind),
      "expected one of [.arrow] for 'arrowToken' " + 
      "in node of kind arrowExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var throwsToken: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.throwsToken)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `throwsToken` replaced.
  /// - param newChild: The new `throwsToken` to replace the node's
  ///                   current `throwsToken`, if present.
  public func withThrowsToken(
    _ newChild: TokenSyntax?) -> ArrowExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.throwsKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.throwsToken)
    return ArrowExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var arrowToken: TokenSyntax {
    let child = data.cachedChild(at: Cursor.arrowToken)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `arrowToken` replaced.
  /// - param newChild: The new `arrowToken` to replace the node's
  ///                   current `arrowToken`, if present.
  public func withArrowToken(
    _ newChild: TokenSyntax?) -> ArrowExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.arrow)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.arrowToken)
    return ArrowExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `ArrowExprSyntax` nodes are equal to each other.
  public static func ==(lhs: ArrowExprSyntax, rhs: ArrowExprSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct FloatLiteralExprSyntax: ExprSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case floatingDigits
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `FloatLiteralExprSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 1)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _floatingDigits = raw[Cursor.floatingLiteralToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _floatingDigitsTokenKind = _floatingDigits.tokenKind else {
      fatalError("expected token child, got \(_floatingDigits.kind)")
    }
    precondition([.floatingLiteral].contains(_floatingDigitsTokenKind),
      "expected one of [.floatingLiteral] for 'floatingDigits' " + 
      "in node of kind floatLiteralExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var floatingDigits: TokenSyntax {
    let child = data.cachedChild(at: Cursor.floatingDigits)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `floatingDigits` replaced.
  /// - param newChild: The new `floatingDigits` to replace the node's
  ///                   current `floatingDigits`, if present.
  public func withFloatingDigits(
    _ newChild: TokenSyntax?) -> FloatLiteralExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.floatingLiteral(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.floatingDigits)
    return FloatLiteralExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `FloatLiteralExprSyntax` nodes are equal to each other.
  public static func ==(lhs: FloatLiteralExprSyntax, rhs: FloatLiteralExprSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct TupleExprSyntax: ExprSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case leftParen
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case elementList
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case rightParen
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `TupleExprSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 3)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _leftParen = raw[Cursor.leftParenToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _leftParenTokenKind = _leftParen.tokenKind else {
      fatalError("expected token child, got \(_leftParen.kind)")
    }
    precondition([.leftParen].contains(_leftParenTokenKind),
      "expected one of [.leftParen] for 'leftParen' " + 
      "in node of kind tupleExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _elementList = raw[Cursor.tupleElementList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_elementList.kind == .tupleElementList,
                 "expected child of kind .tupleElementList, " +
                 "got \(_elementList.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _rightParen = raw[Cursor.rightParenToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _rightParenTokenKind = _rightParen.tokenKind else {
      fatalError("expected token child, got \(_rightParen.kind)")
    }
    precondition([.rightParen].contains(_rightParenTokenKind),
      "expected one of [.rightParen] for 'rightParen' " + 
      "in node of kind tupleExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var leftParen: TokenSyntax {
    let child = data.cachedChild(at: Cursor.leftParen)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `leftParen` replaced.
  /// - param newChild: The new `leftParen` to replace the node's
  ///                   current `leftParen`, if present.
  public func withLeftParen(
    _ newChild: TokenSyntax?) -> TupleExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftParen)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.leftParen)
    return TupleExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var elementList: TupleElementListSyntax {
    let child = data.cachedChild(at: Cursor.elementList)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TupleElementListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `TupleElement` to the node's `elementList`
  /// collection.
  /// - param element: The new `TupleElement` to add to the node's
  ///                  `elementList` collection.
  /// - returns: A copy of the receiver with the provided `TupleElement`
  ///            appended to its `elementList` collection.
  public func addTupleElement(_ element: TupleElementSyntax) -> TupleExprSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.elementList] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.tupleElementList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.elementList)
    return TupleExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `elementList` replaced.
  /// - param newChild: The new `elementList` to replace the node's
  ///                   current `elementList`, if present.
  public func withElementList(
    _ newChild: TupleElementListSyntax?) -> TupleExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.tupleElementList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.elementList)
    return TupleExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var rightParen: TokenSyntax {
    let child = data.cachedChild(at: Cursor.rightParen)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `rightParen` replaced.
  /// - param newChild: The new `rightParen` to replace the node's
  ///                   current `rightParen`, if present.
  public func withRightParen(
    _ newChild: TokenSyntax?) -> TupleExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightParen)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.rightParen)
    return TupleExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `TupleExprSyntax` nodes are equal to each other.
  public static func ==(lhs: TupleExprSyntax, rhs: TupleExprSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct ArrayExprSyntax: ExprSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case leftSquare
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case elements
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case rightSquare
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `ArrayExprSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 3)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _leftSquare = raw[Cursor.leftSquareBracketToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _leftSquareTokenKind = _leftSquare.tokenKind else {
      fatalError("expected token child, got \(_leftSquare.kind)")
    }
    precondition([.leftSquareBracket].contains(_leftSquareTokenKind),
      "expected one of [.leftSquareBracket] for 'leftSquare' " + 
      "in node of kind arrayExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _elements = raw[Cursor.arrayElementList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_elements.kind == .arrayElementList,
                 "expected child of kind .arrayElementList, " +
                 "got \(_elements.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _rightSquare = raw[Cursor.rightSquareBracketToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _rightSquareTokenKind = _rightSquare.tokenKind else {
      fatalError("expected token child, got \(_rightSquare.kind)")
    }
    precondition([.rightSquareBracket].contains(_rightSquareTokenKind),
      "expected one of [.rightSquareBracket] for 'rightSquare' " + 
      "in node of kind arrayExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var leftSquare: TokenSyntax {
    let child = data.cachedChild(at: Cursor.leftSquare)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `leftSquare` replaced.
  /// - param newChild: The new `leftSquare` to replace the node's
  ///                   current `leftSquare`, if present.
  public func withLeftSquare(
    _ newChild: TokenSyntax?) -> ArrayExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftSquareBracket)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.leftSquare)
    return ArrayExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var elements: ArrayElementListSyntax {
    let child = data.cachedChild(at: Cursor.elements)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! ArrayElementListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `ArrayElement` to the node's `elements`
  /// collection.
  /// - param element: The new `ArrayElement` to add to the node's
  ///                  `elements` collection.
  /// - returns: A copy of the receiver with the provided `ArrayElement`
  ///            appended to its `elements` collection.
  public func addArrayElement(_ element: ArrayElementSyntax) -> ArrayExprSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.elements] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.arrayElementList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.elements)
    return ArrayExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `elements` replaced.
  /// - param newChild: The new `elements` to replace the node's
  ///                   current `elements`, if present.
  public func withElements(
    _ newChild: ArrayElementListSyntax?) -> ArrayExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.arrayElementList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.elements)
    return ArrayExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var rightSquare: TokenSyntax {
    let child = data.cachedChild(at: Cursor.rightSquare)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `rightSquare` replaced.
  /// - param newChild: The new `rightSquare` to replace the node's
  ///                   current `rightSquare`, if present.
  public func withRightSquare(
    _ newChild: TokenSyntax?) -> ArrayExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightSquareBracket)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.rightSquare)
    return ArrayExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `ArrayExprSyntax` nodes are equal to each other.
  public static func ==(lhs: ArrayExprSyntax, rhs: ArrayExprSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct DictionaryExprSyntax: ExprSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case leftSquare
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case content
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case rightSquare
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `DictionaryExprSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 3)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _leftSquare = raw[Cursor.leftSquareBracketToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _leftSquareTokenKind = _leftSquare.tokenKind else {
      fatalError("expected token child, got \(_leftSquare.kind)")
    }
    precondition([.leftSquareBracket].contains(_leftSquareTokenKind),
      "expected one of [.leftSquareBracket] for 'leftSquare' " + 
      "in node of kind dictionaryExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _content = raw[Cursor.syntax]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_content.kind == .syntax,
                 "expected child of kind .syntax, " +
                 "got \(_content.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _rightSquare = raw[Cursor.rightSquareBracketToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _rightSquareTokenKind = _rightSquare.tokenKind else {
      fatalError("expected token child, got \(_rightSquare.kind)")
    }
    precondition([.rightSquareBracket].contains(_rightSquareTokenKind),
      "expected one of [.rightSquareBracket] for 'rightSquare' " + 
      "in node of kind dictionaryExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var leftSquare: TokenSyntax {
    let child = data.cachedChild(at: Cursor.leftSquare)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `leftSquare` replaced.
  /// - param newChild: The new `leftSquare` to replace the node's
  ///                   current `leftSquare`, if present.
  public func withLeftSquare(
    _ newChild: TokenSyntax?) -> DictionaryExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftSquareBracket)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.leftSquare)
    return DictionaryExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var content: Syntax {
    let child = data.cachedChild(at: Cursor.content)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) 
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `content` replaced.
  /// - param newChild: The new `content` to replace the node's
  ///                   current `content`, if present.
  public func withContent(
    _ newChild: Syntax?) -> DictionaryExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.unknown)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.content)
    return DictionaryExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var rightSquare: TokenSyntax {
    let child = data.cachedChild(at: Cursor.rightSquare)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `rightSquare` replaced.
  /// - param newChild: The new `rightSquare` to replace the node's
  ///                   current `rightSquare`, if present.
  public func withRightSquare(
    _ newChild: TokenSyntax?) -> DictionaryExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightSquareBracket)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.rightSquare)
    return DictionaryExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `DictionaryExprSyntax` nodes are equal to each other.
  public static func ==(lhs: DictionaryExprSyntax, rhs: DictionaryExprSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct ImplicitMemberExprSyntax: ExprSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case dot
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case name
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case declNameArguments
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `ImplicitMemberExprSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 3)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _dot = raw[Cursor.prefixPeriodToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _dotTokenKind = _dot.tokenKind else {
      fatalError("expected token child, got \(_dot.kind)")
    }
    precondition([.prefixPeriod].contains(_dotTokenKind),
      "expected one of [.prefixPeriod] for 'dot' " + 
      "in node of kind implicitMemberExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _name = raw[Cursor.token]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_name.kind == .token,
                 "expected child of kind .token, " +
                 "got \(_name.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _declNameArguments = raw[Cursor.declNameArguments]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_declNameArguments.kind == .declNameArguments,
                 "expected child of kind .declNameArguments, " +
                 "got \(_declNameArguments.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var dot: TokenSyntax {
    let child = data.cachedChild(at: Cursor.dot)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `dot` replaced.
  /// - param newChild: The new `dot` to replace the node's
  ///                   current `dot`, if present.
  public func withDot(
    _ newChild: TokenSyntax?) -> ImplicitMemberExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.prefixPeriod)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.dot)
    return ImplicitMemberExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var name: TokenSyntax {
    let child = data.cachedChild(at: Cursor.name)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `name` replaced.
  /// - param newChild: The new `name` to replace the node's
  ///                   current `name`, if present.
  public func withName(
    _ newChild: TokenSyntax?) -> ImplicitMemberExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.unknown(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.name)
    return ImplicitMemberExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var declNameArguments: DeclNameArgumentsSyntax? {
    let child = data.cachedChild(at: Cursor.declNameArguments)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? DeclNameArgumentsSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `declNameArguments` replaced.
  /// - param newChild: The new `declNameArguments` to replace the node's
  ///                   current `declNameArguments`, if present.
  public func withDeclNameArguments(
    _ newChild: DeclNameArgumentsSyntax?) -> ImplicitMemberExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.declNameArguments)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.declNameArguments)
    return ImplicitMemberExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `ImplicitMemberExprSyntax` nodes are equal to each other.
  public static func ==(lhs: ImplicitMemberExprSyntax, rhs: ImplicitMemberExprSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct FunctionCallArgumentSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case label
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case colon
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case expression
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case trailingComma
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `FunctionCallArgumentSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 4)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _label = raw[Cursor.identifierToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _labelTokenKind = _label.tokenKind else {
      fatalError("expected token child, got \(_label.kind)")
    }
    precondition([.identifier].contains(_labelTokenKind),
      "expected one of [.identifier] for 'label' " + 
      "in node of kind functionCallArgument")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _colon = raw[Cursor.colonToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _colonTokenKind = _colon.tokenKind else {
      fatalError("expected token child, got \(_colon.kind)")
    }
    precondition([.colon].contains(_colonTokenKind),
      "expected one of [.colon] for 'colon' " + 
      "in node of kind functionCallArgument")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _expression = raw[Cursor.expr]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_expression.kind == .expr,
                 "expected child of kind .expr, " +
                 "got \(_expression.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _trailingComma = raw[Cursor.commaToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _trailingCommaTokenKind = _trailingComma.tokenKind else {
      fatalError("expected token child, got \(_trailingComma.kind)")
    }
    precondition([.comma].contains(_trailingCommaTokenKind),
      "expected one of [.comma] for 'trailingComma' " + 
      "in node of kind functionCallArgument")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var label: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.label)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `label` replaced.
  /// - param newChild: The new `label` to replace the node's
  ///                   current `label`, if present.
  public func withLabel(
    _ newChild: TokenSyntax?) -> FunctionCallArgumentSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.label)
    return FunctionCallArgumentSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var colon: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.colon)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `colon` replaced.
  /// - param newChild: The new `colon` to replace the node's
  ///                   current `colon`, if present.
  public func withColon(
    _ newChild: TokenSyntax?) -> FunctionCallArgumentSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.colon)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.colon)
    return FunctionCallArgumentSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var expression: ExprSyntax {
    let child = data.cachedChild(at: Cursor.expression)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! ExprSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `expression` replaced.
  /// - param newChild: The new `expression` to replace the node's
  ///                   current `expression`, if present.
  public func withExpression(
    _ newChild: ExprSyntax?) -> FunctionCallArgumentSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.expression)
    return FunctionCallArgumentSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var trailingComma: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.trailingComma)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `trailingComma` replaced.
  /// - param newChild: The new `trailingComma` to replace the node's
  ///                   current `trailingComma`, if present.
  public func withTrailingComma(
    _ newChild: TokenSyntax?) -> FunctionCallArgumentSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.comma)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.trailingComma)
    return FunctionCallArgumentSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `FunctionCallArgumentSyntax` nodes are equal to each other.
  public static func ==(lhs: FunctionCallArgumentSyntax, rhs: FunctionCallArgumentSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct TupleElementSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case label
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case colon
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case expression
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case trailingComma
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `TupleElementSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 4)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _label = raw[Cursor.identifierToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _labelTokenKind = _label.tokenKind else {
      fatalError("expected token child, got \(_label.kind)")
    }
    precondition([.identifier].contains(_labelTokenKind),
      "expected one of [.identifier] for 'label' " + 
      "in node of kind tupleElement")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _colon = raw[Cursor.colonToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _colonTokenKind = _colon.tokenKind else {
      fatalError("expected token child, got \(_colon.kind)")
    }
    precondition([.colon].contains(_colonTokenKind),
      "expected one of [.colon] for 'colon' " + 
      "in node of kind tupleElement")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _expression = raw[Cursor.expr]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_expression.kind == .expr,
                 "expected child of kind .expr, " +
                 "got \(_expression.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _trailingComma = raw[Cursor.commaToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _trailingCommaTokenKind = _trailingComma.tokenKind else {
      fatalError("expected token child, got \(_trailingComma.kind)")
    }
    precondition([.comma].contains(_trailingCommaTokenKind),
      "expected one of [.comma] for 'trailingComma' " + 
      "in node of kind tupleElement")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var label: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.label)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `label` replaced.
  /// - param newChild: The new `label` to replace the node's
  ///                   current `label`, if present.
  public func withLabel(
    _ newChild: TokenSyntax?) -> TupleElementSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.label)
    return TupleElementSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var colon: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.colon)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `colon` replaced.
  /// - param newChild: The new `colon` to replace the node's
  ///                   current `colon`, if present.
  public func withColon(
    _ newChild: TokenSyntax?) -> TupleElementSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.colon)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.colon)
    return TupleElementSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var expression: ExprSyntax {
    let child = data.cachedChild(at: Cursor.expression)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! ExprSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `expression` replaced.
  /// - param newChild: The new `expression` to replace the node's
  ///                   current `expression`, if present.
  public func withExpression(
    _ newChild: ExprSyntax?) -> TupleElementSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.expression)
    return TupleElementSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var trailingComma: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.trailingComma)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `trailingComma` replaced.
  /// - param newChild: The new `trailingComma` to replace the node's
  ///                   current `trailingComma`, if present.
  public func withTrailingComma(
    _ newChild: TokenSyntax?) -> TupleElementSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.comma)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.trailingComma)
    return TupleElementSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `TupleElementSyntax` nodes are equal to each other.
  public static func ==(lhs: TupleElementSyntax, rhs: TupleElementSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct ArrayElementSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case expression
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case trailingComma
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `ArrayElementSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 2)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _expression = raw[Cursor.expr]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_expression.kind == .expr,
                 "expected child of kind .expr, " +
                 "got \(_expression.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _trailingComma = raw[Cursor.commaToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _trailingCommaTokenKind = _trailingComma.tokenKind else {
      fatalError("expected token child, got \(_trailingComma.kind)")
    }
    precondition([.comma].contains(_trailingCommaTokenKind),
      "expected one of [.comma] for 'trailingComma' " + 
      "in node of kind arrayElement")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var expression: ExprSyntax {
    let child = data.cachedChild(at: Cursor.expression)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! ExprSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `expression` replaced.
  /// - param newChild: The new `expression` to replace the node's
  ///                   current `expression`, if present.
  public func withExpression(
    _ newChild: ExprSyntax?) -> ArrayElementSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.expression)
    return ArrayElementSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var trailingComma: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.trailingComma)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `trailingComma` replaced.
  /// - param newChild: The new `trailingComma` to replace the node's
  ///                   current `trailingComma`, if present.
  public func withTrailingComma(
    _ newChild: TokenSyntax?) -> ArrayElementSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.comma)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.trailingComma)
    return ArrayElementSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `ArrayElementSyntax` nodes are equal to each other.
  public static func ==(lhs: ArrayElementSyntax, rhs: ArrayElementSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct DictionaryElementSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case keyExpression
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case colon
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case valueExpression
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case trailingComma
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `DictionaryElementSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 4)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _keyExpression = raw[Cursor.expr]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_keyExpression.kind == .expr,
                 "expected child of kind .expr, " +
                 "got \(_keyExpression.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _colon = raw[Cursor.colonToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _colonTokenKind = _colon.tokenKind else {
      fatalError("expected token child, got \(_colon.kind)")
    }
    precondition([.colon].contains(_colonTokenKind),
      "expected one of [.colon] for 'colon' " + 
      "in node of kind dictionaryElement")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _valueExpression = raw[Cursor.expr]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_valueExpression.kind == .expr,
                 "expected child of kind .expr, " +
                 "got \(_valueExpression.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _trailingComma = raw[Cursor.commaToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _trailingCommaTokenKind = _trailingComma.tokenKind else {
      fatalError("expected token child, got \(_trailingComma.kind)")
    }
    precondition([.comma].contains(_trailingCommaTokenKind),
      "expected one of [.comma] for 'trailingComma' " + 
      "in node of kind dictionaryElement")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var keyExpression: ExprSyntax {
    let child = data.cachedChild(at: Cursor.keyExpression)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! ExprSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `keyExpression` replaced.
  /// - param newChild: The new `keyExpression` to replace the node's
  ///                   current `keyExpression`, if present.
  public func withKeyExpression(
    _ newChild: ExprSyntax?) -> DictionaryElementSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.keyExpression)
    return DictionaryElementSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var colon: TokenSyntax {
    let child = data.cachedChild(at: Cursor.colon)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `colon` replaced.
  /// - param newChild: The new `colon` to replace the node's
  ///                   current `colon`, if present.
  public func withColon(
    _ newChild: TokenSyntax?) -> DictionaryElementSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.colon)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.colon)
    return DictionaryElementSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var valueExpression: ExprSyntax {
    let child = data.cachedChild(at: Cursor.valueExpression)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! ExprSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `valueExpression` replaced.
  /// - param newChild: The new `valueExpression` to replace the node's
  ///                   current `valueExpression`, if present.
  public func withValueExpression(
    _ newChild: ExprSyntax?) -> DictionaryElementSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.valueExpression)
    return DictionaryElementSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var trailingComma: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.trailingComma)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `trailingComma` replaced.
  /// - param newChild: The new `trailingComma` to replace the node's
  ///                   current `trailingComma`, if present.
  public func withTrailingComma(
    _ newChild: TokenSyntax?) -> DictionaryElementSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.comma)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.trailingComma)
    return DictionaryElementSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `DictionaryElementSyntax` nodes are equal to each other.
  public static func ==(lhs: DictionaryElementSyntax, rhs: DictionaryElementSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct IntegerLiteralExprSyntax: ExprSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case digits
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `IntegerLiteralExprSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 1)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _digits = raw[Cursor.integerLiteralToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _digitsTokenKind = _digits.tokenKind else {
      fatalError("expected token child, got \(_digits.kind)")
    }
    precondition([.integerLiteral].contains(_digitsTokenKind),
      "expected one of [.integerLiteral] for 'digits' " + 
      "in node of kind integerLiteralExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var digits: TokenSyntax {
    let child = data.cachedChild(at: Cursor.digits)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `digits` replaced.
  /// - param newChild: The new `digits` to replace the node's
  ///                   current `digits`, if present.
  public func withDigits(
    _ newChild: TokenSyntax?) -> IntegerLiteralExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.integerLiteral(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.digits)
    return IntegerLiteralExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `IntegerLiteralExprSyntax` nodes are equal to each other.
  public static func ==(lhs: IntegerLiteralExprSyntax, rhs: IntegerLiteralExprSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct StringLiteralExprSyntax: ExprSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case stringLiteral
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `StringLiteralExprSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 1)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _stringLiteral = raw[Cursor.stringLiteralToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _stringLiteralTokenKind = _stringLiteral.tokenKind else {
      fatalError("expected token child, got \(_stringLiteral.kind)")
    }
    precondition([.stringLiteral].contains(_stringLiteralTokenKind),
      "expected one of [.stringLiteral] for 'stringLiteral' " + 
      "in node of kind stringLiteralExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var stringLiteral: TokenSyntax {
    let child = data.cachedChild(at: Cursor.stringLiteral)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `stringLiteral` replaced.
  /// - param newChild: The new `stringLiteral` to replace the node's
  ///                   current `stringLiteral`, if present.
  public func withStringLiteral(
    _ newChild: TokenSyntax?) -> StringLiteralExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.stringLiteral(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.stringLiteral)
    return StringLiteralExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `StringLiteralExprSyntax` nodes are equal to each other.
  public static func ==(lhs: StringLiteralExprSyntax, rhs: StringLiteralExprSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct BooleanLiteralExprSyntax: ExprSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case booleanLiteral
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `BooleanLiteralExprSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 1)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _booleanLiteral = raw[Cursor.token]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _booleanLiteralTokenKind = _booleanLiteral.tokenKind else {
      fatalError("expected token child, got \(_booleanLiteral.kind)")
    }
    precondition([.trueKeyword, .falseKeyword].contains(_booleanLiteralTokenKind),
      "expected one of [.trueKeyword, .falseKeyword] for 'booleanLiteral' " + 
      "in node of kind booleanLiteralExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var booleanLiteral: TokenSyntax {
    let child = data.cachedChild(at: Cursor.booleanLiteral)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `booleanLiteral` replaced.
  /// - param newChild: The new `booleanLiteral` to replace the node's
  ///                   current `booleanLiteral`, if present.
  public func withBooleanLiteral(
    _ newChild: TokenSyntax?) -> BooleanLiteralExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.trueKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.booleanLiteral)
    return BooleanLiteralExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `BooleanLiteralExprSyntax` nodes are equal to each other.
  public static func ==(lhs: BooleanLiteralExprSyntax, rhs: BooleanLiteralExprSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct TernaryExprSyntax: ExprSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case conditionExpression
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case questionMark
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case firstChoice
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case colonMark
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case secondChoice
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `TernaryExprSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 5)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _conditionExpression = raw[Cursor.expr]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_conditionExpression.kind == .expr,
                 "expected child of kind .expr, " +
                 "got \(_conditionExpression.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _questionMark = raw[Cursor.infixQuestionMarkToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _questionMarkTokenKind = _questionMark.tokenKind else {
      fatalError("expected token child, got \(_questionMark.kind)")
    }
    precondition([.infixQuestionMark].contains(_questionMarkTokenKind),
      "expected one of [.infixQuestionMark] for 'questionMark' " + 
      "in node of kind ternaryExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _firstChoice = raw[Cursor.expr]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_firstChoice.kind == .expr,
                 "expected child of kind .expr, " +
                 "got \(_firstChoice.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _colonMark = raw[Cursor.colonToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _colonMarkTokenKind = _colonMark.tokenKind else {
      fatalError("expected token child, got \(_colonMark.kind)")
    }
    precondition([.colon].contains(_colonMarkTokenKind),
      "expected one of [.colon] for 'colonMark' " + 
      "in node of kind ternaryExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _secondChoice = raw[Cursor.expr]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_secondChoice.kind == .expr,
                 "expected child of kind .expr, " +
                 "got \(_secondChoice.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var conditionExpression: ExprSyntax {
    let child = data.cachedChild(at: Cursor.conditionExpression)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! ExprSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `conditionExpression` replaced.
  /// - param newChild: The new `conditionExpression` to replace the node's
  ///                   current `conditionExpression`, if present.
  public func withConditionExpression(
    _ newChild: ExprSyntax?) -> TernaryExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.conditionExpression)
    return TernaryExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var questionMark: TokenSyntax {
    let child = data.cachedChild(at: Cursor.questionMark)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `questionMark` replaced.
  /// - param newChild: The new `questionMark` to replace the node's
  ///                   current `questionMark`, if present.
  public func withQuestionMark(
    _ newChild: TokenSyntax?) -> TernaryExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.infixQuestionMark)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.questionMark)
    return TernaryExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var firstChoice: ExprSyntax {
    let child = data.cachedChild(at: Cursor.firstChoice)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! ExprSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `firstChoice` replaced.
  /// - param newChild: The new `firstChoice` to replace the node's
  ///                   current `firstChoice`, if present.
  public func withFirstChoice(
    _ newChild: ExprSyntax?) -> TernaryExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.firstChoice)
    return TernaryExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var colonMark: TokenSyntax {
    let child = data.cachedChild(at: Cursor.colonMark)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `colonMark` replaced.
  /// - param newChild: The new `colonMark` to replace the node's
  ///                   current `colonMark`, if present.
  public func withColonMark(
    _ newChild: TokenSyntax?) -> TernaryExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.colon)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.colonMark)
    return TernaryExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var secondChoice: ExprSyntax {
    let child = data.cachedChild(at: Cursor.secondChoice)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! ExprSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `secondChoice` replaced.
  /// - param newChild: The new `secondChoice` to replace the node's
  ///                   current `secondChoice`, if present.
  public func withSecondChoice(
    _ newChild: ExprSyntax?) -> TernaryExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.secondChoice)
    return TernaryExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `TernaryExprSyntax` nodes are equal to each other.
  public static func ==(lhs: TernaryExprSyntax, rhs: TernaryExprSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct MemberAccessExprSyntax: ExprSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case base
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case dot
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case name
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case declNameArguments
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `MemberAccessExprSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 4)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _base = raw[Cursor.expr]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_base.kind == .expr,
                 "expected child of kind .expr, " +
                 "got \(_base.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _dot = raw[Cursor.periodToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _dotTokenKind = _dot.tokenKind else {
      fatalError("expected token child, got \(_dot.kind)")
    }
    precondition([.period].contains(_dotTokenKind),
      "expected one of [.period] for 'dot' " + 
      "in node of kind memberAccessExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _name = raw[Cursor.token]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_name.kind == .token,
                 "expected child of kind .token, " +
                 "got \(_name.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _declNameArguments = raw[Cursor.declNameArguments]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_declNameArguments.kind == .declNameArguments,
                 "expected child of kind .declNameArguments, " +
                 "got \(_declNameArguments.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var base: ExprSyntax? {
    let child = data.cachedChild(at: Cursor.base)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? ExprSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `base` replaced.
  /// - param newChild: The new `base` to replace the node's
  ///                   current `base`, if present.
  public func withBase(
    _ newChild: ExprSyntax?) -> MemberAccessExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.base)
    return MemberAccessExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var dot: TokenSyntax {
    let child = data.cachedChild(at: Cursor.dot)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `dot` replaced.
  /// - param newChild: The new `dot` to replace the node's
  ///                   current `dot`, if present.
  public func withDot(
    _ newChild: TokenSyntax?) -> MemberAccessExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.period)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.dot)
    return MemberAccessExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var name: TokenSyntax {
    let child = data.cachedChild(at: Cursor.name)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `name` replaced.
  /// - param newChild: The new `name` to replace the node's
  ///                   current `name`, if present.
  public func withName(
    _ newChild: TokenSyntax?) -> MemberAccessExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.unknown(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.name)
    return MemberAccessExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var declNameArguments: DeclNameArgumentsSyntax? {
    let child = data.cachedChild(at: Cursor.declNameArguments)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? DeclNameArgumentsSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `declNameArguments` replaced.
  /// - param newChild: The new `declNameArguments` to replace the node's
  ///                   current `declNameArguments`, if present.
  public func withDeclNameArguments(
    _ newChild: DeclNameArgumentsSyntax?) -> MemberAccessExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.declNameArguments)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.declNameArguments)
    return MemberAccessExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `MemberAccessExprSyntax` nodes are equal to each other.
  public static func ==(lhs: MemberAccessExprSyntax, rhs: MemberAccessExprSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct DotSelfExprSyntax: ExprSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case expression
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case dot
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case selfKeyword
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `DotSelfExprSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 3)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _expression = raw[Cursor.expr]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_expression.kind == .expr,
                 "expected child of kind .expr, " +
                 "got \(_expression.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _dot = raw[Cursor.token]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _dotTokenKind = _dot.tokenKind else {
      fatalError("expected token child, got \(_dot.kind)")
    }
    precondition([.period, .prefixPeriod].contains(_dotTokenKind),
      "expected one of [.period, .prefixPeriod] for 'dot' " + 
      "in node of kind dotSelfExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _selfKeyword = raw[Cursor.selfToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _selfKeywordTokenKind = _selfKeyword.tokenKind else {
      fatalError("expected token child, got \(_selfKeyword.kind)")
    }
    precondition([.selfKeyword].contains(_selfKeywordTokenKind),
      "expected one of [.selfKeyword] for 'selfKeyword' " + 
      "in node of kind dotSelfExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var expression: ExprSyntax {
    let child = data.cachedChild(at: Cursor.expression)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! ExprSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `expression` replaced.
  /// - param newChild: The new `expression` to replace the node's
  ///                   current `expression`, if present.
  public func withExpression(
    _ newChild: ExprSyntax?) -> DotSelfExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.expression)
    return DotSelfExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var dot: TokenSyntax {
    let child = data.cachedChild(at: Cursor.dot)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `dot` replaced.
  /// - param newChild: The new `dot` to replace the node's
  ///                   current `dot`, if present.
  public func withDot(
    _ newChild: TokenSyntax?) -> DotSelfExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.period)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.dot)
    return DotSelfExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var selfKeyword: TokenSyntax {
    let child = data.cachedChild(at: Cursor.selfKeyword)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `selfKeyword` replaced.
  /// - param newChild: The new `selfKeyword` to replace the node's
  ///                   current `selfKeyword`, if present.
  public func withSelfKeyword(
    _ newChild: TokenSyntax?) -> DotSelfExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.selfKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.selfKeyword)
    return DotSelfExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `DotSelfExprSyntax` nodes are equal to each other.
  public static func ==(lhs: DotSelfExprSyntax, rhs: DotSelfExprSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct IsExprSyntax: ExprSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case isTok
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case typeName
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `IsExprSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 2)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _isTok = raw[Cursor.isToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _isTokTokenKind = _isTok.tokenKind else {
      fatalError("expected token child, got \(_isTok.kind)")
    }
    precondition([.isKeyword].contains(_isTokTokenKind),
      "expected one of [.isKeyword] for 'isTok' " + 
      "in node of kind isExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _typeName = raw[Cursor.type]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_typeName.kind == .type,
                 "expected child of kind .type, " +
                 "got \(_typeName.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var isTok: TokenSyntax {
    let child = data.cachedChild(at: Cursor.isTok)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `isTok` replaced.
  /// - param newChild: The new `isTok` to replace the node's
  ///                   current `isTok`, if present.
  public func withIsTok(
    _ newChild: TokenSyntax?) -> IsExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.isKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.isTok)
    return IsExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var typeName: TypeSyntax {
    let child = data.cachedChild(at: Cursor.typeName)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TypeSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `typeName` replaced.
  /// - param newChild: The new `typeName` to replace the node's
  ///                   current `typeName`, if present.
  public func withTypeName(
    _ newChild: TypeSyntax?) -> IsExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.type)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.typeName)
    return IsExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `IsExprSyntax` nodes are equal to each other.
  public static func ==(lhs: IsExprSyntax, rhs: IsExprSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct AsExprSyntax: ExprSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case asTok
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case questionOrExclamationMark
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case typeName
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `AsExprSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 3)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _asTok = raw[Cursor.asToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _asTokTokenKind = _asTok.tokenKind else {
      fatalError("expected token child, got \(_asTok.kind)")
    }
    precondition([.asKeyword].contains(_asTokTokenKind),
      "expected one of [.asKeyword] for 'asTok' " + 
      "in node of kind asExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _questionOrExclamationMark = raw[Cursor.token]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _questionOrExclamationMarkTokenKind = _questionOrExclamationMark.tokenKind else {
      fatalError("expected token child, got \(_questionOrExclamationMark.kind)")
    }
    precondition([.postfixQuestionMark, .exclamationMark].contains(_questionOrExclamationMarkTokenKind),
      "expected one of [.postfixQuestionMark, .exclamationMark] for 'questionOrExclamationMark' " + 
      "in node of kind asExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _typeName = raw[Cursor.type]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_typeName.kind == .type,
                 "expected child of kind .type, " +
                 "got \(_typeName.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var asTok: TokenSyntax {
    let child = data.cachedChild(at: Cursor.asTok)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `asTok` replaced.
  /// - param newChild: The new `asTok` to replace the node's
  ///                   current `asTok`, if present.
  public func withAsTok(
    _ newChild: TokenSyntax?) -> AsExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.asKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.asTok)
    return AsExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var questionOrExclamationMark: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.questionOrExclamationMark)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `questionOrExclamationMark` replaced.
  /// - param newChild: The new `questionOrExclamationMark` to replace the node's
  ///                   current `questionOrExclamationMark`, if present.
  public func withQuestionOrExclamationMark(
    _ newChild: TokenSyntax?) -> AsExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.postfixQuestionMark)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.questionOrExclamationMark)
    return AsExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var typeName: TypeSyntax {
    let child = data.cachedChild(at: Cursor.typeName)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TypeSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `typeName` replaced.
  /// - param newChild: The new `typeName` to replace the node's
  ///                   current `typeName`, if present.
  public func withTypeName(
    _ newChild: TypeSyntax?) -> AsExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.type)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.typeName)
    return AsExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `AsExprSyntax` nodes are equal to each other.
  public static func ==(lhs: AsExprSyntax, rhs: AsExprSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct TypeExprSyntax: ExprSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case type
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `TypeExprSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 1)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _type = raw[Cursor.type]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_type.kind == .type,
                 "expected child of kind .type, " +
                 "got \(_type.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var type: TypeSyntax {
    let child = data.cachedChild(at: Cursor.type)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TypeSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `type` replaced.
  /// - param newChild: The new `type` to replace the node's
  ///                   current `type`, if present.
  public func withType(
    _ newChild: TypeSyntax?) -> TypeExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.type)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.type)
    return TypeExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `TypeExprSyntax` nodes are equal to each other.
  public static func ==(lhs: TypeExprSyntax, rhs: TypeExprSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct ClosureCaptureItemSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case specifier
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case name
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case assignToken
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case expression
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case trailingComma
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `ClosureCaptureItemSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 5)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _specifier = raw[Cursor.tokenList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_specifier.kind == .tokenList,
                 "expected child of kind .tokenList, " +
                 "got \(_specifier.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _name = raw[Cursor.identifierToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _nameTokenKind = _name.tokenKind else {
      fatalError("expected token child, got \(_name.kind)")
    }
    precondition([.identifier].contains(_nameTokenKind),
      "expected one of [.identifier] for 'name' " + 
      "in node of kind closureCaptureItem")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _assignToken = raw[Cursor.equalToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _assignTokenTokenKind = _assignToken.tokenKind else {
      fatalError("expected token child, got \(_assignToken.kind)")
    }
    precondition([.equal].contains(_assignTokenTokenKind),
      "expected one of [.equal] for 'assignToken' " + 
      "in node of kind closureCaptureItem")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _expression = raw[Cursor.expr]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_expression.kind == .expr,
                 "expected child of kind .expr, " +
                 "got \(_expression.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _trailingComma = raw[Cursor.commaToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _trailingCommaTokenKind = _trailingComma.tokenKind else {
      fatalError("expected token child, got \(_trailingComma.kind)")
    }
    precondition([.comma].contains(_trailingCommaTokenKind),
      "expected one of [.comma] for 'trailingComma' " + 
      "in node of kind closureCaptureItem")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var specifier: TokenListSyntax? {
    let child = data.cachedChild(at: Cursor.specifier)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `Token` to the node's `specifier`
  /// collection.
  /// - param element: The new `Token` to add to the node's
  ///                  `specifier` collection.
  /// - returns: A copy of the receiver with the provided `Token`
  ///            appended to its `specifier` collection.
  public func addToken(_ element: TokenSyntax) -> ClosureCaptureItemSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.specifier] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.tokenList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.specifier)
    return ClosureCaptureItemSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `specifier` replaced.
  /// - param newChild: The new `specifier` to replace the node's
  ///                   current `specifier`, if present.
  public func withSpecifier(
    _ newChild: TokenListSyntax?) -> ClosureCaptureItemSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.unknown(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.specifier)
    return ClosureCaptureItemSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var name: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.name)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `name` replaced.
  /// - param newChild: The new `name` to replace the node's
  ///                   current `name`, if present.
  public func withName(
    _ newChild: TokenSyntax?) -> ClosureCaptureItemSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.name)
    return ClosureCaptureItemSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var assignToken: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.assignToken)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `assignToken` replaced.
  /// - param newChild: The new `assignToken` to replace the node's
  ///                   current `assignToken`, if present.
  public func withAssignToken(
    _ newChild: TokenSyntax?) -> ClosureCaptureItemSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.equal)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.assignToken)
    return ClosureCaptureItemSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var expression: ExprSyntax {
    let child = data.cachedChild(at: Cursor.expression)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! ExprSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `expression` replaced.
  /// - param newChild: The new `expression` to replace the node's
  ///                   current `expression`, if present.
  public func withExpression(
    _ newChild: ExprSyntax?) -> ClosureCaptureItemSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.expression)
    return ClosureCaptureItemSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var trailingComma: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.trailingComma)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `trailingComma` replaced.
  /// - param newChild: The new `trailingComma` to replace the node's
  ///                   current `trailingComma`, if present.
  public func withTrailingComma(
    _ newChild: TokenSyntax?) -> ClosureCaptureItemSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.comma)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.trailingComma)
    return ClosureCaptureItemSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `ClosureCaptureItemSyntax` nodes are equal to each other.
  public static func ==(lhs: ClosureCaptureItemSyntax, rhs: ClosureCaptureItemSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct ClosureCaptureSignatureSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case leftSquare
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case items
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case rightSquare
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `ClosureCaptureSignatureSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 3)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _leftSquare = raw[Cursor.leftSquareBracketToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _leftSquareTokenKind = _leftSquare.tokenKind else {
      fatalError("expected token child, got \(_leftSquare.kind)")
    }
    precondition([.leftSquareBracket].contains(_leftSquareTokenKind),
      "expected one of [.leftSquareBracket] for 'leftSquare' " + 
      "in node of kind closureCaptureSignature")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _items = raw[Cursor.closureCaptureItemList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_items.kind == .closureCaptureItemList,
                 "expected child of kind .closureCaptureItemList, " +
                 "got \(_items.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _rightSquare = raw[Cursor.rightSquareBracketToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _rightSquareTokenKind = _rightSquare.tokenKind else {
      fatalError("expected token child, got \(_rightSquare.kind)")
    }
    precondition([.rightSquareBracket].contains(_rightSquareTokenKind),
      "expected one of [.rightSquareBracket] for 'rightSquare' " + 
      "in node of kind closureCaptureSignature")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var leftSquare: TokenSyntax {
    let child = data.cachedChild(at: Cursor.leftSquare)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `leftSquare` replaced.
  /// - param newChild: The new `leftSquare` to replace the node's
  ///                   current `leftSquare`, if present.
  public func withLeftSquare(
    _ newChild: TokenSyntax?) -> ClosureCaptureSignatureSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftSquareBracket)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.leftSquare)
    return ClosureCaptureSignatureSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var items: ClosureCaptureItemListSyntax? {
    let child = data.cachedChild(at: Cursor.items)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? ClosureCaptureItemListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `ClosureCaptureItem` to the node's `items`
  /// collection.
  /// - param element: The new `ClosureCaptureItem` to add to the node's
  ///                  `items` collection.
  /// - returns: A copy of the receiver with the provided `ClosureCaptureItem`
  ///            appended to its `items` collection.
  public func addClosureCaptureItem(_ element: ClosureCaptureItemSyntax) -> ClosureCaptureSignatureSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.items] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.closureCaptureItemList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.items)
    return ClosureCaptureSignatureSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `items` replaced.
  /// - param newChild: The new `items` to replace the node's
  ///                   current `items`, if present.
  public func withItems(
    _ newChild: ClosureCaptureItemListSyntax?) -> ClosureCaptureSignatureSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.closureCaptureItemList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.items)
    return ClosureCaptureSignatureSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var rightSquare: TokenSyntax {
    let child = data.cachedChild(at: Cursor.rightSquare)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `rightSquare` replaced.
  /// - param newChild: The new `rightSquare` to replace the node's
  ///                   current `rightSquare`, if present.
  public func withRightSquare(
    _ newChild: TokenSyntax?) -> ClosureCaptureSignatureSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightSquareBracket)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.rightSquare)
    return ClosureCaptureSignatureSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `ClosureCaptureSignatureSyntax` nodes are equal to each other.
  public static func ==(lhs: ClosureCaptureSignatureSyntax, rhs: ClosureCaptureSignatureSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct ClosureParamSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case name
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case trailingComma
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `ClosureParamSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 2)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _name = raw[Cursor.token]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _nameTokenKind = _name.tokenKind else {
      fatalError("expected token child, got \(_name.kind)")
    }
    precondition([.identifier, .wildcardKeyword].contains(_nameTokenKind),
      "expected one of [.identifier, .wildcardKeyword] for 'name' " + 
      "in node of kind closureParam")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _trailingComma = raw[Cursor.commaToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _trailingCommaTokenKind = _trailingComma.tokenKind else {
      fatalError("expected token child, got \(_trailingComma.kind)")
    }
    precondition([.comma].contains(_trailingCommaTokenKind),
      "expected one of [.comma] for 'trailingComma' " + 
      "in node of kind closureParam")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var name: TokenSyntax {
    let child = data.cachedChild(at: Cursor.name)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `name` replaced.
  /// - param newChild: The new `name` to replace the node's
  ///                   current `name`, if present.
  public func withName(
    _ newChild: TokenSyntax?) -> ClosureParamSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.name)
    return ClosureParamSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var trailingComma: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.trailingComma)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `trailingComma` replaced.
  /// - param newChild: The new `trailingComma` to replace the node's
  ///                   current `trailingComma`, if present.
  public func withTrailingComma(
    _ newChild: TokenSyntax?) -> ClosureParamSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.comma)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.trailingComma)
    return ClosureParamSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `ClosureParamSyntax` nodes are equal to each other.
  public static func ==(lhs: ClosureParamSyntax, rhs: ClosureParamSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct ClosureSignatureSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case capture
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case input
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case throwsTok
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case output
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case inTok
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `ClosureSignatureSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 5)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _capture = raw[Cursor.closureCaptureSignature]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_capture.kind == .closureCaptureSignature,
                 "expected child of kind .closureCaptureSignature, " +
                 "got \(_capture.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _input = raw[Cursor.syntax]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_input.kind == .syntax,
                 "expected child of kind .syntax, " +
                 "got \(_input.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _throwsTok = raw[Cursor.throwsToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _throwsTokTokenKind = _throwsTok.tokenKind else {
      fatalError("expected token child, got \(_throwsTok.kind)")
    }
    precondition([.throwsKeyword].contains(_throwsTokTokenKind),
      "expected one of [.throwsKeyword] for 'throwsTok' " + 
      "in node of kind closureSignature")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _output = raw[Cursor.returnClause]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_output.kind == .returnClause,
                 "expected child of kind .returnClause, " +
                 "got \(_output.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _inTok = raw[Cursor.inToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _inTokTokenKind = _inTok.tokenKind else {
      fatalError("expected token child, got \(_inTok.kind)")
    }
    precondition([.inKeyword].contains(_inTokTokenKind),
      "expected one of [.inKeyword] for 'inTok' " + 
      "in node of kind closureSignature")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var capture: ClosureCaptureSignatureSyntax? {
    let child = data.cachedChild(at: Cursor.capture)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? ClosureCaptureSignatureSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `capture` replaced.
  /// - param newChild: The new `capture` to replace the node's
  ///                   current `capture`, if present.
  public func withCapture(
    _ newChild: ClosureCaptureSignatureSyntax?) -> ClosureSignatureSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.closureCaptureSignature)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.capture)
    return ClosureSignatureSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var input: Syntax? {
    let child = data.cachedChild(at: Cursor.input)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) 
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `input` replaced.
  /// - param newChild: The new `input` to replace the node's
  ///                   current `input`, if present.
  public func withInput(
    _ newChild: Syntax?) -> ClosureSignatureSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.unknown)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.input)
    return ClosureSignatureSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var throwsTok: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.throwsTok)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `throwsTok` replaced.
  /// - param newChild: The new `throwsTok` to replace the node's
  ///                   current `throwsTok`, if present.
  public func withThrowsTok(
    _ newChild: TokenSyntax?) -> ClosureSignatureSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.throwsKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.throwsTok)
    return ClosureSignatureSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var output: ReturnClauseSyntax? {
    let child = data.cachedChild(at: Cursor.output)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? ReturnClauseSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `output` replaced.
  /// - param newChild: The new `output` to replace the node's
  ///                   current `output`, if present.
  public func withOutput(
    _ newChild: ReturnClauseSyntax?) -> ClosureSignatureSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.returnClause)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.output)
    return ClosureSignatureSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var inTok: TokenSyntax {
    let child = data.cachedChild(at: Cursor.inTok)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `inTok` replaced.
  /// - param newChild: The new `inTok` to replace the node's
  ///                   current `inTok`, if present.
  public func withInTok(
    _ newChild: TokenSyntax?) -> ClosureSignatureSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.inKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.inTok)
    return ClosureSignatureSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `ClosureSignatureSyntax` nodes are equal to each other.
  public static func ==(lhs: ClosureSignatureSyntax, rhs: ClosureSignatureSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct ClosureExprSyntax: ExprSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case leftBrace
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case signature
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case statements
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case rightBrace
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `ClosureExprSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 4)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _leftBrace = raw[Cursor.leftBraceToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _leftBraceTokenKind = _leftBrace.tokenKind else {
      fatalError("expected token child, got \(_leftBrace.kind)")
    }
    precondition([.leftBrace].contains(_leftBraceTokenKind),
      "expected one of [.leftBrace] for 'leftBrace' " + 
      "in node of kind closureExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _signature = raw[Cursor.closureSignature]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_signature.kind == .closureSignature,
                 "expected child of kind .closureSignature, " +
                 "got \(_signature.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _statements = raw[Cursor.codeBlockItemList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_statements.kind == .codeBlockItemList,
                 "expected child of kind .codeBlockItemList, " +
                 "got \(_statements.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _rightBrace = raw[Cursor.rightBraceToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _rightBraceTokenKind = _rightBrace.tokenKind else {
      fatalError("expected token child, got \(_rightBrace.kind)")
    }
    precondition([.rightBrace].contains(_rightBraceTokenKind),
      "expected one of [.rightBrace] for 'rightBrace' " + 
      "in node of kind closureExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var leftBrace: TokenSyntax {
    let child = data.cachedChild(at: Cursor.leftBrace)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `leftBrace` replaced.
  /// - param newChild: The new `leftBrace` to replace the node's
  ///                   current `leftBrace`, if present.
  public func withLeftBrace(
    _ newChild: TokenSyntax?) -> ClosureExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftBrace)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.leftBrace)
    return ClosureExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var signature: ClosureSignatureSyntax? {
    let child = data.cachedChild(at: Cursor.signature)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? ClosureSignatureSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `signature` replaced.
  /// - param newChild: The new `signature` to replace the node's
  ///                   current `signature`, if present.
  public func withSignature(
    _ newChild: ClosureSignatureSyntax?) -> ClosureExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.closureSignature)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.signature)
    return ClosureExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var statements: CodeBlockItemListSyntax {
    let child = data.cachedChild(at: Cursor.statements)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! CodeBlockItemListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `CodeBlockItem` to the node's `statements`
  /// collection.
  /// - param element: The new `CodeBlockItem` to add to the node's
  ///                  `statements` collection.
  /// - returns: A copy of the receiver with the provided `CodeBlockItem`
  ///            appended to its `statements` collection.
  public func addCodeBlockItem(_ element: CodeBlockItemSyntax) -> ClosureExprSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.statements] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.codeBlockItemList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.statements)
    return ClosureExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `statements` replaced.
  /// - param newChild: The new `statements` to replace the node's
  ///                   current `statements`, if present.
  public func withStatements(
    _ newChild: CodeBlockItemListSyntax?) -> ClosureExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.codeBlockItemList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.statements)
    return ClosureExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var rightBrace: TokenSyntax {
    let child = data.cachedChild(at: Cursor.rightBrace)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `rightBrace` replaced.
  /// - param newChild: The new `rightBrace` to replace the node's
  ///                   current `rightBrace`, if present.
  public func withRightBrace(
    _ newChild: TokenSyntax?) -> ClosureExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightBrace)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.rightBrace)
    return ClosureExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `ClosureExprSyntax` nodes are equal to each other.
  public static func ==(lhs: ClosureExprSyntax, rhs: ClosureExprSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct UnresolvedPatternExprSyntax: ExprSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case pattern
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `UnresolvedPatternExprSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 1)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _pattern = raw[Cursor.pattern]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_pattern.kind == .pattern,
                 "expected child of kind .pattern, " +
                 "got \(_pattern.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var pattern: PatternSyntax {
    let child = data.cachedChild(at: Cursor.pattern)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! PatternSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `pattern` replaced.
  /// - param newChild: The new `pattern` to replace the node's
  ///                   current `pattern`, if present.
  public func withPattern(
    _ newChild: PatternSyntax?) -> UnresolvedPatternExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.pattern)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.pattern)
    return UnresolvedPatternExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `UnresolvedPatternExprSyntax` nodes are equal to each other.
  public static func ==(lhs: UnresolvedPatternExprSyntax, rhs: UnresolvedPatternExprSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct FunctionCallExprSyntax: ExprSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case calledExpression
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case leftParen
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case argumentList
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case rightParen
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case trailingClosure
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `FunctionCallExprSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 5)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _calledExpression = raw[Cursor.expr]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_calledExpression.kind == .expr,
                 "expected child of kind .expr, " +
                 "got \(_calledExpression.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _leftParen = raw[Cursor.leftParenToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _leftParenTokenKind = _leftParen.tokenKind else {
      fatalError("expected token child, got \(_leftParen.kind)")
    }
    precondition([.leftParen].contains(_leftParenTokenKind),
      "expected one of [.leftParen] for 'leftParen' " + 
      "in node of kind functionCallExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _argumentList = raw[Cursor.functionCallArgumentList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_argumentList.kind == .functionCallArgumentList,
                 "expected child of kind .functionCallArgumentList, " +
                 "got \(_argumentList.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _rightParen = raw[Cursor.rightParenToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _rightParenTokenKind = _rightParen.tokenKind else {
      fatalError("expected token child, got \(_rightParen.kind)")
    }
    precondition([.rightParen].contains(_rightParenTokenKind),
      "expected one of [.rightParen] for 'rightParen' " + 
      "in node of kind functionCallExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _trailingClosure = raw[Cursor.closureExpr]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_trailingClosure.kind == .closureExpr,
                 "expected child of kind .closureExpr, " +
                 "got \(_trailingClosure.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var calledExpression: ExprSyntax {
    let child = data.cachedChild(at: Cursor.calledExpression)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! ExprSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `calledExpression` replaced.
  /// - param newChild: The new `calledExpression` to replace the node's
  ///                   current `calledExpression`, if present.
  public func withCalledExpression(
    _ newChild: ExprSyntax?) -> FunctionCallExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.calledExpression)
    return FunctionCallExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var leftParen: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.leftParen)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `leftParen` replaced.
  /// - param newChild: The new `leftParen` to replace the node's
  ///                   current `leftParen`, if present.
  public func withLeftParen(
    _ newChild: TokenSyntax?) -> FunctionCallExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftParen)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.leftParen)
    return FunctionCallExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var argumentList: FunctionCallArgumentListSyntax {
    let child = data.cachedChild(at: Cursor.argumentList)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! FunctionCallArgumentListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `FunctionCallArgument` to the node's `argumentList`
  /// collection.
  /// - param element: The new `FunctionCallArgument` to add to the node's
  ///                  `argumentList` collection.
  /// - returns: A copy of the receiver with the provided `FunctionCallArgument`
  ///            appended to its `argumentList` collection.
  public func addFunctionCallArgument(_ element: FunctionCallArgumentSyntax) -> FunctionCallExprSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.argumentList] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.functionCallArgumentList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.argumentList)
    return FunctionCallExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `argumentList` replaced.
  /// - param newChild: The new `argumentList` to replace the node's
  ///                   current `argumentList`, if present.
  public func withArgumentList(
    _ newChild: FunctionCallArgumentListSyntax?) -> FunctionCallExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.functionCallArgumentList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.argumentList)
    return FunctionCallExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var rightParen: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.rightParen)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `rightParen` replaced.
  /// - param newChild: The new `rightParen` to replace the node's
  ///                   current `rightParen`, if present.
  public func withRightParen(
    _ newChild: TokenSyntax?) -> FunctionCallExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightParen)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.rightParen)
    return FunctionCallExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var trailingClosure: ClosureExprSyntax? {
    let child = data.cachedChild(at: Cursor.trailingClosure)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? ClosureExprSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `trailingClosure` replaced.
  /// - param newChild: The new `trailingClosure` to replace the node's
  ///                   current `trailingClosure`, if present.
  public func withTrailingClosure(
    _ newChild: ClosureExprSyntax?) -> FunctionCallExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.closureExpr)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.trailingClosure)
    return FunctionCallExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `FunctionCallExprSyntax` nodes are equal to each other.
  public static func ==(lhs: FunctionCallExprSyntax, rhs: FunctionCallExprSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct SubscriptExprSyntax: ExprSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case calledExpression
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case leftBracket
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case argumentList
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case rightBracket
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case trailingClosure
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `SubscriptExprSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 5)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _calledExpression = raw[Cursor.expr]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_calledExpression.kind == .expr,
                 "expected child of kind .expr, " +
                 "got \(_calledExpression.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _leftBracket = raw[Cursor.leftSquareBracketToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _leftBracketTokenKind = _leftBracket.tokenKind else {
      fatalError("expected token child, got \(_leftBracket.kind)")
    }
    precondition([.leftSquareBracket].contains(_leftBracketTokenKind),
      "expected one of [.leftSquareBracket] for 'leftBracket' " + 
      "in node of kind subscriptExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _argumentList = raw[Cursor.functionCallArgumentList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_argumentList.kind == .functionCallArgumentList,
                 "expected child of kind .functionCallArgumentList, " +
                 "got \(_argumentList.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _rightBracket = raw[Cursor.rightSquareBracketToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _rightBracketTokenKind = _rightBracket.tokenKind else {
      fatalError("expected token child, got \(_rightBracket.kind)")
    }
    precondition([.rightSquareBracket].contains(_rightBracketTokenKind),
      "expected one of [.rightSquareBracket] for 'rightBracket' " + 
      "in node of kind subscriptExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _trailingClosure = raw[Cursor.closureExpr]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_trailingClosure.kind == .closureExpr,
                 "expected child of kind .closureExpr, " +
                 "got \(_trailingClosure.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var calledExpression: ExprSyntax {
    let child = data.cachedChild(at: Cursor.calledExpression)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! ExprSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `calledExpression` replaced.
  /// - param newChild: The new `calledExpression` to replace the node's
  ///                   current `calledExpression`, if present.
  public func withCalledExpression(
    _ newChild: ExprSyntax?) -> SubscriptExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.calledExpression)
    return SubscriptExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var leftBracket: TokenSyntax {
    let child = data.cachedChild(at: Cursor.leftBracket)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `leftBracket` replaced.
  /// - param newChild: The new `leftBracket` to replace the node's
  ///                   current `leftBracket`, if present.
  public func withLeftBracket(
    _ newChild: TokenSyntax?) -> SubscriptExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftSquareBracket)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.leftBracket)
    return SubscriptExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var argumentList: FunctionCallArgumentListSyntax {
    let child = data.cachedChild(at: Cursor.argumentList)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! FunctionCallArgumentListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `FunctionCallArgument` to the node's `argumentList`
  /// collection.
  /// - param element: The new `FunctionCallArgument` to add to the node's
  ///                  `argumentList` collection.
  /// - returns: A copy of the receiver with the provided `FunctionCallArgument`
  ///            appended to its `argumentList` collection.
  public func addFunctionCallArgument(_ element: FunctionCallArgumentSyntax) -> SubscriptExprSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.argumentList] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.functionCallArgumentList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.argumentList)
    return SubscriptExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `argumentList` replaced.
  /// - param newChild: The new `argumentList` to replace the node's
  ///                   current `argumentList`, if present.
  public func withArgumentList(
    _ newChild: FunctionCallArgumentListSyntax?) -> SubscriptExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.functionCallArgumentList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.argumentList)
    return SubscriptExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var rightBracket: TokenSyntax {
    let child = data.cachedChild(at: Cursor.rightBracket)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `rightBracket` replaced.
  /// - param newChild: The new `rightBracket` to replace the node's
  ///                   current `rightBracket`, if present.
  public func withRightBracket(
    _ newChild: TokenSyntax?) -> SubscriptExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightSquareBracket)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.rightBracket)
    return SubscriptExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var trailingClosure: ClosureExprSyntax? {
    let child = data.cachedChild(at: Cursor.trailingClosure)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? ClosureExprSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `trailingClosure` replaced.
  /// - param newChild: The new `trailingClosure` to replace the node's
  ///                   current `trailingClosure`, if present.
  public func withTrailingClosure(
    _ newChild: ClosureExprSyntax?) -> SubscriptExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.closureExpr)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.trailingClosure)
    return SubscriptExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `SubscriptExprSyntax` nodes are equal to each other.
  public static func ==(lhs: SubscriptExprSyntax, rhs: SubscriptExprSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct OptionalChainingExprSyntax: ExprSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case expression
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case questionMark
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `OptionalChainingExprSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 2)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _expression = raw[Cursor.expr]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_expression.kind == .expr,
                 "expected child of kind .expr, " +
                 "got \(_expression.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _questionMark = raw[Cursor.postfixQuestionMarkToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _questionMarkTokenKind = _questionMark.tokenKind else {
      fatalError("expected token child, got \(_questionMark.kind)")
    }
    precondition([.postfixQuestionMark].contains(_questionMarkTokenKind),
      "expected one of [.postfixQuestionMark] for 'questionMark' " + 
      "in node of kind optionalChainingExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var expression: ExprSyntax {
    let child = data.cachedChild(at: Cursor.expression)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! ExprSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `expression` replaced.
  /// - param newChild: The new `expression` to replace the node's
  ///                   current `expression`, if present.
  public func withExpression(
    _ newChild: ExprSyntax?) -> OptionalChainingExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.expression)
    return OptionalChainingExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var questionMark: TokenSyntax {
    let child = data.cachedChild(at: Cursor.questionMark)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `questionMark` replaced.
  /// - param newChild: The new `questionMark` to replace the node's
  ///                   current `questionMark`, if present.
  public func withQuestionMark(
    _ newChild: TokenSyntax?) -> OptionalChainingExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.postfixQuestionMark)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.questionMark)
    return OptionalChainingExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `OptionalChainingExprSyntax` nodes are equal to each other.
  public static func ==(lhs: OptionalChainingExprSyntax, rhs: OptionalChainingExprSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct ForcedValueExprSyntax: ExprSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case expression
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case exclamationMark
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `ForcedValueExprSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 2)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _expression = raw[Cursor.expr]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_expression.kind == .expr,
                 "expected child of kind .expr, " +
                 "got \(_expression.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _exclamationMark = raw[Cursor.exclamationMarkToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _exclamationMarkTokenKind = _exclamationMark.tokenKind else {
      fatalError("expected token child, got \(_exclamationMark.kind)")
    }
    precondition([.exclamationMark].contains(_exclamationMarkTokenKind),
      "expected one of [.exclamationMark] for 'exclamationMark' " + 
      "in node of kind forcedValueExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var expression: ExprSyntax {
    let child = data.cachedChild(at: Cursor.expression)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! ExprSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `expression` replaced.
  /// - param newChild: The new `expression` to replace the node's
  ///                   current `expression`, if present.
  public func withExpression(
    _ newChild: ExprSyntax?) -> ForcedValueExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.expression)
    return ForcedValueExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var exclamationMark: TokenSyntax {
    let child = data.cachedChild(at: Cursor.exclamationMark)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `exclamationMark` replaced.
  /// - param newChild: The new `exclamationMark` to replace the node's
  ///                   current `exclamationMark`, if present.
  public func withExclamationMark(
    _ newChild: TokenSyntax?) -> ForcedValueExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.exclamationMark)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.exclamationMark)
    return ForcedValueExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `ForcedValueExprSyntax` nodes are equal to each other.
  public static func ==(lhs: ForcedValueExprSyntax, rhs: ForcedValueExprSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct PostfixUnaryExprSyntax: ExprSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case expression
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case operatorToken
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `PostfixUnaryExprSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 2)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _expression = raw[Cursor.expr]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_expression.kind == .expr,
                 "expected child of kind .expr, " +
                 "got \(_expression.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _operatorToken = raw[Cursor.postfixOperatorToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _operatorTokenTokenKind = _operatorToken.tokenKind else {
      fatalError("expected token child, got \(_operatorToken.kind)")
    }
    precondition([.postfixOperator].contains(_operatorTokenTokenKind),
      "expected one of [.postfixOperator] for 'operatorToken' " + 
      "in node of kind postfixUnaryExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var expression: ExprSyntax {
    let child = data.cachedChild(at: Cursor.expression)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! ExprSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `expression` replaced.
  /// - param newChild: The new `expression` to replace the node's
  ///                   current `expression`, if present.
  public func withExpression(
    _ newChild: ExprSyntax?) -> PostfixUnaryExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.expression)
    return PostfixUnaryExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var operatorToken: TokenSyntax {
    let child = data.cachedChild(at: Cursor.operatorToken)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `operatorToken` replaced.
  /// - param newChild: The new `operatorToken` to replace the node's
  ///                   current `operatorToken`, if present.
  public func withOperatorToken(
    _ newChild: TokenSyntax?) -> PostfixUnaryExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.postfixOperator(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.operatorToken)
    return PostfixUnaryExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `PostfixUnaryExprSyntax` nodes are equal to each other.
  public static func ==(lhs: PostfixUnaryExprSyntax, rhs: PostfixUnaryExprSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct SpecializeExprSyntax: ExprSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case expression
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case genericArgumentClause
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `SpecializeExprSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 2)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _expression = raw[Cursor.expr]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_expression.kind == .expr,
                 "expected child of kind .expr, " +
                 "got \(_expression.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _genericArgumentClause = raw[Cursor.genericArgumentClause]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_genericArgumentClause.kind == .genericArgumentClause,
                 "expected child of kind .genericArgumentClause, " +
                 "got \(_genericArgumentClause.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var expression: ExprSyntax {
    let child = data.cachedChild(at: Cursor.expression)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! ExprSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `expression` replaced.
  /// - param newChild: The new `expression` to replace the node's
  ///                   current `expression`, if present.
  public func withExpression(
    _ newChild: ExprSyntax?) -> SpecializeExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.expression)
    return SpecializeExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var genericArgumentClause: GenericArgumentClauseSyntax {
    let child = data.cachedChild(at: Cursor.genericArgumentClause)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! GenericArgumentClauseSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `genericArgumentClause` replaced.
  /// - param newChild: The new `genericArgumentClause` to replace the node's
  ///                   current `genericArgumentClause`, if present.
  public func withGenericArgumentClause(
    _ newChild: GenericArgumentClauseSyntax?) -> SpecializeExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.genericArgumentClause)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.genericArgumentClause)
    return SpecializeExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `SpecializeExprSyntax` nodes are equal to each other.
  public static func ==(lhs: SpecializeExprSyntax, rhs: SpecializeExprSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct StringSegmentSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case content
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `StringSegmentSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 1)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _content = raw[Cursor.stringSegmentToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _contentTokenKind = _content.tokenKind else {
      fatalError("expected token child, got \(_content.kind)")
    }
    precondition([.stringSegment].contains(_contentTokenKind),
      "expected one of [.stringSegment] for 'content' " + 
      "in node of kind stringSegment")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var content: TokenSyntax {
    let child = data.cachedChild(at: Cursor.content)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `content` replaced.
  /// - param newChild: The new `content` to replace the node's
  ///                   current `content`, if present.
  public func withContent(
    _ newChild: TokenSyntax?) -> StringSegmentSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.stringSegment(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.content)
    return StringSegmentSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `StringSegmentSyntax` nodes are equal to each other.
  public static func ==(lhs: StringSegmentSyntax, rhs: StringSegmentSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct ExpressionSegmentSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case backslash
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case leftParen
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case expression
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case rightParen
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `ExpressionSegmentSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 4)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _backslash = raw[Cursor.backslashToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _backslashTokenKind = _backslash.tokenKind else {
      fatalError("expected token child, got \(_backslash.kind)")
    }
    precondition([.backslash].contains(_backslashTokenKind),
      "expected one of [.backslash] for 'backslash' " + 
      "in node of kind expressionSegment")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _leftParen = raw[Cursor.leftParenToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _leftParenTokenKind = _leftParen.tokenKind else {
      fatalError("expected token child, got \(_leftParen.kind)")
    }
    precondition([.leftParen].contains(_leftParenTokenKind),
      "expected one of [.leftParen] for 'leftParen' " + 
      "in node of kind expressionSegment")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _expression = raw[Cursor.expr]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_expression.kind == .expr,
                 "expected child of kind .expr, " +
                 "got \(_expression.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _rightParen = raw[Cursor.stringInterpolationAnchorToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _rightParenTokenKind = _rightParen.tokenKind else {
      fatalError("expected token child, got \(_rightParen.kind)")
    }
    precondition([.stringInterpolationAnchor].contains(_rightParenTokenKind),
      "expected one of [.stringInterpolationAnchor] for 'rightParen' " + 
      "in node of kind expressionSegment")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var backslash: TokenSyntax {
    let child = data.cachedChild(at: Cursor.backslash)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `backslash` replaced.
  /// - param newChild: The new `backslash` to replace the node's
  ///                   current `backslash`, if present.
  public func withBackslash(
    _ newChild: TokenSyntax?) -> ExpressionSegmentSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.backslash)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.backslash)
    return ExpressionSegmentSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var leftParen: TokenSyntax {
    let child = data.cachedChild(at: Cursor.leftParen)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `leftParen` replaced.
  /// - param newChild: The new `leftParen` to replace the node's
  ///                   current `leftParen`, if present.
  public func withLeftParen(
    _ newChild: TokenSyntax?) -> ExpressionSegmentSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftParen)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.leftParen)
    return ExpressionSegmentSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var expression: ExprSyntax {
    let child = data.cachedChild(at: Cursor.expression)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! ExprSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `expression` replaced.
  /// - param newChild: The new `expression` to replace the node's
  ///                   current `expression`, if present.
  public func withExpression(
    _ newChild: ExprSyntax?) -> ExpressionSegmentSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.expression)
    return ExpressionSegmentSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var rightParen: TokenSyntax {
    let child = data.cachedChild(at: Cursor.rightParen)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `rightParen` replaced.
  /// - param newChild: The new `rightParen` to replace the node's
  ///                   current `rightParen`, if present.
  public func withRightParen(
    _ newChild: TokenSyntax?) -> ExpressionSegmentSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.stringInterpolationAnchor)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.rightParen)
    return ExpressionSegmentSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `ExpressionSegmentSyntax` nodes are equal to each other.
  public static func ==(lhs: ExpressionSegmentSyntax, rhs: ExpressionSegmentSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct StringInterpolationExprSyntax: ExprSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case openQuote
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case segments
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case closeQuote
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `StringInterpolationExprSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 3)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _openQuote = raw[Cursor.token]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _openQuoteTokenKind = _openQuote.tokenKind else {
      fatalError("expected token child, got \(_openQuote.kind)")
    }
    precondition([.stringQuote, .multilineStringQuote].contains(_openQuoteTokenKind),
      "expected one of [.stringQuote, .multilineStringQuote] for 'openQuote' " + 
      "in node of kind stringInterpolationExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _segments = raw[Cursor.stringInterpolationSegments]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_segments.kind == .stringInterpolationSegments,
                 "expected child of kind .stringInterpolationSegments, " +
                 "got \(_segments.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _closeQuote = raw[Cursor.token]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _closeQuoteTokenKind = _closeQuote.tokenKind else {
      fatalError("expected token child, got \(_closeQuote.kind)")
    }
    precondition([.stringQuote, .multilineStringQuote].contains(_closeQuoteTokenKind),
      "expected one of [.stringQuote, .multilineStringQuote] for 'closeQuote' " + 
      "in node of kind stringInterpolationExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var openQuote: TokenSyntax {
    let child = data.cachedChild(at: Cursor.openQuote)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `openQuote` replaced.
  /// - param newChild: The new `openQuote` to replace the node's
  ///                   current `openQuote`, if present.
  public func withOpenQuote(
    _ newChild: TokenSyntax?) -> StringInterpolationExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.stringQuote)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.openQuote)
    return StringInterpolationExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var segments: StringInterpolationSegmentsSyntax {
    let child = data.cachedChild(at: Cursor.segments)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! StringInterpolationSegmentsSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `Segment` to the node's `segments`
  /// collection.
  /// - param element: The new `Segment` to add to the node's
  ///                  `segments` collection.
  /// - returns: A copy of the receiver with the provided `Segment`
  ///            appended to its `segments` collection.
  public func addSegment(_ element: Syntax) -> StringInterpolationExprSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.segments] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.stringInterpolationSegments,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.segments)
    return StringInterpolationExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `segments` replaced.
  /// - param newChild: The new `segments` to replace the node's
  ///                   current `segments`, if present.
  public func withSegments(
    _ newChild: StringInterpolationSegmentsSyntax?) -> StringInterpolationExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.stringInterpolationSegments)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.segments)
    return StringInterpolationExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var closeQuote: TokenSyntax {
    let child = data.cachedChild(at: Cursor.closeQuote)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `closeQuote` replaced.
  /// - param newChild: The new `closeQuote` to replace the node's
  ///                   current `closeQuote`, if present.
  public func withCloseQuote(
    _ newChild: TokenSyntax?) -> StringInterpolationExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.stringQuote)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.closeQuote)
    return StringInterpolationExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `StringInterpolationExprSyntax` nodes are equal to each other.
  public static func ==(lhs: StringInterpolationExprSyntax, rhs: StringInterpolationExprSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct KeyPathExprSyntax: ExprSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case backslash
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case rootExpr
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case expression
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `KeyPathExprSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 3)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _backslash = raw[Cursor.backslashToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _backslashTokenKind = _backslash.tokenKind else {
      fatalError("expected token child, got \(_backslash.kind)")
    }
    precondition([.backslash].contains(_backslashTokenKind),
      "expected one of [.backslash] for 'backslash' " + 
      "in node of kind keyPathExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _rootExpr = raw[Cursor.expr]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_rootExpr.kind == .expr,
                 "expected child of kind .expr, " +
                 "got \(_rootExpr.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _expression = raw[Cursor.expr]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_expression.kind == .expr,
                 "expected child of kind .expr, " +
                 "got \(_expression.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var backslash: TokenSyntax {
    let child = data.cachedChild(at: Cursor.backslash)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `backslash` replaced.
  /// - param newChild: The new `backslash` to replace the node's
  ///                   current `backslash`, if present.
  public func withBackslash(
    _ newChild: TokenSyntax?) -> KeyPathExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.backslash)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.backslash)
    return KeyPathExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var rootExpr: ExprSyntax? {
    let child = data.cachedChild(at: Cursor.rootExpr)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? ExprSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `rootExpr` replaced.
  /// - param newChild: The new `rootExpr` to replace the node's
  ///                   current `rootExpr`, if present.
  public func withRootExpr(
    _ newChild: ExprSyntax?) -> KeyPathExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.rootExpr)
    return KeyPathExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var expression: ExprSyntax {
    let child = data.cachedChild(at: Cursor.expression)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! ExprSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `expression` replaced.
  /// - param newChild: The new `expression` to replace the node's
  ///                   current `expression`, if present.
  public func withExpression(
    _ newChild: ExprSyntax?) -> KeyPathExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.expression)
    return KeyPathExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `KeyPathExprSyntax` nodes are equal to each other.
  public static func ==(lhs: KeyPathExprSyntax, rhs: KeyPathExprSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct KeyPathBaseExprSyntax: ExprSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case period
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `KeyPathBaseExprSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 1)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _period = raw[Cursor.periodToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _periodTokenKind = _period.tokenKind else {
      fatalError("expected token child, got \(_period.kind)")
    }
    precondition([.period].contains(_periodTokenKind),
      "expected one of [.period] for 'period' " + 
      "in node of kind keyPathBaseExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var period: TokenSyntax {
    let child = data.cachedChild(at: Cursor.period)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `period` replaced.
  /// - param newChild: The new `period` to replace the node's
  ///                   current `period`, if present.
  public func withPeriod(
    _ newChild: TokenSyntax?) -> KeyPathBaseExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.period)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.period)
    return KeyPathBaseExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `KeyPathBaseExprSyntax` nodes are equal to each other.
  public static func ==(lhs: KeyPathBaseExprSyntax, rhs: KeyPathBaseExprSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct ObjcNamePieceSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case name
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case dot
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `ObjcNamePieceSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 2)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _name = raw[Cursor.identifierToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _nameTokenKind = _name.tokenKind else {
      fatalError("expected token child, got \(_name.kind)")
    }
    precondition([.identifier].contains(_nameTokenKind),
      "expected one of [.identifier] for 'name' " + 
      "in node of kind objcNamePiece")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _dot = raw[Cursor.periodToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _dotTokenKind = _dot.tokenKind else {
      fatalError("expected token child, got \(_dot.kind)")
    }
    precondition([.period].contains(_dotTokenKind),
      "expected one of [.period] for 'dot' " + 
      "in node of kind objcNamePiece")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var name: TokenSyntax {
    let child = data.cachedChild(at: Cursor.name)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `name` replaced.
  /// - param newChild: The new `name` to replace the node's
  ///                   current `name`, if present.
  public func withName(
    _ newChild: TokenSyntax?) -> ObjcNamePieceSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.name)
    return ObjcNamePieceSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var dot: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.dot)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `dot` replaced.
  /// - param newChild: The new `dot` to replace the node's
  ///                   current `dot`, if present.
  public func withDot(
    _ newChild: TokenSyntax?) -> ObjcNamePieceSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.period)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.dot)
    return ObjcNamePieceSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `ObjcNamePieceSyntax` nodes are equal to each other.
  public static func ==(lhs: ObjcNamePieceSyntax, rhs: ObjcNamePieceSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct ObjcKeyPathExprSyntax: ExprSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case keyPath
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case leftParen
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case name
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case rightParen
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `ObjcKeyPathExprSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 4)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _keyPath = raw[Cursor.poundKeyPathToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _keyPathTokenKind = _keyPath.tokenKind else {
      fatalError("expected token child, got \(_keyPath.kind)")
    }
    precondition([.poundKeyPathKeyword].contains(_keyPathTokenKind),
      "expected one of [.poundKeyPathKeyword] for 'keyPath' " + 
      "in node of kind objcKeyPathExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _leftParen = raw[Cursor.leftParenToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _leftParenTokenKind = _leftParen.tokenKind else {
      fatalError("expected token child, got \(_leftParen.kind)")
    }
    precondition([.leftParen].contains(_leftParenTokenKind),
      "expected one of [.leftParen] for 'leftParen' " + 
      "in node of kind objcKeyPathExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _name = raw[Cursor.objcName]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_name.kind == .objcName,
                 "expected child of kind .objcName, " +
                 "got \(_name.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _rightParen = raw[Cursor.rightParenToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _rightParenTokenKind = _rightParen.tokenKind else {
      fatalError("expected token child, got \(_rightParen.kind)")
    }
    precondition([.rightParen].contains(_rightParenTokenKind),
      "expected one of [.rightParen] for 'rightParen' " + 
      "in node of kind objcKeyPathExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var keyPath: TokenSyntax {
    let child = data.cachedChild(at: Cursor.keyPath)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `keyPath` replaced.
  /// - param newChild: The new `keyPath` to replace the node's
  ///                   current `keyPath`, if present.
  public func withKeyPath(
    _ newChild: TokenSyntax?) -> ObjcKeyPathExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.poundKeyPathKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.keyPath)
    return ObjcKeyPathExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var leftParen: TokenSyntax {
    let child = data.cachedChild(at: Cursor.leftParen)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `leftParen` replaced.
  /// - param newChild: The new `leftParen` to replace the node's
  ///                   current `leftParen`, if present.
  public func withLeftParen(
    _ newChild: TokenSyntax?) -> ObjcKeyPathExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftParen)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.leftParen)
    return ObjcKeyPathExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var name: ObjcNameSyntax {
    let child = data.cachedChild(at: Cursor.name)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! ObjcNameSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `ObjcNamePiece` to the node's `name`
  /// collection.
  /// - param element: The new `ObjcNamePiece` to add to the node's
  ///                  `name` collection.
  /// - returns: A copy of the receiver with the provided `ObjcNamePiece`
  ///            appended to its `name` collection.
  public func addObjcNamePiece(_ element: ObjcNamePieceSyntax) -> ObjcKeyPathExprSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.name] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.objcName,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.name)
    return ObjcKeyPathExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `name` replaced.
  /// - param newChild: The new `name` to replace the node's
  ///                   current `name`, if present.
  public func withName(
    _ newChild: ObjcNameSyntax?) -> ObjcKeyPathExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.objcName)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.name)
    return ObjcKeyPathExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var rightParen: TokenSyntax {
    let child = data.cachedChild(at: Cursor.rightParen)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `rightParen` replaced.
  /// - param newChild: The new `rightParen` to replace the node's
  ///                   current `rightParen`, if present.
  public func withRightParen(
    _ newChild: TokenSyntax?) -> ObjcKeyPathExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightParen)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.rightParen)
    return ObjcKeyPathExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `ObjcKeyPathExprSyntax` nodes are equal to each other.
  public static func ==(lhs: ObjcKeyPathExprSyntax, rhs: ObjcKeyPathExprSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct ObjcSelectorExprSyntax: ExprSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case poundSelector
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case leftParen
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case kind
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case colon
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case name
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case rightParen
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `ObjcSelectorExprSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 6)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _poundSelector = raw[Cursor.poundSelectorToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _poundSelectorTokenKind = _poundSelector.tokenKind else {
      fatalError("expected token child, got \(_poundSelector.kind)")
    }
    precondition([.poundSelectorKeyword].contains(_poundSelectorTokenKind),
      "expected one of [.poundSelectorKeyword] for 'poundSelector' " + 
      "in node of kind objcSelectorExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _leftParen = raw[Cursor.leftParenToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _leftParenTokenKind = _leftParen.tokenKind else {
      fatalError("expected token child, got \(_leftParen.kind)")
    }
    precondition([.leftParen].contains(_leftParenTokenKind),
      "expected one of [.leftParen] for 'leftParen' " + 
      "in node of kind objcSelectorExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _kind = raw[Cursor.contextualKeywordToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _kindTokenKind = _kind.tokenKind else {
      fatalError("expected token child, got \(_kind.kind)")
    }
    precondition([.contextualKeyword].contains(_kindTokenKind),
      "expected one of [.contextualKeyword] for 'kind' " + 
      "in node of kind objcSelectorExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _colon = raw[Cursor.colonToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _colonTokenKind = _colon.tokenKind else {
      fatalError("expected token child, got \(_colon.kind)")
    }
    precondition([.colon].contains(_colonTokenKind),
      "expected one of [.colon] for 'colon' " + 
      "in node of kind objcSelectorExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _name = raw[Cursor.expr]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_name.kind == .expr,
                 "expected child of kind .expr, " +
                 "got \(_name.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _rightParen = raw[Cursor.rightParenToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _rightParenTokenKind = _rightParen.tokenKind else {
      fatalError("expected token child, got \(_rightParen.kind)")
    }
    precondition([.rightParen].contains(_rightParenTokenKind),
      "expected one of [.rightParen] for 'rightParen' " + 
      "in node of kind objcSelectorExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var poundSelector: TokenSyntax {
    let child = data.cachedChild(at: Cursor.poundSelector)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `poundSelector` replaced.
  /// - param newChild: The new `poundSelector` to replace the node's
  ///                   current `poundSelector`, if present.
  public func withPoundSelector(
    _ newChild: TokenSyntax?) -> ObjcSelectorExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.poundSelectorKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.poundSelector)
    return ObjcSelectorExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var leftParen: TokenSyntax {
    let child = data.cachedChild(at: Cursor.leftParen)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `leftParen` replaced.
  /// - param newChild: The new `leftParen` to replace the node's
  ///                   current `leftParen`, if present.
  public func withLeftParen(
    _ newChild: TokenSyntax?) -> ObjcSelectorExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftParen)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.leftParen)
    return ObjcSelectorExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var kind: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.kind)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `kind` replaced.
  /// - param newChild: The new `kind` to replace the node's
  ///                   current `kind`, if present.
  public func withKind(
    _ newChild: TokenSyntax?) -> ObjcSelectorExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.contextualKeyword(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.kind)
    return ObjcSelectorExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var colon: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.colon)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `colon` replaced.
  /// - param newChild: The new `colon` to replace the node's
  ///                   current `colon`, if present.
  public func withColon(
    _ newChild: TokenSyntax?) -> ObjcSelectorExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.colon)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.colon)
    return ObjcSelectorExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var name: ExprSyntax {
    let child = data.cachedChild(at: Cursor.name)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! ExprSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `name` replaced.
  /// - param newChild: The new `name` to replace the node's
  ///                   current `name`, if present.
  public func withName(
    _ newChild: ExprSyntax?) -> ObjcSelectorExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.name)
    return ObjcSelectorExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var rightParen: TokenSyntax {
    let child = data.cachedChild(at: Cursor.rightParen)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `rightParen` replaced.
  /// - param newChild: The new `rightParen` to replace the node's
  ///                   current `rightParen`, if present.
  public func withRightParen(
    _ newChild: TokenSyntax?) -> ObjcSelectorExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightParen)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.rightParen)
    return ObjcSelectorExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `ObjcSelectorExprSyntax` nodes are equal to each other.
  public static func ==(lhs: ObjcSelectorExprSyntax, rhs: ObjcSelectorExprSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct EditorPlaceholderExprSyntax: ExprSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case identifier
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `EditorPlaceholderExprSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 1)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _identifier = raw[Cursor.identifierToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _identifierTokenKind = _identifier.tokenKind else {
      fatalError("expected token child, got \(_identifier.kind)")
    }
    precondition([.identifier].contains(_identifierTokenKind),
      "expected one of [.identifier] for 'identifier' " + 
      "in node of kind editorPlaceholderExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var identifier: TokenSyntax {
    let child = data.cachedChild(at: Cursor.identifier)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `identifier` replaced.
  /// - param newChild: The new `identifier` to replace the node's
  ///                   current `identifier`, if present.
  public func withIdentifier(
    _ newChild: TokenSyntax?) -> EditorPlaceholderExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.identifier)
    return EditorPlaceholderExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `EditorPlaceholderExprSyntax` nodes are equal to each other.
  public static func ==(lhs: EditorPlaceholderExprSyntax, rhs: EditorPlaceholderExprSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct ObjectLiteralExprSyntax: ExprSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case identifier
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case leftParen
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case arguments
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case rightParen
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `ObjectLiteralExprSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 4)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _identifier = raw[Cursor.token]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _identifierTokenKind = _identifier.tokenKind else {
      fatalError("expected token child, got \(_identifier.kind)")
    }
    precondition([.poundColorLiteralKeyword, .poundFileLiteralKeyword, .poundImageLiteralKeyword].contains(_identifierTokenKind),
      "expected one of [.poundColorLiteralKeyword, .poundFileLiteralKeyword, .poundImageLiteralKeyword] for 'identifier' " + 
      "in node of kind objectLiteralExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _leftParen = raw[Cursor.leftParenToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _leftParenTokenKind = _leftParen.tokenKind else {
      fatalError("expected token child, got \(_leftParen.kind)")
    }
    precondition([.leftParen].contains(_leftParenTokenKind),
      "expected one of [.leftParen] for 'leftParen' " + 
      "in node of kind objectLiteralExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _arguments = raw[Cursor.functionCallArgumentList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_arguments.kind == .functionCallArgumentList,
                 "expected child of kind .functionCallArgumentList, " +
                 "got \(_arguments.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _rightParen = raw[Cursor.rightParenToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _rightParenTokenKind = _rightParen.tokenKind else {
      fatalError("expected token child, got \(_rightParen.kind)")
    }
    precondition([.rightParen].contains(_rightParenTokenKind),
      "expected one of [.rightParen] for 'rightParen' " + 
      "in node of kind objectLiteralExpr")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var identifier: TokenSyntax {
    let child = data.cachedChild(at: Cursor.identifier)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `identifier` replaced.
  /// - param newChild: The new `identifier` to replace the node's
  ///                   current `identifier`, if present.
  public func withIdentifier(
    _ newChild: TokenSyntax?) -> ObjectLiteralExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.poundColorLiteralKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.identifier)
    return ObjectLiteralExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var leftParen: TokenSyntax {
    let child = data.cachedChild(at: Cursor.leftParen)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `leftParen` replaced.
  /// - param newChild: The new `leftParen` to replace the node's
  ///                   current `leftParen`, if present.
  public func withLeftParen(
    _ newChild: TokenSyntax?) -> ObjectLiteralExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftParen)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.leftParen)
    return ObjectLiteralExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var arguments: FunctionCallArgumentListSyntax {
    let child = data.cachedChild(at: Cursor.arguments)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! FunctionCallArgumentListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `FunctionCallArgument` to the node's `arguments`
  /// collection.
  /// - param element: The new `FunctionCallArgument` to add to the node's
  ///                  `arguments` collection.
  /// - returns: A copy of the receiver with the provided `FunctionCallArgument`
  ///            appended to its `arguments` collection.
  public func addFunctionCallArgument(_ element: FunctionCallArgumentSyntax) -> ObjectLiteralExprSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.arguments] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.functionCallArgumentList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.arguments)
    return ObjectLiteralExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `arguments` replaced.
  /// - param newChild: The new `arguments` to replace the node's
  ///                   current `arguments`, if present.
  public func withArguments(
    _ newChild: FunctionCallArgumentListSyntax?) -> ObjectLiteralExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.functionCallArgumentList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.arguments)
    return ObjectLiteralExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var rightParen: TokenSyntax {
    let child = data.cachedChild(at: Cursor.rightParen)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `rightParen` replaced.
  /// - param newChild: The new `rightParen` to replace the node's
  ///                   current `rightParen`, if present.
  public func withRightParen(
    _ newChild: TokenSyntax?) -> ObjectLiteralExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightParen)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.rightParen)
    return ObjectLiteralExprSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `ObjectLiteralExprSyntax` nodes are equal to each other.
  public static func ==(lhs: ObjectLiteralExprSyntax, rhs: ObjectLiteralExprSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct TypeInitializerClauseSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case equal
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case value
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `TypeInitializerClauseSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 2)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _equal = raw[Cursor.equalToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _equalTokenKind = _equal.tokenKind else {
      fatalError("expected token child, got \(_equal.kind)")
    }
    precondition([.equal].contains(_equalTokenKind),
      "expected one of [.equal] for 'equal' " + 
      "in node of kind typeInitializerClause")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _value = raw[Cursor.type]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_value.kind == .type,
                 "expected child of kind .type, " +
                 "got \(_value.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var equal: TokenSyntax {
    let child = data.cachedChild(at: Cursor.equal)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `equal` replaced.
  /// - param newChild: The new `equal` to replace the node's
  ///                   current `equal`, if present.
  public func withEqual(
    _ newChild: TokenSyntax?) -> TypeInitializerClauseSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.equal)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.equal)
    return TypeInitializerClauseSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var value: TypeSyntax {
    let child = data.cachedChild(at: Cursor.value)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TypeSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `value` replaced.
  /// - param newChild: The new `value` to replace the node's
  ///                   current `value`, if present.
  public func withValue(
    _ newChild: TypeSyntax?) -> TypeInitializerClauseSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.type)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.value)
    return TypeInitializerClauseSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `TypeInitializerClauseSyntax` nodes are equal to each other.
  public static func ==(lhs: TypeInitializerClauseSyntax, rhs: TypeInitializerClauseSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct TypealiasDeclSyntax: DeclSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case attributes
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case modifiers
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case typealiasKeyword
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case identifier
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case genericParameterClause
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case initializer
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case genericWhereClause
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `TypealiasDeclSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 7)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _attributes = raw[Cursor.attributeList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_attributes.kind == .attributeList,
                 "expected child of kind .attributeList, " +
                 "got \(_attributes.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _modifiers = raw[Cursor.modifierList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_modifiers.kind == .modifierList,
                 "expected child of kind .modifierList, " +
                 "got \(_modifiers.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _typealiasKeyword = raw[Cursor.typealiasToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _typealiasKeywordTokenKind = _typealiasKeyword.tokenKind else {
      fatalError("expected token child, got \(_typealiasKeyword.kind)")
    }
    precondition([.typealiasKeyword].contains(_typealiasKeywordTokenKind),
      "expected one of [.typealiasKeyword] for 'typealiasKeyword' " + 
      "in node of kind typealiasDecl")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _identifier = raw[Cursor.identifierToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _identifierTokenKind = _identifier.tokenKind else {
      fatalError("expected token child, got \(_identifier.kind)")
    }
    precondition([.identifier].contains(_identifierTokenKind),
      "expected one of [.identifier] for 'identifier' " + 
      "in node of kind typealiasDecl")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _genericParameterClause = raw[Cursor.genericParameterClause]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_genericParameterClause.kind == .genericParameterClause,
                 "expected child of kind .genericParameterClause, " +
                 "got \(_genericParameterClause.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _initializer = raw[Cursor.typeInitializerClause]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_initializer.kind == .typeInitializerClause,
                 "expected child of kind .typeInitializerClause, " +
                 "got \(_initializer.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _genericWhereClause = raw[Cursor.genericWhereClause]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_genericWhereClause.kind == .genericWhereClause,
                 "expected child of kind .genericWhereClause, " +
                 "got \(_genericWhereClause.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var attributes: AttributeListSyntax? {
    let child = data.cachedChild(at: Cursor.attributes)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? AttributeListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `Attribute` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: AttributeSyntax) -> TypealiasDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.attributes] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.attributeList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.attributes)
    return TypealiasDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `attributes` replaced.
  /// - param newChild: The new `attributes` to replace the node's
  ///                   current `attributes`, if present.
  public func withAttributes(
    _ newChild: AttributeListSyntax?) -> TypealiasDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.attributeList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.attributes)
    return TypealiasDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var modifiers: ModifierListSyntax? {
    let child = data.cachedChild(at: Cursor.modifiers)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? ModifierListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `Modifier` to the node's `modifiers`
  /// collection.
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  public func addModifier(_ element: DeclModifierSyntax) -> TypealiasDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.modifiers] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.modifierList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.modifiers)
    return TypealiasDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `modifiers` replaced.
  /// - param newChild: The new `modifiers` to replace the node's
  ///                   current `modifiers`, if present.
  public func withModifiers(
    _ newChild: ModifierListSyntax?) -> TypealiasDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.modifierList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.modifiers)
    return TypealiasDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var typealiasKeyword: TokenSyntax {
    let child = data.cachedChild(at: Cursor.typealiasKeyword)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `typealiasKeyword` replaced.
  /// - param newChild: The new `typealiasKeyword` to replace the node's
  ///                   current `typealiasKeyword`, if present.
  public func withTypealiasKeyword(
    _ newChild: TokenSyntax?) -> TypealiasDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.typealiasKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.typealiasKeyword)
    return TypealiasDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var identifier: TokenSyntax {
    let child = data.cachedChild(at: Cursor.identifier)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `identifier` replaced.
  /// - param newChild: The new `identifier` to replace the node's
  ///                   current `identifier`, if present.
  public func withIdentifier(
    _ newChild: TokenSyntax?) -> TypealiasDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.identifier)
    return TypealiasDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var genericParameterClause: GenericParameterClauseSyntax? {
    let child = data.cachedChild(at: Cursor.genericParameterClause)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? GenericParameterClauseSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `genericParameterClause` replaced.
  /// - param newChild: The new `genericParameterClause` to replace the node's
  ///                   current `genericParameterClause`, if present.
  public func withGenericParameterClause(
    _ newChild: GenericParameterClauseSyntax?) -> TypealiasDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.genericParameterClause)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.genericParameterClause)
    return TypealiasDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var initializer: TypeInitializerClauseSyntax? {
    let child = data.cachedChild(at: Cursor.initializer)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TypeInitializerClauseSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `initializer` replaced.
  /// - param newChild: The new `initializer` to replace the node's
  ///                   current `initializer`, if present.
  public func withInitializer(
    _ newChild: TypeInitializerClauseSyntax?) -> TypealiasDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.typeInitializerClause)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.initializer)
    return TypealiasDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var genericWhereClause: GenericWhereClauseSyntax? {
    let child = data.cachedChild(at: Cursor.genericWhereClause)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? GenericWhereClauseSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `genericWhereClause` replaced.
  /// - param newChild: The new `genericWhereClause` to replace the node's
  ///                   current `genericWhereClause`, if present.
  public func withGenericWhereClause(
    _ newChild: GenericWhereClauseSyntax?) -> TypealiasDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.genericWhereClause)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.genericWhereClause)
    return TypealiasDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `TypealiasDeclSyntax` nodes are equal to each other.
  public static func ==(lhs: TypealiasDeclSyntax, rhs: TypealiasDeclSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct AssociatedtypeDeclSyntax: DeclSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case attributes
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case modifiers
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case associatedtypeKeyword
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case identifier
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case inheritanceClause
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case initializer
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case genericWhereClause
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `AssociatedtypeDeclSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 7)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _attributes = raw[Cursor.attributeList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_attributes.kind == .attributeList,
                 "expected child of kind .attributeList, " +
                 "got \(_attributes.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _modifiers = raw[Cursor.modifierList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_modifiers.kind == .modifierList,
                 "expected child of kind .modifierList, " +
                 "got \(_modifiers.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _associatedtypeKeyword = raw[Cursor.associatedtypeToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _associatedtypeKeywordTokenKind = _associatedtypeKeyword.tokenKind else {
      fatalError("expected token child, got \(_associatedtypeKeyword.kind)")
    }
    precondition([.associatedtypeKeyword].contains(_associatedtypeKeywordTokenKind),
      "expected one of [.associatedtypeKeyword] for 'associatedtypeKeyword' " + 
      "in node of kind associatedtypeDecl")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _identifier = raw[Cursor.identifierToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _identifierTokenKind = _identifier.tokenKind else {
      fatalError("expected token child, got \(_identifier.kind)")
    }
    precondition([.identifier].contains(_identifierTokenKind),
      "expected one of [.identifier] for 'identifier' " + 
      "in node of kind associatedtypeDecl")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _inheritanceClause = raw[Cursor.typeInheritanceClause]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_inheritanceClause.kind == .typeInheritanceClause,
                 "expected child of kind .typeInheritanceClause, " +
                 "got \(_inheritanceClause.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _initializer = raw[Cursor.typeInitializerClause]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_initializer.kind == .typeInitializerClause,
                 "expected child of kind .typeInitializerClause, " +
                 "got \(_initializer.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _genericWhereClause = raw[Cursor.genericWhereClause]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_genericWhereClause.kind == .genericWhereClause,
                 "expected child of kind .genericWhereClause, " +
                 "got \(_genericWhereClause.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var attributes: AttributeListSyntax? {
    let child = data.cachedChild(at: Cursor.attributes)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? AttributeListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `Attribute` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: AttributeSyntax) -> AssociatedtypeDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.attributes] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.attributeList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.attributes)
    return AssociatedtypeDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `attributes` replaced.
  /// - param newChild: The new `attributes` to replace the node's
  ///                   current `attributes`, if present.
  public func withAttributes(
    _ newChild: AttributeListSyntax?) -> AssociatedtypeDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.attributeList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.attributes)
    return AssociatedtypeDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var modifiers: ModifierListSyntax? {
    let child = data.cachedChild(at: Cursor.modifiers)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? ModifierListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `Modifier` to the node's `modifiers`
  /// collection.
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  public func addModifier(_ element: DeclModifierSyntax) -> AssociatedtypeDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.modifiers] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.modifierList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.modifiers)
    return AssociatedtypeDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `modifiers` replaced.
  /// - param newChild: The new `modifiers` to replace the node's
  ///                   current `modifiers`, if present.
  public func withModifiers(
    _ newChild: ModifierListSyntax?) -> AssociatedtypeDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.modifierList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.modifiers)
    return AssociatedtypeDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var associatedtypeKeyword: TokenSyntax {
    let child = data.cachedChild(at: Cursor.associatedtypeKeyword)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `associatedtypeKeyword` replaced.
  /// - param newChild: The new `associatedtypeKeyword` to replace the node's
  ///                   current `associatedtypeKeyword`, if present.
  public func withAssociatedtypeKeyword(
    _ newChild: TokenSyntax?) -> AssociatedtypeDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.associatedtypeKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.associatedtypeKeyword)
    return AssociatedtypeDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var identifier: TokenSyntax {
    let child = data.cachedChild(at: Cursor.identifier)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `identifier` replaced.
  /// - param newChild: The new `identifier` to replace the node's
  ///                   current `identifier`, if present.
  public func withIdentifier(
    _ newChild: TokenSyntax?) -> AssociatedtypeDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.identifier)
    return AssociatedtypeDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var inheritanceClause: TypeInheritanceClauseSyntax? {
    let child = data.cachedChild(at: Cursor.inheritanceClause)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TypeInheritanceClauseSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `inheritanceClause` replaced.
  /// - param newChild: The new `inheritanceClause` to replace the node's
  ///                   current `inheritanceClause`, if present.
  public func withInheritanceClause(
    _ newChild: TypeInheritanceClauseSyntax?) -> AssociatedtypeDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.typeInheritanceClause)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.inheritanceClause)
    return AssociatedtypeDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var initializer: TypeInitializerClauseSyntax? {
    let child = data.cachedChild(at: Cursor.initializer)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TypeInitializerClauseSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `initializer` replaced.
  /// - param newChild: The new `initializer` to replace the node's
  ///                   current `initializer`, if present.
  public func withInitializer(
    _ newChild: TypeInitializerClauseSyntax?) -> AssociatedtypeDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.typeInitializerClause)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.initializer)
    return AssociatedtypeDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var genericWhereClause: GenericWhereClauseSyntax? {
    let child = data.cachedChild(at: Cursor.genericWhereClause)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? GenericWhereClauseSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `genericWhereClause` replaced.
  /// - param newChild: The new `genericWhereClause` to replace the node's
  ///                   current `genericWhereClause`, if present.
  public func withGenericWhereClause(
    _ newChild: GenericWhereClauseSyntax?) -> AssociatedtypeDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.genericWhereClause)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.genericWhereClause)
    return AssociatedtypeDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `AssociatedtypeDeclSyntax` nodes are equal to each other.
  public static func ==(lhs: AssociatedtypeDeclSyntax, rhs: AssociatedtypeDeclSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct ParameterClauseSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case leftParen
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case parameterList
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case rightParen
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `ParameterClauseSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 3)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _leftParen = raw[Cursor.leftParenToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _leftParenTokenKind = _leftParen.tokenKind else {
      fatalError("expected token child, got \(_leftParen.kind)")
    }
    precondition([.leftParen].contains(_leftParenTokenKind),
      "expected one of [.leftParen] for 'leftParen' " + 
      "in node of kind parameterClause")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _parameterList = raw[Cursor.functionParameterList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_parameterList.kind == .functionParameterList,
                 "expected child of kind .functionParameterList, " +
                 "got \(_parameterList.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _rightParen = raw[Cursor.rightParenToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _rightParenTokenKind = _rightParen.tokenKind else {
      fatalError("expected token child, got \(_rightParen.kind)")
    }
    precondition([.rightParen].contains(_rightParenTokenKind),
      "expected one of [.rightParen] for 'rightParen' " + 
      "in node of kind parameterClause")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var leftParen: TokenSyntax {
    let child = data.cachedChild(at: Cursor.leftParen)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `leftParen` replaced.
  /// - param newChild: The new `leftParen` to replace the node's
  ///                   current `leftParen`, if present.
  public func withLeftParen(
    _ newChild: TokenSyntax?) -> ParameterClauseSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftParen)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.leftParen)
    return ParameterClauseSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var parameterList: FunctionParameterListSyntax {
    let child = data.cachedChild(at: Cursor.parameterList)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! FunctionParameterListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `FunctionParameter` to the node's `parameterList`
  /// collection.
  /// - param element: The new `FunctionParameter` to add to the node's
  ///                  `parameterList` collection.
  /// - returns: A copy of the receiver with the provided `FunctionParameter`
  ///            appended to its `parameterList` collection.
  public func addFunctionParameter(_ element: FunctionParameterSyntax) -> ParameterClauseSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.parameterList] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.functionParameterList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.parameterList)
    return ParameterClauseSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `parameterList` replaced.
  /// - param newChild: The new `parameterList` to replace the node's
  ///                   current `parameterList`, if present.
  public func withParameterList(
    _ newChild: FunctionParameterListSyntax?) -> ParameterClauseSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.functionParameterList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.parameterList)
    return ParameterClauseSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var rightParen: TokenSyntax {
    let child = data.cachedChild(at: Cursor.rightParen)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `rightParen` replaced.
  /// - param newChild: The new `rightParen` to replace the node's
  ///                   current `rightParen`, if present.
  public func withRightParen(
    _ newChild: TokenSyntax?) -> ParameterClauseSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightParen)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.rightParen)
    return ParameterClauseSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `ParameterClauseSyntax` nodes are equal to each other.
  public static func ==(lhs: ParameterClauseSyntax, rhs: ParameterClauseSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct ReturnClauseSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case arrow
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case returnType
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `ReturnClauseSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 2)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _arrow = raw[Cursor.arrowToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _arrowTokenKind = _arrow.tokenKind else {
      fatalError("expected token child, got \(_arrow.kind)")
    }
    precondition([.arrow].contains(_arrowTokenKind),
      "expected one of [.arrow] for 'arrow' " + 
      "in node of kind returnClause")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _returnType = raw[Cursor.type]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_returnType.kind == .type,
                 "expected child of kind .type, " +
                 "got \(_returnType.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var arrow: TokenSyntax {
    let child = data.cachedChild(at: Cursor.arrow)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `arrow` replaced.
  /// - param newChild: The new `arrow` to replace the node's
  ///                   current `arrow`, if present.
  public func withArrow(
    _ newChild: TokenSyntax?) -> ReturnClauseSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.arrow)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.arrow)
    return ReturnClauseSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var returnType: TypeSyntax {
    let child = data.cachedChild(at: Cursor.returnType)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TypeSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `returnType` replaced.
  /// - param newChild: The new `returnType` to replace the node's
  ///                   current `returnType`, if present.
  public func withReturnType(
    _ newChild: TypeSyntax?) -> ReturnClauseSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.type)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.returnType)
    return ReturnClauseSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `ReturnClauseSyntax` nodes are equal to each other.
  public static func ==(lhs: ReturnClauseSyntax, rhs: ReturnClauseSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct FunctionSignatureSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case input
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case throwsOrRethrowsKeyword
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case output
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `FunctionSignatureSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 3)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _input = raw[Cursor.parameterClause]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_input.kind == .parameterClause,
                 "expected child of kind .parameterClause, " +
                 "got \(_input.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _throwsOrRethrowsKeyword = raw[Cursor.token]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _throwsOrRethrowsKeywordTokenKind = _throwsOrRethrowsKeyword.tokenKind else {
      fatalError("expected token child, got \(_throwsOrRethrowsKeyword.kind)")
    }
    precondition([.throwsKeyword, .rethrowsKeyword].contains(_throwsOrRethrowsKeywordTokenKind),
      "expected one of [.throwsKeyword, .rethrowsKeyword] for 'throwsOrRethrowsKeyword' " + 
      "in node of kind functionSignature")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _output = raw[Cursor.returnClause]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_output.kind == .returnClause,
                 "expected child of kind .returnClause, " +
                 "got \(_output.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var input: ParameterClauseSyntax {
    let child = data.cachedChild(at: Cursor.input)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! ParameterClauseSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `input` replaced.
  /// - param newChild: The new `input` to replace the node's
  ///                   current `input`, if present.
  public func withInput(
    _ newChild: ParameterClauseSyntax?) -> FunctionSignatureSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.parameterClause)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.input)
    return FunctionSignatureSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var throwsOrRethrowsKeyword: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.throwsOrRethrowsKeyword)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `throwsOrRethrowsKeyword` replaced.
  /// - param newChild: The new `throwsOrRethrowsKeyword` to replace the node's
  ///                   current `throwsOrRethrowsKeyword`, if present.
  public func withThrowsOrRethrowsKeyword(
    _ newChild: TokenSyntax?) -> FunctionSignatureSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.throwsKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.throwsOrRethrowsKeyword)
    return FunctionSignatureSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var output: ReturnClauseSyntax? {
    let child = data.cachedChild(at: Cursor.output)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? ReturnClauseSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `output` replaced.
  /// - param newChild: The new `output` to replace the node's
  ///                   current `output`, if present.
  public func withOutput(
    _ newChild: ReturnClauseSyntax?) -> FunctionSignatureSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.returnClause)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.output)
    return FunctionSignatureSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `FunctionSignatureSyntax` nodes are equal to each other.
  public static func ==(lhs: FunctionSignatureSyntax, rhs: FunctionSignatureSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct IfConfigClauseSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case poundKeyword
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case condition
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case elements
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `IfConfigClauseSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 3)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _poundKeyword = raw[Cursor.token]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _poundKeywordTokenKind = _poundKeyword.tokenKind else {
      fatalError("expected token child, got \(_poundKeyword.kind)")
    }
    precondition([.poundIfKeyword, .poundElseifKeyword, .poundElseKeyword].contains(_poundKeywordTokenKind),
      "expected one of [.poundIfKeyword, .poundElseifKeyword, .poundElseKeyword] for 'poundKeyword' " + 
      "in node of kind ifConfigClause")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _condition = raw[Cursor.expr]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_condition.kind == .expr,
                 "expected child of kind .expr, " +
                 "got \(_condition.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _elements = raw[Cursor.syntax]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_elements.kind == .syntax,
                 "expected child of kind .syntax, " +
                 "got \(_elements.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var poundKeyword: TokenSyntax {
    let child = data.cachedChild(at: Cursor.poundKeyword)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `poundKeyword` replaced.
  /// - param newChild: The new `poundKeyword` to replace the node's
  ///                   current `poundKeyword`, if present.
  public func withPoundKeyword(
    _ newChild: TokenSyntax?) -> IfConfigClauseSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.poundIfKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.poundKeyword)
    return IfConfigClauseSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var condition: ExprSyntax? {
    let child = data.cachedChild(at: Cursor.condition)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? ExprSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `condition` replaced.
  /// - param newChild: The new `condition` to replace the node's
  ///                   current `condition`, if present.
  public func withCondition(
    _ newChild: ExprSyntax?) -> IfConfigClauseSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.condition)
    return IfConfigClauseSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var elements: Syntax {
    let child = data.cachedChild(at: Cursor.elements)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) 
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `elements` replaced.
  /// - param newChild: The new `elements` to replace the node's
  ///                   current `elements`, if present.
  public func withElements(
    _ newChild: Syntax?) -> IfConfigClauseSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.unknown)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.elements)
    return IfConfigClauseSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `IfConfigClauseSyntax` nodes are equal to each other.
  public static func ==(lhs: IfConfigClauseSyntax, rhs: IfConfigClauseSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct IfConfigDeclSyntax: DeclSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case clauses
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case poundEndif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `IfConfigDeclSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 2)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _clauses = raw[Cursor.ifConfigClauseList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_clauses.kind == .ifConfigClauseList,
                 "expected child of kind .ifConfigClauseList, " +
                 "got \(_clauses.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _poundEndif = raw[Cursor.poundEndifToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _poundEndifTokenKind = _poundEndif.tokenKind else {
      fatalError("expected token child, got \(_poundEndif.kind)")
    }
    precondition([.poundEndifKeyword].contains(_poundEndifTokenKind),
      "expected one of [.poundEndifKeyword] for 'poundEndif' " + 
      "in node of kind ifConfigDecl")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var clauses: IfConfigClauseListSyntax {
    let child = data.cachedChild(at: Cursor.clauses)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! IfConfigClauseListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `IfConfigClause` to the node's `clauses`
  /// collection.
  /// - param element: The new `IfConfigClause` to add to the node's
  ///                  `clauses` collection.
  /// - returns: A copy of the receiver with the provided `IfConfigClause`
  ///            appended to its `clauses` collection.
  public func addIfConfigClause(_ element: IfConfigClauseSyntax) -> IfConfigDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.clauses] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.ifConfigClauseList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.clauses)
    return IfConfigDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `clauses` replaced.
  /// - param newChild: The new `clauses` to replace the node's
  ///                   current `clauses`, if present.
  public func withClauses(
    _ newChild: IfConfigClauseListSyntax?) -> IfConfigDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.ifConfigClauseList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.clauses)
    return IfConfigDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var poundEndif: TokenSyntax {
    let child = data.cachedChild(at: Cursor.poundEndif)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `poundEndif` replaced.
  /// - param newChild: The new `poundEndif` to replace the node's
  ///                   current `poundEndif`, if present.
  public func withPoundEndif(
    _ newChild: TokenSyntax?) -> IfConfigDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.poundEndifKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.poundEndif)
    return IfConfigDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `IfConfigDeclSyntax` nodes are equal to each other.
  public static func ==(lhs: IfConfigDeclSyntax, rhs: IfConfigDeclSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct PoundErrorDeclSyntax: DeclSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case poundError
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case leftParen
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case message
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case rightParen
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `PoundErrorDeclSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 4)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _poundError = raw[Cursor.poundErrorToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _poundErrorTokenKind = _poundError.tokenKind else {
      fatalError("expected token child, got \(_poundError.kind)")
    }
    precondition([.poundErrorKeyword].contains(_poundErrorTokenKind),
      "expected one of [.poundErrorKeyword] for 'poundError' " + 
      "in node of kind poundErrorDecl")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _leftParen = raw[Cursor.leftParenToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _leftParenTokenKind = _leftParen.tokenKind else {
      fatalError("expected token child, got \(_leftParen.kind)")
    }
    precondition([.leftParen].contains(_leftParenTokenKind),
      "expected one of [.leftParen] for 'leftParen' " + 
      "in node of kind poundErrorDecl")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _message = raw[Cursor.stringLiteralExpr]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_message.kind == .stringLiteralExpr,
                 "expected child of kind .stringLiteralExpr, " +
                 "got \(_message.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _rightParen = raw[Cursor.rightParenToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _rightParenTokenKind = _rightParen.tokenKind else {
      fatalError("expected token child, got \(_rightParen.kind)")
    }
    precondition([.rightParen].contains(_rightParenTokenKind),
      "expected one of [.rightParen] for 'rightParen' " + 
      "in node of kind poundErrorDecl")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var poundError: TokenSyntax {
    let child = data.cachedChild(at: Cursor.poundError)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `poundError` replaced.
  /// - param newChild: The new `poundError` to replace the node's
  ///                   current `poundError`, if present.
  public func withPoundError(
    _ newChild: TokenSyntax?) -> PoundErrorDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.poundErrorKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.poundError)
    return PoundErrorDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var leftParen: TokenSyntax {
    let child = data.cachedChild(at: Cursor.leftParen)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `leftParen` replaced.
  /// - param newChild: The new `leftParen` to replace the node's
  ///                   current `leftParen`, if present.
  public func withLeftParen(
    _ newChild: TokenSyntax?) -> PoundErrorDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftParen)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.leftParen)
    return PoundErrorDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var message: StringLiteralExprSyntax {
    let child = data.cachedChild(at: Cursor.message)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! StringLiteralExprSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `message` replaced.
  /// - param newChild: The new `message` to replace the node's
  ///                   current `message`, if present.
  public func withMessage(
    _ newChild: StringLiteralExprSyntax?) -> PoundErrorDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.stringLiteralExpr)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.message)
    return PoundErrorDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var rightParen: TokenSyntax {
    let child = data.cachedChild(at: Cursor.rightParen)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `rightParen` replaced.
  /// - param newChild: The new `rightParen` to replace the node's
  ///                   current `rightParen`, if present.
  public func withRightParen(
    _ newChild: TokenSyntax?) -> PoundErrorDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightParen)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.rightParen)
    return PoundErrorDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `PoundErrorDeclSyntax` nodes are equal to each other.
  public static func ==(lhs: PoundErrorDeclSyntax, rhs: PoundErrorDeclSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct PoundWarningDeclSyntax: DeclSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case poundWarning
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case leftParen
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case message
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case rightParen
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `PoundWarningDeclSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 4)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _poundWarning = raw[Cursor.poundWarningToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _poundWarningTokenKind = _poundWarning.tokenKind else {
      fatalError("expected token child, got \(_poundWarning.kind)")
    }
    precondition([.poundWarningKeyword].contains(_poundWarningTokenKind),
      "expected one of [.poundWarningKeyword] for 'poundWarning' " + 
      "in node of kind poundWarningDecl")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _leftParen = raw[Cursor.leftParenToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _leftParenTokenKind = _leftParen.tokenKind else {
      fatalError("expected token child, got \(_leftParen.kind)")
    }
    precondition([.leftParen].contains(_leftParenTokenKind),
      "expected one of [.leftParen] for 'leftParen' " + 
      "in node of kind poundWarningDecl")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _message = raw[Cursor.stringLiteralExpr]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_message.kind == .stringLiteralExpr,
                 "expected child of kind .stringLiteralExpr, " +
                 "got \(_message.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _rightParen = raw[Cursor.rightParenToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _rightParenTokenKind = _rightParen.tokenKind else {
      fatalError("expected token child, got \(_rightParen.kind)")
    }
    precondition([.rightParen].contains(_rightParenTokenKind),
      "expected one of [.rightParen] for 'rightParen' " + 
      "in node of kind poundWarningDecl")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var poundWarning: TokenSyntax {
    let child = data.cachedChild(at: Cursor.poundWarning)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `poundWarning` replaced.
  /// - param newChild: The new `poundWarning` to replace the node's
  ///                   current `poundWarning`, if present.
  public func withPoundWarning(
    _ newChild: TokenSyntax?) -> PoundWarningDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.poundWarningKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.poundWarning)
    return PoundWarningDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var leftParen: TokenSyntax {
    let child = data.cachedChild(at: Cursor.leftParen)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `leftParen` replaced.
  /// - param newChild: The new `leftParen` to replace the node's
  ///                   current `leftParen`, if present.
  public func withLeftParen(
    _ newChild: TokenSyntax?) -> PoundWarningDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftParen)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.leftParen)
    return PoundWarningDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var message: StringLiteralExprSyntax {
    let child = data.cachedChild(at: Cursor.message)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! StringLiteralExprSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `message` replaced.
  /// - param newChild: The new `message` to replace the node's
  ///                   current `message`, if present.
  public func withMessage(
    _ newChild: StringLiteralExprSyntax?) -> PoundWarningDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.stringLiteralExpr)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.message)
    return PoundWarningDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var rightParen: TokenSyntax {
    let child = data.cachedChild(at: Cursor.rightParen)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `rightParen` replaced.
  /// - param newChild: The new `rightParen` to replace the node's
  ///                   current `rightParen`, if present.
  public func withRightParen(
    _ newChild: TokenSyntax?) -> PoundWarningDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightParen)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.rightParen)
    return PoundWarningDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `PoundWarningDeclSyntax` nodes are equal to each other.
  public static func ==(lhs: PoundWarningDeclSyntax, rhs: PoundWarningDeclSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct PoundSourceLocationSyntax: DeclSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case poundSourceLocation
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case leftParen
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case args
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case rightParen
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `PoundSourceLocationSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 4)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _poundSourceLocation = raw[Cursor.poundSourceLocationToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _poundSourceLocationTokenKind = _poundSourceLocation.tokenKind else {
      fatalError("expected token child, got \(_poundSourceLocation.kind)")
    }
    precondition([.poundSourceLocationKeyword].contains(_poundSourceLocationTokenKind),
      "expected one of [.poundSourceLocationKeyword] for 'poundSourceLocation' " + 
      "in node of kind poundSourceLocation")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _leftParen = raw[Cursor.leftParenToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _leftParenTokenKind = _leftParen.tokenKind else {
      fatalError("expected token child, got \(_leftParen.kind)")
    }
    precondition([.leftParen].contains(_leftParenTokenKind),
      "expected one of [.leftParen] for 'leftParen' " + 
      "in node of kind poundSourceLocation")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _args = raw[Cursor.poundSourceLocationArgs]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_args.kind == .poundSourceLocationArgs,
                 "expected child of kind .poundSourceLocationArgs, " +
                 "got \(_args.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _rightParen = raw[Cursor.rightParenToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _rightParenTokenKind = _rightParen.tokenKind else {
      fatalError("expected token child, got \(_rightParen.kind)")
    }
    precondition([.rightParen].contains(_rightParenTokenKind),
      "expected one of [.rightParen] for 'rightParen' " + 
      "in node of kind poundSourceLocation")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var poundSourceLocation: TokenSyntax {
    let child = data.cachedChild(at: Cursor.poundSourceLocation)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `poundSourceLocation` replaced.
  /// - param newChild: The new `poundSourceLocation` to replace the node's
  ///                   current `poundSourceLocation`, if present.
  public func withPoundSourceLocation(
    _ newChild: TokenSyntax?) -> PoundSourceLocationSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.poundSourceLocationKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.poundSourceLocation)
    return PoundSourceLocationSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var leftParen: TokenSyntax {
    let child = data.cachedChild(at: Cursor.leftParen)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `leftParen` replaced.
  /// - param newChild: The new `leftParen` to replace the node's
  ///                   current `leftParen`, if present.
  public func withLeftParen(
    _ newChild: TokenSyntax?) -> PoundSourceLocationSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftParen)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.leftParen)
    return PoundSourceLocationSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var args: PoundSourceLocationArgsSyntax? {
    let child = data.cachedChild(at: Cursor.args)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? PoundSourceLocationArgsSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `args` replaced.
  /// - param newChild: The new `args` to replace the node's
  ///                   current `args`, if present.
  public func withArgs(
    _ newChild: PoundSourceLocationArgsSyntax?) -> PoundSourceLocationSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.poundSourceLocationArgs)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.args)
    return PoundSourceLocationSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var rightParen: TokenSyntax {
    let child = data.cachedChild(at: Cursor.rightParen)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `rightParen` replaced.
  /// - param newChild: The new `rightParen` to replace the node's
  ///                   current `rightParen`, if present.
  public func withRightParen(
    _ newChild: TokenSyntax?) -> PoundSourceLocationSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightParen)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.rightParen)
    return PoundSourceLocationSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `PoundSourceLocationSyntax` nodes are equal to each other.
  public static func ==(lhs: PoundSourceLocationSyntax, rhs: PoundSourceLocationSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct PoundSourceLocationArgsSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case fileArgLabel
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case fileArgColon
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case fileName
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case comma
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case lineArgLabel
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case lineArgColon
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case lineNumber
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `PoundSourceLocationArgsSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 7)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _fileArgLabel = raw[Cursor.identifierToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _fileArgLabelTokenKind = _fileArgLabel.tokenKind else {
      fatalError("expected token child, got \(_fileArgLabel.kind)")
    }
    precondition([.identifier].contains(_fileArgLabelTokenKind),
      "expected one of [.identifier] for 'fileArgLabel' " + 
      "in node of kind poundSourceLocationArgs")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _fileArgColon = raw[Cursor.colonToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _fileArgColonTokenKind = _fileArgColon.tokenKind else {
      fatalError("expected token child, got \(_fileArgColon.kind)")
    }
    precondition([.colon].contains(_fileArgColonTokenKind),
      "expected one of [.colon] for 'fileArgColon' " + 
      "in node of kind poundSourceLocationArgs")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _fileName = raw[Cursor.stringLiteralToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _fileNameTokenKind = _fileName.tokenKind else {
      fatalError("expected token child, got \(_fileName.kind)")
    }
    precondition([.stringLiteral].contains(_fileNameTokenKind),
      "expected one of [.stringLiteral] for 'fileName' " + 
      "in node of kind poundSourceLocationArgs")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _comma = raw[Cursor.commaToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _commaTokenKind = _comma.tokenKind else {
      fatalError("expected token child, got \(_comma.kind)")
    }
    precondition([.comma].contains(_commaTokenKind),
      "expected one of [.comma] for 'comma' " + 
      "in node of kind poundSourceLocationArgs")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _lineArgLabel = raw[Cursor.identifierToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _lineArgLabelTokenKind = _lineArgLabel.tokenKind else {
      fatalError("expected token child, got \(_lineArgLabel.kind)")
    }
    precondition([.identifier].contains(_lineArgLabelTokenKind),
      "expected one of [.identifier] for 'lineArgLabel' " + 
      "in node of kind poundSourceLocationArgs")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _lineArgColon = raw[Cursor.colonToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _lineArgColonTokenKind = _lineArgColon.tokenKind else {
      fatalError("expected token child, got \(_lineArgColon.kind)")
    }
    precondition([.colon].contains(_lineArgColonTokenKind),
      "expected one of [.colon] for 'lineArgColon' " + 
      "in node of kind poundSourceLocationArgs")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _lineNumber = raw[Cursor.integerLiteralToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _lineNumberTokenKind = _lineNumber.tokenKind else {
      fatalError("expected token child, got \(_lineNumber.kind)")
    }
    precondition([.integerLiteral].contains(_lineNumberTokenKind),
      "expected one of [.integerLiteral] for 'lineNumber' " + 
      "in node of kind poundSourceLocationArgs")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var fileArgLabel: TokenSyntax {
    let child = data.cachedChild(at: Cursor.fileArgLabel)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `fileArgLabel` replaced.
  /// - param newChild: The new `fileArgLabel` to replace the node's
  ///                   current `fileArgLabel`, if present.
  public func withFileArgLabel(
    _ newChild: TokenSyntax?) -> PoundSourceLocationArgsSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.fileArgLabel)
    return PoundSourceLocationArgsSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var fileArgColon: TokenSyntax {
    let child = data.cachedChild(at: Cursor.fileArgColon)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `fileArgColon` replaced.
  /// - param newChild: The new `fileArgColon` to replace the node's
  ///                   current `fileArgColon`, if present.
  public func withFileArgColon(
    _ newChild: TokenSyntax?) -> PoundSourceLocationArgsSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.colon)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.fileArgColon)
    return PoundSourceLocationArgsSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var fileName: TokenSyntax {
    let child = data.cachedChild(at: Cursor.fileName)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `fileName` replaced.
  /// - param newChild: The new `fileName` to replace the node's
  ///                   current `fileName`, if present.
  public func withFileName(
    _ newChild: TokenSyntax?) -> PoundSourceLocationArgsSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.stringLiteral(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.fileName)
    return PoundSourceLocationArgsSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var comma: TokenSyntax {
    let child = data.cachedChild(at: Cursor.comma)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `comma` replaced.
  /// - param newChild: The new `comma` to replace the node's
  ///                   current `comma`, if present.
  public func withComma(
    _ newChild: TokenSyntax?) -> PoundSourceLocationArgsSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.comma)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.comma)
    return PoundSourceLocationArgsSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var lineArgLabel: TokenSyntax {
    let child = data.cachedChild(at: Cursor.lineArgLabel)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `lineArgLabel` replaced.
  /// - param newChild: The new `lineArgLabel` to replace the node's
  ///                   current `lineArgLabel`, if present.
  public func withLineArgLabel(
    _ newChild: TokenSyntax?) -> PoundSourceLocationArgsSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.lineArgLabel)
    return PoundSourceLocationArgsSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var lineArgColon: TokenSyntax {
    let child = data.cachedChild(at: Cursor.lineArgColon)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `lineArgColon` replaced.
  /// - param newChild: The new `lineArgColon` to replace the node's
  ///                   current `lineArgColon`, if present.
  public func withLineArgColon(
    _ newChild: TokenSyntax?) -> PoundSourceLocationArgsSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.colon)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.lineArgColon)
    return PoundSourceLocationArgsSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var lineNumber: TokenSyntax {
    let child = data.cachedChild(at: Cursor.lineNumber)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `lineNumber` replaced.
  /// - param newChild: The new `lineNumber` to replace the node's
  ///                   current `lineNumber`, if present.
  public func withLineNumber(
    _ newChild: TokenSyntax?) -> PoundSourceLocationArgsSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.integerLiteral(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.lineNumber)
    return PoundSourceLocationArgsSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `PoundSourceLocationArgsSyntax` nodes are equal to each other.
  public static func ==(lhs: PoundSourceLocationArgsSyntax, rhs: PoundSourceLocationArgsSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct DeclModifierSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case name
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case detailLeftParen
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case detail
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case detailRightParen
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `DeclModifierSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 4)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _name = raw[Cursor.token]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 113)
    guard let _nameTokenKind = _name.tokenKind else {
      fatalError("expected token child, got \(_name.kind)")
    }
    precondition(["class", "convenience", "dynamic", "final", "infix", "lazy", "optional", "override", "postfix", "prefix", "required", "static", "unowned", "weak", "private", "fileprivate", "internal", "public", "open", "mutating", "nonmutating", "indirect", "__consuming"].contains(_nameTokenKind.text),
                 "expected one of '[class, convenience, dynamic, final, infix, lazy, optional, override, postfix, prefix, required, static, unowned, weak, private, fileprivate, internal, public, open, mutating, nonmutating, indirect, __consuming]', got " +
                 "'\(_nameTokenKind.text)'")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _detailLeftParen = raw[Cursor.leftParenToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _detailLeftParenTokenKind = _detailLeftParen.tokenKind else {
      fatalError("expected token child, got \(_detailLeftParen.kind)")
    }
    precondition([.leftParen].contains(_detailLeftParenTokenKind),
      "expected one of [.leftParen] for 'detailLeftParen' " + 
      "in node of kind declModifier")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _detail = raw[Cursor.identifierToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _detailTokenKind = _detail.tokenKind else {
      fatalError("expected token child, got \(_detail.kind)")
    }
    precondition([.identifier].contains(_detailTokenKind),
      "expected one of [.identifier] for 'detail' " + 
      "in node of kind declModifier")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _detailRightParen = raw[Cursor.rightParenToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _detailRightParenTokenKind = _detailRightParen.tokenKind else {
      fatalError("expected token child, got \(_detailRightParen.kind)")
    }
    precondition([.rightParen].contains(_detailRightParenTokenKind),
      "expected one of [.rightParen] for 'detailRightParen' " + 
      "in node of kind declModifier")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var name: TokenSyntax {
    let child = data.cachedChild(at: Cursor.name)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `name` replaced.
  /// - param newChild: The new `name` to replace the node's
  ///                   current `name`, if present.
  public func withName(
    _ newChild: TokenSyntax?) -> DeclModifierSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.unknown(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.name)
    return DeclModifierSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var detailLeftParen: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.detailLeftParen)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `detailLeftParen` replaced.
  /// - param newChild: The new `detailLeftParen` to replace the node's
  ///                   current `detailLeftParen`, if present.
  public func withDetailLeftParen(
    _ newChild: TokenSyntax?) -> DeclModifierSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftParen)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.detailLeftParen)
    return DeclModifierSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var detail: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.detail)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `detail` replaced.
  /// - param newChild: The new `detail` to replace the node's
  ///                   current `detail`, if present.
  public func withDetail(
    _ newChild: TokenSyntax?) -> DeclModifierSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.detail)
    return DeclModifierSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var detailRightParen: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.detailRightParen)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `detailRightParen` replaced.
  /// - param newChild: The new `detailRightParen` to replace the node's
  ///                   current `detailRightParen`, if present.
  public func withDetailRightParen(
    _ newChild: TokenSyntax?) -> DeclModifierSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightParen)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.detailRightParen)
    return DeclModifierSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `DeclModifierSyntax` nodes are equal to each other.
  public static func ==(lhs: DeclModifierSyntax, rhs: DeclModifierSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct InheritedTypeSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case typeName
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case trailingComma
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `InheritedTypeSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 2)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _typeName = raw[Cursor.type]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_typeName.kind == .type,
                 "expected child of kind .type, " +
                 "got \(_typeName.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _trailingComma = raw[Cursor.commaToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _trailingCommaTokenKind = _trailingComma.tokenKind else {
      fatalError("expected token child, got \(_trailingComma.kind)")
    }
    precondition([.comma].contains(_trailingCommaTokenKind),
      "expected one of [.comma] for 'trailingComma' " + 
      "in node of kind inheritedType")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var typeName: TypeSyntax {
    let child = data.cachedChild(at: Cursor.typeName)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TypeSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `typeName` replaced.
  /// - param newChild: The new `typeName` to replace the node's
  ///                   current `typeName`, if present.
  public func withTypeName(
    _ newChild: TypeSyntax?) -> InheritedTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.type)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.typeName)
    return InheritedTypeSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var trailingComma: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.trailingComma)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `trailingComma` replaced.
  /// - param newChild: The new `trailingComma` to replace the node's
  ///                   current `trailingComma`, if present.
  public func withTrailingComma(
    _ newChild: TokenSyntax?) -> InheritedTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.comma)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.trailingComma)
    return InheritedTypeSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `InheritedTypeSyntax` nodes are equal to each other.
  public static func ==(lhs: InheritedTypeSyntax, rhs: InheritedTypeSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct TypeInheritanceClauseSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case colon
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case inheritedTypeCollection
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `TypeInheritanceClauseSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 2)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _colon = raw[Cursor.colonToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _colonTokenKind = _colon.tokenKind else {
      fatalError("expected token child, got \(_colon.kind)")
    }
    precondition([.colon].contains(_colonTokenKind),
      "expected one of [.colon] for 'colon' " + 
      "in node of kind typeInheritanceClause")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _inheritedTypeCollection = raw[Cursor.inheritedTypeList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_inheritedTypeCollection.kind == .inheritedTypeList,
                 "expected child of kind .inheritedTypeList, " +
                 "got \(_inheritedTypeCollection.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var colon: TokenSyntax {
    let child = data.cachedChild(at: Cursor.colon)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `colon` replaced.
  /// - param newChild: The new `colon` to replace the node's
  ///                   current `colon`, if present.
  public func withColon(
    _ newChild: TokenSyntax?) -> TypeInheritanceClauseSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.colon)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.colon)
    return TypeInheritanceClauseSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var inheritedTypeCollection: InheritedTypeListSyntax {
    let child = data.cachedChild(at: Cursor.inheritedTypeCollection)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! InheritedTypeListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `InheritedType` to the node's `inheritedTypeCollection`
  /// collection.
  /// - param element: The new `InheritedType` to add to the node's
  ///                  `inheritedTypeCollection` collection.
  /// - returns: A copy of the receiver with the provided `InheritedType`
  ///            appended to its `inheritedTypeCollection` collection.
  public func addInheritedType(_ element: InheritedTypeSyntax) -> TypeInheritanceClauseSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.inheritedTypeCollection] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.inheritedTypeList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.inheritedTypeCollection)
    return TypeInheritanceClauseSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `inheritedTypeCollection` replaced.
  /// - param newChild: The new `inheritedTypeCollection` to replace the node's
  ///                   current `inheritedTypeCollection`, if present.
  public func withInheritedTypeCollection(
    _ newChild: InheritedTypeListSyntax?) -> TypeInheritanceClauseSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.inheritedTypeList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.inheritedTypeCollection)
    return TypeInheritanceClauseSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `TypeInheritanceClauseSyntax` nodes are equal to each other.
  public static func ==(lhs: TypeInheritanceClauseSyntax, rhs: TypeInheritanceClauseSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct ClassDeclSyntax: DeclSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case attributes
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case modifiers
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case classKeyword
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case identifier
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case genericParameterClause
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case inheritanceClause
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case genericWhereClause
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case members
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `ClassDeclSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 8)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _attributes = raw[Cursor.attributeList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_attributes.kind == .attributeList,
                 "expected child of kind .attributeList, " +
                 "got \(_attributes.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _modifiers = raw[Cursor.modifierList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_modifiers.kind == .modifierList,
                 "expected child of kind .modifierList, " +
                 "got \(_modifiers.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _classKeyword = raw[Cursor.classToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _classKeywordTokenKind = _classKeyword.tokenKind else {
      fatalError("expected token child, got \(_classKeyword.kind)")
    }
    precondition([.classKeyword].contains(_classKeywordTokenKind),
      "expected one of [.classKeyword] for 'classKeyword' " + 
      "in node of kind classDecl")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _identifier = raw[Cursor.identifierToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _identifierTokenKind = _identifier.tokenKind else {
      fatalError("expected token child, got \(_identifier.kind)")
    }
    precondition([.identifier].contains(_identifierTokenKind),
      "expected one of [.identifier] for 'identifier' " + 
      "in node of kind classDecl")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _genericParameterClause = raw[Cursor.genericParameterClause]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_genericParameterClause.kind == .genericParameterClause,
                 "expected child of kind .genericParameterClause, " +
                 "got \(_genericParameterClause.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _inheritanceClause = raw[Cursor.typeInheritanceClause]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_inheritanceClause.kind == .typeInheritanceClause,
                 "expected child of kind .typeInheritanceClause, " +
                 "got \(_inheritanceClause.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _genericWhereClause = raw[Cursor.genericWhereClause]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_genericWhereClause.kind == .genericWhereClause,
                 "expected child of kind .genericWhereClause, " +
                 "got \(_genericWhereClause.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _members = raw[Cursor.memberDeclBlock]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_members.kind == .memberDeclBlock,
                 "expected child of kind .memberDeclBlock, " +
                 "got \(_members.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var attributes: AttributeListSyntax? {
    let child = data.cachedChild(at: Cursor.attributes)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? AttributeListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `Attribute` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: AttributeSyntax) -> ClassDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.attributes] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.attributeList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.attributes)
    return ClassDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `attributes` replaced.
  /// - param newChild: The new `attributes` to replace the node's
  ///                   current `attributes`, if present.
  public func withAttributes(
    _ newChild: AttributeListSyntax?) -> ClassDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.attributeList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.attributes)
    return ClassDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var modifiers: ModifierListSyntax? {
    let child = data.cachedChild(at: Cursor.modifiers)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? ModifierListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `Modifier` to the node's `modifiers`
  /// collection.
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  public func addModifier(_ element: DeclModifierSyntax) -> ClassDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.modifiers] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.modifierList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.modifiers)
    return ClassDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `modifiers` replaced.
  /// - param newChild: The new `modifiers` to replace the node's
  ///                   current `modifiers`, if present.
  public func withModifiers(
    _ newChild: ModifierListSyntax?) -> ClassDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.modifierList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.modifiers)
    return ClassDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var classKeyword: TokenSyntax {
    let child = data.cachedChild(at: Cursor.classKeyword)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `classKeyword` replaced.
  /// - param newChild: The new `classKeyword` to replace the node's
  ///                   current `classKeyword`, if present.
  public func withClassKeyword(
    _ newChild: TokenSyntax?) -> ClassDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.classKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.classKeyword)
    return ClassDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var identifier: TokenSyntax {
    let child = data.cachedChild(at: Cursor.identifier)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `identifier` replaced.
  /// - param newChild: The new `identifier` to replace the node's
  ///                   current `identifier`, if present.
  public func withIdentifier(
    _ newChild: TokenSyntax?) -> ClassDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.identifier)
    return ClassDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var genericParameterClause: GenericParameterClauseSyntax? {
    let child = data.cachedChild(at: Cursor.genericParameterClause)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? GenericParameterClauseSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `genericParameterClause` replaced.
  /// - param newChild: The new `genericParameterClause` to replace the node's
  ///                   current `genericParameterClause`, if present.
  public func withGenericParameterClause(
    _ newChild: GenericParameterClauseSyntax?) -> ClassDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.genericParameterClause)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.genericParameterClause)
    return ClassDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var inheritanceClause: TypeInheritanceClauseSyntax? {
    let child = data.cachedChild(at: Cursor.inheritanceClause)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TypeInheritanceClauseSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `inheritanceClause` replaced.
  /// - param newChild: The new `inheritanceClause` to replace the node's
  ///                   current `inheritanceClause`, if present.
  public func withInheritanceClause(
    _ newChild: TypeInheritanceClauseSyntax?) -> ClassDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.typeInheritanceClause)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.inheritanceClause)
    return ClassDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var genericWhereClause: GenericWhereClauseSyntax? {
    let child = data.cachedChild(at: Cursor.genericWhereClause)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? GenericWhereClauseSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `genericWhereClause` replaced.
  /// - param newChild: The new `genericWhereClause` to replace the node's
  ///                   current `genericWhereClause`, if present.
  public func withGenericWhereClause(
    _ newChild: GenericWhereClauseSyntax?) -> ClassDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.genericWhereClause)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.genericWhereClause)
    return ClassDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var members: MemberDeclBlockSyntax {
    let child = data.cachedChild(at: Cursor.members)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! MemberDeclBlockSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `members` replaced.
  /// - param newChild: The new `members` to replace the node's
  ///                   current `members`, if present.
  public func withMembers(
    _ newChild: MemberDeclBlockSyntax?) -> ClassDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.memberDeclBlock)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.members)
    return ClassDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `ClassDeclSyntax` nodes are equal to each other.
  public static func ==(lhs: ClassDeclSyntax, rhs: ClassDeclSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct StructDeclSyntax: DeclSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case attributes
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case modifiers
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case structKeyword
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case identifier
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case genericParameterClause
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case inheritanceClause
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case genericWhereClause
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case members
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `StructDeclSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 8)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _attributes = raw[Cursor.attributeList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_attributes.kind == .attributeList,
                 "expected child of kind .attributeList, " +
                 "got \(_attributes.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _modifiers = raw[Cursor.modifierList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_modifiers.kind == .modifierList,
                 "expected child of kind .modifierList, " +
                 "got \(_modifiers.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _structKeyword = raw[Cursor.structToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _structKeywordTokenKind = _structKeyword.tokenKind else {
      fatalError("expected token child, got \(_structKeyword.kind)")
    }
    precondition([.structKeyword].contains(_structKeywordTokenKind),
      "expected one of [.structKeyword] for 'structKeyword' " + 
      "in node of kind structDecl")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _identifier = raw[Cursor.identifierToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _identifierTokenKind = _identifier.tokenKind else {
      fatalError("expected token child, got \(_identifier.kind)")
    }
    precondition([.identifier].contains(_identifierTokenKind),
      "expected one of [.identifier] for 'identifier' " + 
      "in node of kind structDecl")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _genericParameterClause = raw[Cursor.genericParameterClause]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_genericParameterClause.kind == .genericParameterClause,
                 "expected child of kind .genericParameterClause, " +
                 "got \(_genericParameterClause.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _inheritanceClause = raw[Cursor.typeInheritanceClause]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_inheritanceClause.kind == .typeInheritanceClause,
                 "expected child of kind .typeInheritanceClause, " +
                 "got \(_inheritanceClause.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _genericWhereClause = raw[Cursor.genericWhereClause]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_genericWhereClause.kind == .genericWhereClause,
                 "expected child of kind .genericWhereClause, " +
                 "got \(_genericWhereClause.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _members = raw[Cursor.memberDeclBlock]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_members.kind == .memberDeclBlock,
                 "expected child of kind .memberDeclBlock, " +
                 "got \(_members.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var attributes: AttributeListSyntax? {
    let child = data.cachedChild(at: Cursor.attributes)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? AttributeListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `Attribute` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: AttributeSyntax) -> StructDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.attributes] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.attributeList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.attributes)
    return StructDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `attributes` replaced.
  /// - param newChild: The new `attributes` to replace the node's
  ///                   current `attributes`, if present.
  public func withAttributes(
    _ newChild: AttributeListSyntax?) -> StructDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.attributeList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.attributes)
    return StructDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var modifiers: ModifierListSyntax? {
    let child = data.cachedChild(at: Cursor.modifiers)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? ModifierListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `Modifier` to the node's `modifiers`
  /// collection.
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  public func addModifier(_ element: DeclModifierSyntax) -> StructDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.modifiers] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.modifierList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.modifiers)
    return StructDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `modifiers` replaced.
  /// - param newChild: The new `modifiers` to replace the node's
  ///                   current `modifiers`, if present.
  public func withModifiers(
    _ newChild: ModifierListSyntax?) -> StructDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.modifierList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.modifiers)
    return StructDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var structKeyword: TokenSyntax {
    let child = data.cachedChild(at: Cursor.structKeyword)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `structKeyword` replaced.
  /// - param newChild: The new `structKeyword` to replace the node's
  ///                   current `structKeyword`, if present.
  public func withStructKeyword(
    _ newChild: TokenSyntax?) -> StructDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.structKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.structKeyword)
    return StructDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var identifier: TokenSyntax {
    let child = data.cachedChild(at: Cursor.identifier)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `identifier` replaced.
  /// - param newChild: The new `identifier` to replace the node's
  ///                   current `identifier`, if present.
  public func withIdentifier(
    _ newChild: TokenSyntax?) -> StructDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.identifier)
    return StructDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var genericParameterClause: GenericParameterClauseSyntax? {
    let child = data.cachedChild(at: Cursor.genericParameterClause)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? GenericParameterClauseSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `genericParameterClause` replaced.
  /// - param newChild: The new `genericParameterClause` to replace the node's
  ///                   current `genericParameterClause`, if present.
  public func withGenericParameterClause(
    _ newChild: GenericParameterClauseSyntax?) -> StructDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.genericParameterClause)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.genericParameterClause)
    return StructDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var inheritanceClause: TypeInheritanceClauseSyntax? {
    let child = data.cachedChild(at: Cursor.inheritanceClause)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TypeInheritanceClauseSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `inheritanceClause` replaced.
  /// - param newChild: The new `inheritanceClause` to replace the node's
  ///                   current `inheritanceClause`, if present.
  public func withInheritanceClause(
    _ newChild: TypeInheritanceClauseSyntax?) -> StructDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.typeInheritanceClause)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.inheritanceClause)
    return StructDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var genericWhereClause: GenericWhereClauseSyntax? {
    let child = data.cachedChild(at: Cursor.genericWhereClause)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? GenericWhereClauseSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `genericWhereClause` replaced.
  /// - param newChild: The new `genericWhereClause` to replace the node's
  ///                   current `genericWhereClause`, if present.
  public func withGenericWhereClause(
    _ newChild: GenericWhereClauseSyntax?) -> StructDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.genericWhereClause)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.genericWhereClause)
    return StructDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var members: MemberDeclBlockSyntax {
    let child = data.cachedChild(at: Cursor.members)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! MemberDeclBlockSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `members` replaced.
  /// - param newChild: The new `members` to replace the node's
  ///                   current `members`, if present.
  public func withMembers(
    _ newChild: MemberDeclBlockSyntax?) -> StructDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.memberDeclBlock)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.members)
    return StructDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `StructDeclSyntax` nodes are equal to each other.
  public static func ==(lhs: StructDeclSyntax, rhs: StructDeclSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct ProtocolDeclSyntax: DeclSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case attributes
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case modifiers
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case protocolKeyword
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case identifier
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case inheritanceClause
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case genericWhereClause
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case members
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `ProtocolDeclSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 7)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _attributes = raw[Cursor.attributeList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_attributes.kind == .attributeList,
                 "expected child of kind .attributeList, " +
                 "got \(_attributes.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _modifiers = raw[Cursor.modifierList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_modifiers.kind == .modifierList,
                 "expected child of kind .modifierList, " +
                 "got \(_modifiers.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _protocolKeyword = raw[Cursor.protocolToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _protocolKeywordTokenKind = _protocolKeyword.tokenKind else {
      fatalError("expected token child, got \(_protocolKeyword.kind)")
    }
    precondition([.protocolKeyword].contains(_protocolKeywordTokenKind),
      "expected one of [.protocolKeyword] for 'protocolKeyword' " + 
      "in node of kind protocolDecl")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _identifier = raw[Cursor.identifierToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _identifierTokenKind = _identifier.tokenKind else {
      fatalError("expected token child, got \(_identifier.kind)")
    }
    precondition([.identifier].contains(_identifierTokenKind),
      "expected one of [.identifier] for 'identifier' " + 
      "in node of kind protocolDecl")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _inheritanceClause = raw[Cursor.typeInheritanceClause]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_inheritanceClause.kind == .typeInheritanceClause,
                 "expected child of kind .typeInheritanceClause, " +
                 "got \(_inheritanceClause.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _genericWhereClause = raw[Cursor.genericWhereClause]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_genericWhereClause.kind == .genericWhereClause,
                 "expected child of kind .genericWhereClause, " +
                 "got \(_genericWhereClause.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _members = raw[Cursor.memberDeclBlock]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_members.kind == .memberDeclBlock,
                 "expected child of kind .memberDeclBlock, " +
                 "got \(_members.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var attributes: AttributeListSyntax? {
    let child = data.cachedChild(at: Cursor.attributes)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? AttributeListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `Attribute` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: AttributeSyntax) -> ProtocolDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.attributes] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.attributeList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.attributes)
    return ProtocolDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `attributes` replaced.
  /// - param newChild: The new `attributes` to replace the node's
  ///                   current `attributes`, if present.
  public func withAttributes(
    _ newChild: AttributeListSyntax?) -> ProtocolDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.attributeList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.attributes)
    return ProtocolDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var modifiers: ModifierListSyntax? {
    let child = data.cachedChild(at: Cursor.modifiers)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? ModifierListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `Modifier` to the node's `modifiers`
  /// collection.
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  public func addModifier(_ element: DeclModifierSyntax) -> ProtocolDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.modifiers] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.modifierList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.modifiers)
    return ProtocolDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `modifiers` replaced.
  /// - param newChild: The new `modifiers` to replace the node's
  ///                   current `modifiers`, if present.
  public func withModifiers(
    _ newChild: ModifierListSyntax?) -> ProtocolDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.modifierList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.modifiers)
    return ProtocolDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var protocolKeyword: TokenSyntax {
    let child = data.cachedChild(at: Cursor.protocolKeyword)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `protocolKeyword` replaced.
  /// - param newChild: The new `protocolKeyword` to replace the node's
  ///                   current `protocolKeyword`, if present.
  public func withProtocolKeyword(
    _ newChild: TokenSyntax?) -> ProtocolDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.protocolKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.protocolKeyword)
    return ProtocolDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var identifier: TokenSyntax {
    let child = data.cachedChild(at: Cursor.identifier)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `identifier` replaced.
  /// - param newChild: The new `identifier` to replace the node's
  ///                   current `identifier`, if present.
  public func withIdentifier(
    _ newChild: TokenSyntax?) -> ProtocolDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.identifier)
    return ProtocolDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var inheritanceClause: TypeInheritanceClauseSyntax? {
    let child = data.cachedChild(at: Cursor.inheritanceClause)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TypeInheritanceClauseSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `inheritanceClause` replaced.
  /// - param newChild: The new `inheritanceClause` to replace the node's
  ///                   current `inheritanceClause`, if present.
  public func withInheritanceClause(
    _ newChild: TypeInheritanceClauseSyntax?) -> ProtocolDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.typeInheritanceClause)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.inheritanceClause)
    return ProtocolDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var genericWhereClause: GenericWhereClauseSyntax? {
    let child = data.cachedChild(at: Cursor.genericWhereClause)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? GenericWhereClauseSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `genericWhereClause` replaced.
  /// - param newChild: The new `genericWhereClause` to replace the node's
  ///                   current `genericWhereClause`, if present.
  public func withGenericWhereClause(
    _ newChild: GenericWhereClauseSyntax?) -> ProtocolDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.genericWhereClause)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.genericWhereClause)
    return ProtocolDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var members: MemberDeclBlockSyntax {
    let child = data.cachedChild(at: Cursor.members)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! MemberDeclBlockSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `members` replaced.
  /// - param newChild: The new `members` to replace the node's
  ///                   current `members`, if present.
  public func withMembers(
    _ newChild: MemberDeclBlockSyntax?) -> ProtocolDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.memberDeclBlock)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.members)
    return ProtocolDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `ProtocolDeclSyntax` nodes are equal to each other.
  public static func ==(lhs: ProtocolDeclSyntax, rhs: ProtocolDeclSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct ExtensionDeclSyntax: DeclSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case attributes
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case modifiers
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case extensionKeyword
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case extendedType
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case inheritanceClause
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case genericWhereClause
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case members
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `ExtensionDeclSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 7)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _attributes = raw[Cursor.attributeList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_attributes.kind == .attributeList,
                 "expected child of kind .attributeList, " +
                 "got \(_attributes.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _modifiers = raw[Cursor.modifierList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_modifiers.kind == .modifierList,
                 "expected child of kind .modifierList, " +
                 "got \(_modifiers.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _extensionKeyword = raw[Cursor.extensionToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _extensionKeywordTokenKind = _extensionKeyword.tokenKind else {
      fatalError("expected token child, got \(_extensionKeyword.kind)")
    }
    precondition([.extensionKeyword].contains(_extensionKeywordTokenKind),
      "expected one of [.extensionKeyword] for 'extensionKeyword' " + 
      "in node of kind extensionDecl")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _extendedType = raw[Cursor.type]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_extendedType.kind == .type,
                 "expected child of kind .type, " +
                 "got \(_extendedType.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _inheritanceClause = raw[Cursor.typeInheritanceClause]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_inheritanceClause.kind == .typeInheritanceClause,
                 "expected child of kind .typeInheritanceClause, " +
                 "got \(_inheritanceClause.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _genericWhereClause = raw[Cursor.genericWhereClause]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_genericWhereClause.kind == .genericWhereClause,
                 "expected child of kind .genericWhereClause, " +
                 "got \(_genericWhereClause.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _members = raw[Cursor.memberDeclBlock]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_members.kind == .memberDeclBlock,
                 "expected child of kind .memberDeclBlock, " +
                 "got \(_members.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var attributes: AttributeListSyntax? {
    let child = data.cachedChild(at: Cursor.attributes)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? AttributeListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `Attribute` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: AttributeSyntax) -> ExtensionDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.attributes] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.attributeList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.attributes)
    return ExtensionDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `attributes` replaced.
  /// - param newChild: The new `attributes` to replace the node's
  ///                   current `attributes`, if present.
  public func withAttributes(
    _ newChild: AttributeListSyntax?) -> ExtensionDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.attributeList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.attributes)
    return ExtensionDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var modifiers: ModifierListSyntax? {
    let child = data.cachedChild(at: Cursor.modifiers)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? ModifierListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `Modifier` to the node's `modifiers`
  /// collection.
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  public func addModifier(_ element: DeclModifierSyntax) -> ExtensionDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.modifiers] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.modifierList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.modifiers)
    return ExtensionDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `modifiers` replaced.
  /// - param newChild: The new `modifiers` to replace the node's
  ///                   current `modifiers`, if present.
  public func withModifiers(
    _ newChild: ModifierListSyntax?) -> ExtensionDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.modifierList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.modifiers)
    return ExtensionDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var extensionKeyword: TokenSyntax {
    let child = data.cachedChild(at: Cursor.extensionKeyword)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `extensionKeyword` replaced.
  /// - param newChild: The new `extensionKeyword` to replace the node's
  ///                   current `extensionKeyword`, if present.
  public func withExtensionKeyword(
    _ newChild: TokenSyntax?) -> ExtensionDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.extensionKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.extensionKeyword)
    return ExtensionDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var extendedType: TypeSyntax {
    let child = data.cachedChild(at: Cursor.extendedType)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TypeSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `extendedType` replaced.
  /// - param newChild: The new `extendedType` to replace the node's
  ///                   current `extendedType`, if present.
  public func withExtendedType(
    _ newChild: TypeSyntax?) -> ExtensionDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.type)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.extendedType)
    return ExtensionDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var inheritanceClause: TypeInheritanceClauseSyntax? {
    let child = data.cachedChild(at: Cursor.inheritanceClause)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TypeInheritanceClauseSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `inheritanceClause` replaced.
  /// - param newChild: The new `inheritanceClause` to replace the node's
  ///                   current `inheritanceClause`, if present.
  public func withInheritanceClause(
    _ newChild: TypeInheritanceClauseSyntax?) -> ExtensionDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.typeInheritanceClause)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.inheritanceClause)
    return ExtensionDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var genericWhereClause: GenericWhereClauseSyntax? {
    let child = data.cachedChild(at: Cursor.genericWhereClause)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? GenericWhereClauseSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `genericWhereClause` replaced.
  /// - param newChild: The new `genericWhereClause` to replace the node's
  ///                   current `genericWhereClause`, if present.
  public func withGenericWhereClause(
    _ newChild: GenericWhereClauseSyntax?) -> ExtensionDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.genericWhereClause)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.genericWhereClause)
    return ExtensionDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var members: MemberDeclBlockSyntax {
    let child = data.cachedChild(at: Cursor.members)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! MemberDeclBlockSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `members` replaced.
  /// - param newChild: The new `members` to replace the node's
  ///                   current `members`, if present.
  public func withMembers(
    _ newChild: MemberDeclBlockSyntax?) -> ExtensionDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.memberDeclBlock)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.members)
    return ExtensionDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `ExtensionDeclSyntax` nodes are equal to each other.
  public static func ==(lhs: ExtensionDeclSyntax, rhs: ExtensionDeclSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct MemberDeclBlockSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case leftBrace
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case members
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case rightBrace
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `MemberDeclBlockSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 3)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _leftBrace = raw[Cursor.leftBraceToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _leftBraceTokenKind = _leftBrace.tokenKind else {
      fatalError("expected token child, got \(_leftBrace.kind)")
    }
    precondition([.leftBrace].contains(_leftBraceTokenKind),
      "expected one of [.leftBrace] for 'leftBrace' " + 
      "in node of kind memberDeclBlock")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _members = raw[Cursor.memberDeclList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_members.kind == .memberDeclList,
                 "expected child of kind .memberDeclList, " +
                 "got \(_members.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _rightBrace = raw[Cursor.rightBraceToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _rightBraceTokenKind = _rightBrace.tokenKind else {
      fatalError("expected token child, got \(_rightBrace.kind)")
    }
    precondition([.rightBrace].contains(_rightBraceTokenKind),
      "expected one of [.rightBrace] for 'rightBrace' " + 
      "in node of kind memberDeclBlock")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var leftBrace: TokenSyntax {
    let child = data.cachedChild(at: Cursor.leftBrace)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `leftBrace` replaced.
  /// - param newChild: The new `leftBrace` to replace the node's
  ///                   current `leftBrace`, if present.
  public func withLeftBrace(
    _ newChild: TokenSyntax?) -> MemberDeclBlockSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftBrace)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.leftBrace)
    return MemberDeclBlockSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var members: MemberDeclListSyntax {
    let child = data.cachedChild(at: Cursor.members)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! MemberDeclListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `MemberDeclListItem` to the node's `members`
  /// collection.
  /// - param element: The new `MemberDeclListItem` to add to the node's
  ///                  `members` collection.
  /// - returns: A copy of the receiver with the provided `MemberDeclListItem`
  ///            appended to its `members` collection.
  public func addMemberDeclListItem(_ element: MemberDeclListItemSyntax) -> MemberDeclBlockSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.members] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.memberDeclList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.members)
    return MemberDeclBlockSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `members` replaced.
  /// - param newChild: The new `members` to replace the node's
  ///                   current `members`, if present.
  public func withMembers(
    _ newChild: MemberDeclListSyntax?) -> MemberDeclBlockSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.memberDeclList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.members)
    return MemberDeclBlockSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var rightBrace: TokenSyntax {
    let child = data.cachedChild(at: Cursor.rightBrace)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `rightBrace` replaced.
  /// - param newChild: The new `rightBrace` to replace the node's
  ///                   current `rightBrace`, if present.
  public func withRightBrace(
    _ newChild: TokenSyntax?) -> MemberDeclBlockSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightBrace)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.rightBrace)
    return MemberDeclBlockSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `MemberDeclBlockSyntax` nodes are equal to each other.
  public static func ==(lhs: MemberDeclBlockSyntax, rhs: MemberDeclBlockSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 70)
/// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 70)
/// A member declaration of a type consisting of a declaration and an          optional semicolon;
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 70)
/// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct MemberDeclListItemSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case decl
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case semicolon
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `MemberDeclListItemSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 2)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _decl = raw[Cursor.decl]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_decl.kind == .decl,
                 "expected child of kind .decl, " +
                 "got \(_decl.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _semicolon = raw[Cursor.semicolonToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _semicolonTokenKind = _semicolon.tokenKind else {
      fatalError("expected token child, got \(_semicolon.kind)")
    }
    precondition([.semicolon].contains(_semicolonTokenKind),
      "expected one of [.semicolon] for 'semicolon' " + 
      "in node of kind memberDeclListItem")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// The declaration of the type member.
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var decl: DeclSyntax {
    let child = data.cachedChild(at: Cursor.decl)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! DeclSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `decl` replaced.
  /// - param newChild: The new `decl` to replace the node's
  ///                   current `decl`, if present.
  public func withDecl(
    _ newChild: DeclSyntax?) -> MemberDeclListItemSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.decl)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.decl)
    return MemberDeclListItemSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// An optional trailing semicolon.
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var semicolon: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.semicolon)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `semicolon` replaced.
  /// - param newChild: The new `semicolon` to replace the node's
  ///                   current `semicolon`, if present.
  public func withSemicolon(
    _ newChild: TokenSyntax?) -> MemberDeclListItemSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.semicolon)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.semicolon)
    return MemberDeclListItemSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `MemberDeclListItemSyntax` nodes are equal to each other.
  public static func ==(lhs: MemberDeclListItemSyntax, rhs: MemberDeclListItemSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct SourceFileSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case statements
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case eofToken
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `SourceFileSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 2)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _statements = raw[Cursor.codeBlockItemList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_statements.kind == .codeBlockItemList,
                 "expected child of kind .codeBlockItemList, " +
                 "got \(_statements.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _eofToken = raw[Cursor.eofToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_eofToken.kind == .eofToken,
                 "expected child of kind .eofToken, " +
                 "got \(_eofToken.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var statements: CodeBlockItemListSyntax {
    let child = data.cachedChild(at: Cursor.statements)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! CodeBlockItemListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `CodeBlockItem` to the node's `statements`
  /// collection.
  /// - param element: The new `CodeBlockItem` to add to the node's
  ///                  `statements` collection.
  /// - returns: A copy of the receiver with the provided `CodeBlockItem`
  ///            appended to its `statements` collection.
  public func addCodeBlockItem(_ element: CodeBlockItemSyntax) -> SourceFileSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.statements] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.codeBlockItemList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.statements)
    return SourceFileSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `statements` replaced.
  /// - param newChild: The new `statements` to replace the node's
  ///                   current `statements`, if present.
  public func withStatements(
    _ newChild: CodeBlockItemListSyntax?) -> SourceFileSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.codeBlockItemList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.statements)
    return SourceFileSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var eofToken: TokenSyntax {
    let child = data.cachedChild(at: Cursor.eofToken)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `eofToken` replaced.
  /// - param newChild: The new `eofToken` to replace the node's
  ///                   current `eofToken`, if present.
  public func withEOFToken(
    _ newChild: TokenSyntax?) -> SourceFileSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.unknown(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.eofToken)
    return SourceFileSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `SourceFileSyntax` nodes are equal to each other.
  public static func ==(lhs: SourceFileSyntax, rhs: SourceFileSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct InitializerClauseSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case equal
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case value
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `InitializerClauseSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 2)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _equal = raw[Cursor.equalToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _equalTokenKind = _equal.tokenKind else {
      fatalError("expected token child, got \(_equal.kind)")
    }
    precondition([.equal].contains(_equalTokenKind),
      "expected one of [.equal] for 'equal' " + 
      "in node of kind initializerClause")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _value = raw[Cursor.expr]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_value.kind == .expr,
                 "expected child of kind .expr, " +
                 "got \(_value.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var equal: TokenSyntax {
    let child = data.cachedChild(at: Cursor.equal)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `equal` replaced.
  /// - param newChild: The new `equal` to replace the node's
  ///                   current `equal`, if present.
  public func withEqual(
    _ newChild: TokenSyntax?) -> InitializerClauseSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.equal)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.equal)
    return InitializerClauseSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var value: ExprSyntax {
    let child = data.cachedChild(at: Cursor.value)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! ExprSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `value` replaced.
  /// - param newChild: The new `value` to replace the node's
  ///                   current `value`, if present.
  public func withValue(
    _ newChild: ExprSyntax?) -> InitializerClauseSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.value)
    return InitializerClauseSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `InitializerClauseSyntax` nodes are equal to each other.
  public static func ==(lhs: InitializerClauseSyntax, rhs: InitializerClauseSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct FunctionParameterSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case attributes
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case firstName
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case secondName
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case colon
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case type
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case ellipsis
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case defaultArgument
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case trailingComma
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `FunctionParameterSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 8)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _attributes = raw[Cursor.attributeList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_attributes.kind == .attributeList,
                 "expected child of kind .attributeList, " +
                 "got \(_attributes.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _firstName = raw[Cursor.token]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _firstNameTokenKind = _firstName.tokenKind else {
      fatalError("expected token child, got \(_firstName.kind)")
    }
    precondition([.identifier, .wildcardKeyword].contains(_firstNameTokenKind),
      "expected one of [.identifier, .wildcardKeyword] for 'firstName' " + 
      "in node of kind functionParameter")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _secondName = raw[Cursor.token]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _secondNameTokenKind = _secondName.tokenKind else {
      fatalError("expected token child, got \(_secondName.kind)")
    }
    precondition([.identifier, .wildcardKeyword].contains(_secondNameTokenKind),
      "expected one of [.identifier, .wildcardKeyword] for 'secondName' " + 
      "in node of kind functionParameter")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _colon = raw[Cursor.colonToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _colonTokenKind = _colon.tokenKind else {
      fatalError("expected token child, got \(_colon.kind)")
    }
    precondition([.colon].contains(_colonTokenKind),
      "expected one of [.colon] for 'colon' " + 
      "in node of kind functionParameter")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _type = raw[Cursor.type]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_type.kind == .type,
                 "expected child of kind .type, " +
                 "got \(_type.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _ellipsis = raw[Cursor.token]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_ellipsis.kind == .token,
                 "expected child of kind .token, " +
                 "got \(_ellipsis.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _defaultArgument = raw[Cursor.initializerClause]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_defaultArgument.kind == .initializerClause,
                 "expected child of kind .initializerClause, " +
                 "got \(_defaultArgument.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _trailingComma = raw[Cursor.commaToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _trailingCommaTokenKind = _trailingComma.tokenKind else {
      fatalError("expected token child, got \(_trailingComma.kind)")
    }
    precondition([.comma].contains(_trailingCommaTokenKind),
      "expected one of [.comma] for 'trailingComma' " + 
      "in node of kind functionParameter")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var attributes: AttributeListSyntax? {
    let child = data.cachedChild(at: Cursor.attributes)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? AttributeListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `Attribute` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: AttributeSyntax) -> FunctionParameterSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.attributes] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.attributeList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.attributes)
    return FunctionParameterSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `attributes` replaced.
  /// - param newChild: The new `attributes` to replace the node's
  ///                   current `attributes`, if present.
  public func withAttributes(
    _ newChild: AttributeListSyntax?) -> FunctionParameterSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.attributeList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.attributes)
    return FunctionParameterSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var firstName: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.firstName)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `firstName` replaced.
  /// - param newChild: The new `firstName` to replace the node's
  ///                   current `firstName`, if present.
  public func withFirstName(
    _ newChild: TokenSyntax?) -> FunctionParameterSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.firstName)
    return FunctionParameterSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var secondName: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.secondName)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `secondName` replaced.
  /// - param newChild: The new `secondName` to replace the node's
  ///                   current `secondName`, if present.
  public func withSecondName(
    _ newChild: TokenSyntax?) -> FunctionParameterSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.secondName)
    return FunctionParameterSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var colon: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.colon)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `colon` replaced.
  /// - param newChild: The new `colon` to replace the node's
  ///                   current `colon`, if present.
  public func withColon(
    _ newChild: TokenSyntax?) -> FunctionParameterSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.colon)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.colon)
    return FunctionParameterSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var type: TypeSyntax? {
    let child = data.cachedChild(at: Cursor.type)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TypeSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `type` replaced.
  /// - param newChild: The new `type` to replace the node's
  ///                   current `type`, if present.
  public func withType(
    _ newChild: TypeSyntax?) -> FunctionParameterSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.type)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.type)
    return FunctionParameterSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var ellipsis: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.ellipsis)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `ellipsis` replaced.
  /// - param newChild: The new `ellipsis` to replace the node's
  ///                   current `ellipsis`, if present.
  public func withEllipsis(
    _ newChild: TokenSyntax?) -> FunctionParameterSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.unknown(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.ellipsis)
    return FunctionParameterSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var defaultArgument: InitializerClauseSyntax? {
    let child = data.cachedChild(at: Cursor.defaultArgument)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? InitializerClauseSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `defaultArgument` replaced.
  /// - param newChild: The new `defaultArgument` to replace the node's
  ///                   current `defaultArgument`, if present.
  public func withDefaultArgument(
    _ newChild: InitializerClauseSyntax?) -> FunctionParameterSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.initializerClause)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.defaultArgument)
    return FunctionParameterSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var trailingComma: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.trailingComma)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `trailingComma` replaced.
  /// - param newChild: The new `trailingComma` to replace the node's
  ///                   current `trailingComma`, if present.
  public func withTrailingComma(
    _ newChild: TokenSyntax?) -> FunctionParameterSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.comma)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.trailingComma)
    return FunctionParameterSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `FunctionParameterSyntax` nodes are equal to each other.
  public static func ==(lhs: FunctionParameterSyntax, rhs: FunctionParameterSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct FunctionDeclSyntax: DeclSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case attributes
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case modifiers
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case funcKeyword
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case identifier
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case genericParameterClause
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case signature
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case genericWhereClause
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case body
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `FunctionDeclSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 8)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _attributes = raw[Cursor.attributeList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_attributes.kind == .attributeList,
                 "expected child of kind .attributeList, " +
                 "got \(_attributes.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _modifiers = raw[Cursor.modifierList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_modifiers.kind == .modifierList,
                 "expected child of kind .modifierList, " +
                 "got \(_modifiers.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _funcKeyword = raw[Cursor.funcToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _funcKeywordTokenKind = _funcKeyword.tokenKind else {
      fatalError("expected token child, got \(_funcKeyword.kind)")
    }
    precondition([.funcKeyword].contains(_funcKeywordTokenKind),
      "expected one of [.funcKeyword] for 'funcKeyword' " + 
      "in node of kind functionDecl")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _identifier = raw[Cursor.token]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _identifierTokenKind = _identifier.tokenKind else {
      fatalError("expected token child, got \(_identifier.kind)")
    }
    precondition([.identifier, .unspacedBinaryOperator, .spacedBinaryOperator, .prefixOperator, .postfixOperator].contains(_identifierTokenKind),
      "expected one of [.identifier, .unspacedBinaryOperator, .spacedBinaryOperator, .prefixOperator, .postfixOperator] for 'identifier' " + 
      "in node of kind functionDecl")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _genericParameterClause = raw[Cursor.genericParameterClause]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_genericParameterClause.kind == .genericParameterClause,
                 "expected child of kind .genericParameterClause, " +
                 "got \(_genericParameterClause.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _signature = raw[Cursor.functionSignature]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_signature.kind == .functionSignature,
                 "expected child of kind .functionSignature, " +
                 "got \(_signature.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _genericWhereClause = raw[Cursor.genericWhereClause]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_genericWhereClause.kind == .genericWhereClause,
                 "expected child of kind .genericWhereClause, " +
                 "got \(_genericWhereClause.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _body = raw[Cursor.codeBlock]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_body.kind == .codeBlock,
                 "expected child of kind .codeBlock, " +
                 "got \(_body.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var attributes: AttributeListSyntax? {
    let child = data.cachedChild(at: Cursor.attributes)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? AttributeListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `Attribute` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: AttributeSyntax) -> FunctionDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.attributes] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.attributeList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.attributes)
    return FunctionDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `attributes` replaced.
  /// - param newChild: The new `attributes` to replace the node's
  ///                   current `attributes`, if present.
  public func withAttributes(
    _ newChild: AttributeListSyntax?) -> FunctionDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.attributeList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.attributes)
    return FunctionDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var modifiers: ModifierListSyntax? {
    let child = data.cachedChild(at: Cursor.modifiers)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? ModifierListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `Modifier` to the node's `modifiers`
  /// collection.
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  public func addModifier(_ element: DeclModifierSyntax) -> FunctionDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.modifiers] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.modifierList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.modifiers)
    return FunctionDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `modifiers` replaced.
  /// - param newChild: The new `modifiers` to replace the node's
  ///                   current `modifiers`, if present.
  public func withModifiers(
    _ newChild: ModifierListSyntax?) -> FunctionDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.modifierList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.modifiers)
    return FunctionDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var funcKeyword: TokenSyntax {
    let child = data.cachedChild(at: Cursor.funcKeyword)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `funcKeyword` replaced.
  /// - param newChild: The new `funcKeyword` to replace the node's
  ///                   current `funcKeyword`, if present.
  public func withFuncKeyword(
    _ newChild: TokenSyntax?) -> FunctionDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.funcKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.funcKeyword)
    return FunctionDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var identifier: TokenSyntax {
    let child = data.cachedChild(at: Cursor.identifier)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `identifier` replaced.
  /// - param newChild: The new `identifier` to replace the node's
  ///                   current `identifier`, if present.
  public func withIdentifier(
    _ newChild: TokenSyntax?) -> FunctionDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.identifier)
    return FunctionDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var genericParameterClause: GenericParameterClauseSyntax? {
    let child = data.cachedChild(at: Cursor.genericParameterClause)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? GenericParameterClauseSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `genericParameterClause` replaced.
  /// - param newChild: The new `genericParameterClause` to replace the node's
  ///                   current `genericParameterClause`, if present.
  public func withGenericParameterClause(
    _ newChild: GenericParameterClauseSyntax?) -> FunctionDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.genericParameterClause)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.genericParameterClause)
    return FunctionDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var signature: FunctionSignatureSyntax {
    let child = data.cachedChild(at: Cursor.signature)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! FunctionSignatureSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `signature` replaced.
  /// - param newChild: The new `signature` to replace the node's
  ///                   current `signature`, if present.
  public func withSignature(
    _ newChild: FunctionSignatureSyntax?) -> FunctionDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.functionSignature)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.signature)
    return FunctionDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var genericWhereClause: GenericWhereClauseSyntax? {
    let child = data.cachedChild(at: Cursor.genericWhereClause)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? GenericWhereClauseSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `genericWhereClause` replaced.
  /// - param newChild: The new `genericWhereClause` to replace the node's
  ///                   current `genericWhereClause`, if present.
  public func withGenericWhereClause(
    _ newChild: GenericWhereClauseSyntax?) -> FunctionDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.genericWhereClause)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.genericWhereClause)
    return FunctionDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var body: CodeBlockSyntax? {
    let child = data.cachedChild(at: Cursor.body)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? CodeBlockSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `body` replaced.
  /// - param newChild: The new `body` to replace the node's
  ///                   current `body`, if present.
  public func withBody(
    _ newChild: CodeBlockSyntax?) -> FunctionDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.codeBlock)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.body)
    return FunctionDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `FunctionDeclSyntax` nodes are equal to each other.
  public static func ==(lhs: FunctionDeclSyntax, rhs: FunctionDeclSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct InitializerDeclSyntax: DeclSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case attributes
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case modifiers
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case initKeyword
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case optionalMark
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case genericParameterClause
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case parameters
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case throwsOrRethrowsKeyword
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case genericWhereClause
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case body
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `InitializerDeclSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 9)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _attributes = raw[Cursor.attributeList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_attributes.kind == .attributeList,
                 "expected child of kind .attributeList, " +
                 "got \(_attributes.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _modifiers = raw[Cursor.modifierList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_modifiers.kind == .modifierList,
                 "expected child of kind .modifierList, " +
                 "got \(_modifiers.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _initKeyword = raw[Cursor.initToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _initKeywordTokenKind = _initKeyword.tokenKind else {
      fatalError("expected token child, got \(_initKeyword.kind)")
    }
    precondition([.initKeyword].contains(_initKeywordTokenKind),
      "expected one of [.initKeyword] for 'initKeyword' " + 
      "in node of kind initializerDecl")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _optionalMark = raw[Cursor.token]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _optionalMarkTokenKind = _optionalMark.tokenKind else {
      fatalError("expected token child, got \(_optionalMark.kind)")
    }
    precondition([.postfixQuestionMark, .infixQuestionMark, .exclamationMark].contains(_optionalMarkTokenKind),
      "expected one of [.postfixQuestionMark, .infixQuestionMark, .exclamationMark] for 'optionalMark' " + 
      "in node of kind initializerDecl")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _genericParameterClause = raw[Cursor.genericParameterClause]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_genericParameterClause.kind == .genericParameterClause,
                 "expected child of kind .genericParameterClause, " +
                 "got \(_genericParameterClause.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _parameters = raw[Cursor.parameterClause]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_parameters.kind == .parameterClause,
                 "expected child of kind .parameterClause, " +
                 "got \(_parameters.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _throwsOrRethrowsKeyword = raw[Cursor.token]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _throwsOrRethrowsKeywordTokenKind = _throwsOrRethrowsKeyword.tokenKind else {
      fatalError("expected token child, got \(_throwsOrRethrowsKeyword.kind)")
    }
    precondition([.throwsKeyword, .rethrowsKeyword].contains(_throwsOrRethrowsKeywordTokenKind),
      "expected one of [.throwsKeyword, .rethrowsKeyword] for 'throwsOrRethrowsKeyword' " + 
      "in node of kind initializerDecl")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _genericWhereClause = raw[Cursor.genericWhereClause]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_genericWhereClause.kind == .genericWhereClause,
                 "expected child of kind .genericWhereClause, " +
                 "got \(_genericWhereClause.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _body = raw[Cursor.codeBlock]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_body.kind == .codeBlock,
                 "expected child of kind .codeBlock, " +
                 "got \(_body.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var attributes: AttributeListSyntax? {
    let child = data.cachedChild(at: Cursor.attributes)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? AttributeListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `Attribute` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: AttributeSyntax) -> InitializerDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.attributes] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.attributeList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.attributes)
    return InitializerDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `attributes` replaced.
  /// - param newChild: The new `attributes` to replace the node's
  ///                   current `attributes`, if present.
  public func withAttributes(
    _ newChild: AttributeListSyntax?) -> InitializerDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.attributeList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.attributes)
    return InitializerDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var modifiers: ModifierListSyntax? {
    let child = data.cachedChild(at: Cursor.modifiers)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? ModifierListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `Modifier` to the node's `modifiers`
  /// collection.
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  public func addModifier(_ element: DeclModifierSyntax) -> InitializerDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.modifiers] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.modifierList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.modifiers)
    return InitializerDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `modifiers` replaced.
  /// - param newChild: The new `modifiers` to replace the node's
  ///                   current `modifiers`, if present.
  public func withModifiers(
    _ newChild: ModifierListSyntax?) -> InitializerDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.modifierList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.modifiers)
    return InitializerDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var initKeyword: TokenSyntax {
    let child = data.cachedChild(at: Cursor.initKeyword)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `initKeyword` replaced.
  /// - param newChild: The new `initKeyword` to replace the node's
  ///                   current `initKeyword`, if present.
  public func withInitKeyword(
    _ newChild: TokenSyntax?) -> InitializerDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.initKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.initKeyword)
    return InitializerDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var optionalMark: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.optionalMark)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `optionalMark` replaced.
  /// - param newChild: The new `optionalMark` to replace the node's
  ///                   current `optionalMark`, if present.
  public func withOptionalMark(
    _ newChild: TokenSyntax?) -> InitializerDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.postfixQuestionMark)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.optionalMark)
    return InitializerDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var genericParameterClause: GenericParameterClauseSyntax? {
    let child = data.cachedChild(at: Cursor.genericParameterClause)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? GenericParameterClauseSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `genericParameterClause` replaced.
  /// - param newChild: The new `genericParameterClause` to replace the node's
  ///                   current `genericParameterClause`, if present.
  public func withGenericParameterClause(
    _ newChild: GenericParameterClauseSyntax?) -> InitializerDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.genericParameterClause)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.genericParameterClause)
    return InitializerDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var parameters: ParameterClauseSyntax {
    let child = data.cachedChild(at: Cursor.parameters)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! ParameterClauseSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `parameters` replaced.
  /// - param newChild: The new `parameters` to replace the node's
  ///                   current `parameters`, if present.
  public func withParameters(
    _ newChild: ParameterClauseSyntax?) -> InitializerDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.parameterClause)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.parameters)
    return InitializerDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var throwsOrRethrowsKeyword: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.throwsOrRethrowsKeyword)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `throwsOrRethrowsKeyword` replaced.
  /// - param newChild: The new `throwsOrRethrowsKeyword` to replace the node's
  ///                   current `throwsOrRethrowsKeyword`, if present.
  public func withThrowsOrRethrowsKeyword(
    _ newChild: TokenSyntax?) -> InitializerDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.throwsKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.throwsOrRethrowsKeyword)
    return InitializerDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var genericWhereClause: GenericWhereClauseSyntax? {
    let child = data.cachedChild(at: Cursor.genericWhereClause)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? GenericWhereClauseSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `genericWhereClause` replaced.
  /// - param newChild: The new `genericWhereClause` to replace the node's
  ///                   current `genericWhereClause`, if present.
  public func withGenericWhereClause(
    _ newChild: GenericWhereClauseSyntax?) -> InitializerDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.genericWhereClause)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.genericWhereClause)
    return InitializerDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var body: CodeBlockSyntax? {
    let child = data.cachedChild(at: Cursor.body)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? CodeBlockSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `body` replaced.
  /// - param newChild: The new `body` to replace the node's
  ///                   current `body`, if present.
  public func withBody(
    _ newChild: CodeBlockSyntax?) -> InitializerDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.codeBlock)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.body)
    return InitializerDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `InitializerDeclSyntax` nodes are equal to each other.
  public static func ==(lhs: InitializerDeclSyntax, rhs: InitializerDeclSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct DeinitializerDeclSyntax: DeclSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case attributes
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case modifiers
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case deinitKeyword
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case body
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `DeinitializerDeclSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 4)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _attributes = raw[Cursor.attributeList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_attributes.kind == .attributeList,
                 "expected child of kind .attributeList, " +
                 "got \(_attributes.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _modifiers = raw[Cursor.modifierList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_modifiers.kind == .modifierList,
                 "expected child of kind .modifierList, " +
                 "got \(_modifiers.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _deinitKeyword = raw[Cursor.deinitToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _deinitKeywordTokenKind = _deinitKeyword.tokenKind else {
      fatalError("expected token child, got \(_deinitKeyword.kind)")
    }
    precondition([.deinitKeyword].contains(_deinitKeywordTokenKind),
      "expected one of [.deinitKeyword] for 'deinitKeyword' " + 
      "in node of kind deinitializerDecl")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _body = raw[Cursor.codeBlock]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_body.kind == .codeBlock,
                 "expected child of kind .codeBlock, " +
                 "got \(_body.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var attributes: AttributeListSyntax? {
    let child = data.cachedChild(at: Cursor.attributes)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? AttributeListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `Attribute` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: AttributeSyntax) -> DeinitializerDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.attributes] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.attributeList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.attributes)
    return DeinitializerDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `attributes` replaced.
  /// - param newChild: The new `attributes` to replace the node's
  ///                   current `attributes`, if present.
  public func withAttributes(
    _ newChild: AttributeListSyntax?) -> DeinitializerDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.attributeList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.attributes)
    return DeinitializerDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var modifiers: ModifierListSyntax? {
    let child = data.cachedChild(at: Cursor.modifiers)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? ModifierListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `Modifier` to the node's `modifiers`
  /// collection.
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  public func addModifier(_ element: DeclModifierSyntax) -> DeinitializerDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.modifiers] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.modifierList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.modifiers)
    return DeinitializerDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `modifiers` replaced.
  /// - param newChild: The new `modifiers` to replace the node's
  ///                   current `modifiers`, if present.
  public func withModifiers(
    _ newChild: ModifierListSyntax?) -> DeinitializerDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.modifierList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.modifiers)
    return DeinitializerDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var deinitKeyword: TokenSyntax {
    let child = data.cachedChild(at: Cursor.deinitKeyword)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `deinitKeyword` replaced.
  /// - param newChild: The new `deinitKeyword` to replace the node's
  ///                   current `deinitKeyword`, if present.
  public func withDeinitKeyword(
    _ newChild: TokenSyntax?) -> DeinitializerDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.deinitKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.deinitKeyword)
    return DeinitializerDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var body: CodeBlockSyntax {
    let child = data.cachedChild(at: Cursor.body)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! CodeBlockSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `body` replaced.
  /// - param newChild: The new `body` to replace the node's
  ///                   current `body`, if present.
  public func withBody(
    _ newChild: CodeBlockSyntax?) -> DeinitializerDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.codeBlock)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.body)
    return DeinitializerDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `DeinitializerDeclSyntax` nodes are equal to each other.
  public static func ==(lhs: DeinitializerDeclSyntax, rhs: DeinitializerDeclSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct SubscriptDeclSyntax: DeclSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case attributes
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case modifiers
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case subscriptKeyword
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case genericParameterClause
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case indices
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case result
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case genericWhereClause
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case accessor
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `SubscriptDeclSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 8)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _attributes = raw[Cursor.attributeList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_attributes.kind == .attributeList,
                 "expected child of kind .attributeList, " +
                 "got \(_attributes.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _modifiers = raw[Cursor.modifierList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_modifiers.kind == .modifierList,
                 "expected child of kind .modifierList, " +
                 "got \(_modifiers.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _subscriptKeyword = raw[Cursor.subscriptToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _subscriptKeywordTokenKind = _subscriptKeyword.tokenKind else {
      fatalError("expected token child, got \(_subscriptKeyword.kind)")
    }
    precondition([.subscriptKeyword].contains(_subscriptKeywordTokenKind),
      "expected one of [.subscriptKeyword] for 'subscriptKeyword' " + 
      "in node of kind subscriptDecl")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _genericParameterClause = raw[Cursor.genericParameterClause]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_genericParameterClause.kind == .genericParameterClause,
                 "expected child of kind .genericParameterClause, " +
                 "got \(_genericParameterClause.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _indices = raw[Cursor.parameterClause]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_indices.kind == .parameterClause,
                 "expected child of kind .parameterClause, " +
                 "got \(_indices.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _result = raw[Cursor.returnClause]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_result.kind == .returnClause,
                 "expected child of kind .returnClause, " +
                 "got \(_result.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _genericWhereClause = raw[Cursor.genericWhereClause]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_genericWhereClause.kind == .genericWhereClause,
                 "expected child of kind .genericWhereClause, " +
                 "got \(_genericWhereClause.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _accessor = raw[Cursor.accessorBlock]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_accessor.kind == .accessorBlock,
                 "expected child of kind .accessorBlock, " +
                 "got \(_accessor.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var attributes: AttributeListSyntax? {
    let child = data.cachedChild(at: Cursor.attributes)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? AttributeListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `Attribute` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: AttributeSyntax) -> SubscriptDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.attributes] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.attributeList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.attributes)
    return SubscriptDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `attributes` replaced.
  /// - param newChild: The new `attributes` to replace the node's
  ///                   current `attributes`, if present.
  public func withAttributes(
    _ newChild: AttributeListSyntax?) -> SubscriptDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.attributeList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.attributes)
    return SubscriptDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var modifiers: ModifierListSyntax? {
    let child = data.cachedChild(at: Cursor.modifiers)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? ModifierListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `Modifier` to the node's `modifiers`
  /// collection.
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  public func addModifier(_ element: DeclModifierSyntax) -> SubscriptDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.modifiers] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.modifierList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.modifiers)
    return SubscriptDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `modifiers` replaced.
  /// - param newChild: The new `modifiers` to replace the node's
  ///                   current `modifiers`, if present.
  public func withModifiers(
    _ newChild: ModifierListSyntax?) -> SubscriptDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.modifierList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.modifiers)
    return SubscriptDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var subscriptKeyword: TokenSyntax {
    let child = data.cachedChild(at: Cursor.subscriptKeyword)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `subscriptKeyword` replaced.
  /// - param newChild: The new `subscriptKeyword` to replace the node's
  ///                   current `subscriptKeyword`, if present.
  public func withSubscriptKeyword(
    _ newChild: TokenSyntax?) -> SubscriptDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.subscriptKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.subscriptKeyword)
    return SubscriptDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var genericParameterClause: GenericParameterClauseSyntax? {
    let child = data.cachedChild(at: Cursor.genericParameterClause)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? GenericParameterClauseSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `genericParameterClause` replaced.
  /// - param newChild: The new `genericParameterClause` to replace the node's
  ///                   current `genericParameterClause`, if present.
  public func withGenericParameterClause(
    _ newChild: GenericParameterClauseSyntax?) -> SubscriptDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.genericParameterClause)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.genericParameterClause)
    return SubscriptDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var indices: ParameterClauseSyntax {
    let child = data.cachedChild(at: Cursor.indices)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! ParameterClauseSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `indices` replaced.
  /// - param newChild: The new `indices` to replace the node's
  ///                   current `indices`, if present.
  public func withIndices(
    _ newChild: ParameterClauseSyntax?) -> SubscriptDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.parameterClause)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.indices)
    return SubscriptDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var result: ReturnClauseSyntax {
    let child = data.cachedChild(at: Cursor.result)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! ReturnClauseSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `result` replaced.
  /// - param newChild: The new `result` to replace the node's
  ///                   current `result`, if present.
  public func withResult(
    _ newChild: ReturnClauseSyntax?) -> SubscriptDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.returnClause)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.result)
    return SubscriptDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var genericWhereClause: GenericWhereClauseSyntax? {
    let child = data.cachedChild(at: Cursor.genericWhereClause)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? GenericWhereClauseSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `genericWhereClause` replaced.
  /// - param newChild: The new `genericWhereClause` to replace the node's
  ///                   current `genericWhereClause`, if present.
  public func withGenericWhereClause(
    _ newChild: GenericWhereClauseSyntax?) -> SubscriptDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.genericWhereClause)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.genericWhereClause)
    return SubscriptDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var accessor: AccessorBlockSyntax? {
    let child = data.cachedChild(at: Cursor.accessor)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? AccessorBlockSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `accessor` replaced.
  /// - param newChild: The new `accessor` to replace the node's
  ///                   current `accessor`, if present.
  public func withAccessor(
    _ newChild: AccessorBlockSyntax?) -> SubscriptDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.accessorBlock)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.accessor)
    return SubscriptDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `SubscriptDeclSyntax` nodes are equal to each other.
  public static func ==(lhs: SubscriptDeclSyntax, rhs: SubscriptDeclSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct AccessLevelModifierSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case name
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case leftParen
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case modifier
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case rightParen
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `AccessLevelModifierSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 4)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _name = raw[Cursor.identifierToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _nameTokenKind = _name.tokenKind else {
      fatalError("expected token child, got \(_name.kind)")
    }
    precondition([.identifier].contains(_nameTokenKind),
      "expected one of [.identifier] for 'name' " + 
      "in node of kind accessLevelModifier")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _leftParen = raw[Cursor.leftParenToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _leftParenTokenKind = _leftParen.tokenKind else {
      fatalError("expected token child, got \(_leftParen.kind)")
    }
    precondition([.leftParen].contains(_leftParenTokenKind),
      "expected one of [.leftParen] for 'leftParen' " + 
      "in node of kind accessLevelModifier")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _modifier = raw[Cursor.identifierToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _modifierTokenKind = _modifier.tokenKind else {
      fatalError("expected token child, got \(_modifier.kind)")
    }
    precondition([.identifier].contains(_modifierTokenKind),
      "expected one of [.identifier] for 'modifier' " + 
      "in node of kind accessLevelModifier")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _rightParen = raw[Cursor.rightParenToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _rightParenTokenKind = _rightParen.tokenKind else {
      fatalError("expected token child, got \(_rightParen.kind)")
    }
    precondition([.rightParen].contains(_rightParenTokenKind),
      "expected one of [.rightParen] for 'rightParen' " + 
      "in node of kind accessLevelModifier")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var name: TokenSyntax {
    let child = data.cachedChild(at: Cursor.name)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `name` replaced.
  /// - param newChild: The new `name` to replace the node's
  ///                   current `name`, if present.
  public func withName(
    _ newChild: TokenSyntax?) -> AccessLevelModifierSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.name)
    return AccessLevelModifierSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var leftParen: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.leftParen)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `leftParen` replaced.
  /// - param newChild: The new `leftParen` to replace the node's
  ///                   current `leftParen`, if present.
  public func withLeftParen(
    _ newChild: TokenSyntax?) -> AccessLevelModifierSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftParen)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.leftParen)
    return AccessLevelModifierSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var modifier: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.modifier)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `modifier` replaced.
  /// - param newChild: The new `modifier` to replace the node's
  ///                   current `modifier`, if present.
  public func withModifier(
    _ newChild: TokenSyntax?) -> AccessLevelModifierSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.modifier)
    return AccessLevelModifierSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var rightParen: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.rightParen)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `rightParen` replaced.
  /// - param newChild: The new `rightParen` to replace the node's
  ///                   current `rightParen`, if present.
  public func withRightParen(
    _ newChild: TokenSyntax?) -> AccessLevelModifierSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightParen)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.rightParen)
    return AccessLevelModifierSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `AccessLevelModifierSyntax` nodes are equal to each other.
  public static func ==(lhs: AccessLevelModifierSyntax, rhs: AccessLevelModifierSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct AccessPathComponentSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case name
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case trailingDot
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `AccessPathComponentSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 2)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _name = raw[Cursor.identifierToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _nameTokenKind = _name.tokenKind else {
      fatalError("expected token child, got \(_name.kind)")
    }
    precondition([.identifier].contains(_nameTokenKind),
      "expected one of [.identifier] for 'name' " + 
      "in node of kind accessPathComponent")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _trailingDot = raw[Cursor.periodToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _trailingDotTokenKind = _trailingDot.tokenKind else {
      fatalError("expected token child, got \(_trailingDot.kind)")
    }
    precondition([.period].contains(_trailingDotTokenKind),
      "expected one of [.period] for 'trailingDot' " + 
      "in node of kind accessPathComponent")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var name: TokenSyntax {
    let child = data.cachedChild(at: Cursor.name)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `name` replaced.
  /// - param newChild: The new `name` to replace the node's
  ///                   current `name`, if present.
  public func withName(
    _ newChild: TokenSyntax?) -> AccessPathComponentSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.name)
    return AccessPathComponentSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var trailingDot: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.trailingDot)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `trailingDot` replaced.
  /// - param newChild: The new `trailingDot` to replace the node's
  ///                   current `trailingDot`, if present.
  public func withTrailingDot(
    _ newChild: TokenSyntax?) -> AccessPathComponentSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.period)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.trailingDot)
    return AccessPathComponentSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `AccessPathComponentSyntax` nodes are equal to each other.
  public static func ==(lhs: AccessPathComponentSyntax, rhs: AccessPathComponentSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct ImportDeclSyntax: DeclSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case attributes
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case modifiers
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case importTok
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case importKind
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case path
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `ImportDeclSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 5)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _attributes = raw[Cursor.attributeList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_attributes.kind == .attributeList,
                 "expected child of kind .attributeList, " +
                 "got \(_attributes.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _modifiers = raw[Cursor.modifierList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_modifiers.kind == .modifierList,
                 "expected child of kind .modifierList, " +
                 "got \(_modifiers.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _importTok = raw[Cursor.importToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _importTokTokenKind = _importTok.tokenKind else {
      fatalError("expected token child, got \(_importTok.kind)")
    }
    precondition([.importKeyword].contains(_importTokTokenKind),
      "expected one of [.importKeyword] for 'importTok' " + 
      "in node of kind importDecl")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _importKind = raw[Cursor.token]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _importKindTokenKind = _importKind.tokenKind else {
      fatalError("expected token child, got \(_importKind.kind)")
    }
    precondition([.typealiasKeyword, .structKeyword, .classKeyword, .enumKeyword, .protocolKeyword, .varKeyword, .letKeyword, .funcKeyword].contains(_importKindTokenKind),
      "expected one of [.typealiasKeyword, .structKeyword, .classKeyword, .enumKeyword, .protocolKeyword, .varKeyword, .letKeyword, .funcKeyword] for 'importKind' " + 
      "in node of kind importDecl")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _path = raw[Cursor.accessPath]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_path.kind == .accessPath,
                 "expected child of kind .accessPath, " +
                 "got \(_path.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var attributes: AttributeListSyntax? {
    let child = data.cachedChild(at: Cursor.attributes)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? AttributeListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `Attribute` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: AttributeSyntax) -> ImportDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.attributes] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.attributeList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.attributes)
    return ImportDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `attributes` replaced.
  /// - param newChild: The new `attributes` to replace the node's
  ///                   current `attributes`, if present.
  public func withAttributes(
    _ newChild: AttributeListSyntax?) -> ImportDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.attributeList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.attributes)
    return ImportDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var modifiers: ModifierListSyntax? {
    let child = data.cachedChild(at: Cursor.modifiers)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? ModifierListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `Modifier` to the node's `modifiers`
  /// collection.
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  public func addModifier(_ element: DeclModifierSyntax) -> ImportDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.modifiers] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.modifierList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.modifiers)
    return ImportDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `modifiers` replaced.
  /// - param newChild: The new `modifiers` to replace the node's
  ///                   current `modifiers`, if present.
  public func withModifiers(
    _ newChild: ModifierListSyntax?) -> ImportDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.modifierList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.modifiers)
    return ImportDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var importTok: TokenSyntax {
    let child = data.cachedChild(at: Cursor.importTok)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `importTok` replaced.
  /// - param newChild: The new `importTok` to replace the node's
  ///                   current `importTok`, if present.
  public func withImportTok(
    _ newChild: TokenSyntax?) -> ImportDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.importKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.importTok)
    return ImportDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var importKind: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.importKind)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `importKind` replaced.
  /// - param newChild: The new `importKind` to replace the node's
  ///                   current `importKind`, if present.
  public func withImportKind(
    _ newChild: TokenSyntax?) -> ImportDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.typealiasKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.importKind)
    return ImportDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var path: AccessPathSyntax {
    let child = data.cachedChild(at: Cursor.path)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! AccessPathSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `AccessPathComponent` to the node's `path`
  /// collection.
  /// - param element: The new `AccessPathComponent` to add to the node's
  ///                  `path` collection.
  /// - returns: A copy of the receiver with the provided `AccessPathComponent`
  ///            appended to its `path` collection.
  public func addAccessPathComponent(_ element: AccessPathComponentSyntax) -> ImportDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.path] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.accessPath,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.path)
    return ImportDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `path` replaced.
  /// - param newChild: The new `path` to replace the node's
  ///                   current `path`, if present.
  public func withPath(
    _ newChild: AccessPathSyntax?) -> ImportDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.accessPath)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.path)
    return ImportDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `ImportDeclSyntax` nodes are equal to each other.
  public static func ==(lhs: ImportDeclSyntax, rhs: ImportDeclSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct AccessorParameterSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case leftParen
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case name
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case rightParen
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `AccessorParameterSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 3)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _leftParen = raw[Cursor.leftParenToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _leftParenTokenKind = _leftParen.tokenKind else {
      fatalError("expected token child, got \(_leftParen.kind)")
    }
    precondition([.leftParen].contains(_leftParenTokenKind),
      "expected one of [.leftParen] for 'leftParen' " + 
      "in node of kind accessorParameter")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _name = raw[Cursor.identifierToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _nameTokenKind = _name.tokenKind else {
      fatalError("expected token child, got \(_name.kind)")
    }
    precondition([.identifier].contains(_nameTokenKind),
      "expected one of [.identifier] for 'name' " + 
      "in node of kind accessorParameter")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _rightParen = raw[Cursor.rightParenToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _rightParenTokenKind = _rightParen.tokenKind else {
      fatalError("expected token child, got \(_rightParen.kind)")
    }
    precondition([.rightParen].contains(_rightParenTokenKind),
      "expected one of [.rightParen] for 'rightParen' " + 
      "in node of kind accessorParameter")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var leftParen: TokenSyntax {
    let child = data.cachedChild(at: Cursor.leftParen)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `leftParen` replaced.
  /// - param newChild: The new `leftParen` to replace the node's
  ///                   current `leftParen`, if present.
  public func withLeftParen(
    _ newChild: TokenSyntax?) -> AccessorParameterSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftParen)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.leftParen)
    return AccessorParameterSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var name: TokenSyntax {
    let child = data.cachedChild(at: Cursor.name)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `name` replaced.
  /// - param newChild: The new `name` to replace the node's
  ///                   current `name`, if present.
  public func withName(
    _ newChild: TokenSyntax?) -> AccessorParameterSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.name)
    return AccessorParameterSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var rightParen: TokenSyntax {
    let child = data.cachedChild(at: Cursor.rightParen)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `rightParen` replaced.
  /// - param newChild: The new `rightParen` to replace the node's
  ///                   current `rightParen`, if present.
  public func withRightParen(
    _ newChild: TokenSyntax?) -> AccessorParameterSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightParen)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.rightParen)
    return AccessorParameterSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `AccessorParameterSyntax` nodes are equal to each other.
  public static func ==(lhs: AccessorParameterSyntax, rhs: AccessorParameterSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct AccessorDeclSyntax: DeclSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case attributes
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case modifier
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case accessorKind
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case parameter
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case body
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `AccessorDeclSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 5)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _attributes = raw[Cursor.attributeList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_attributes.kind == .attributeList,
                 "expected child of kind .attributeList, " +
                 "got \(_attributes.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _modifier = raw[Cursor.declModifier]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_modifier.kind == .declModifier,
                 "expected child of kind .declModifier, " +
                 "got \(_modifier.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _accessorKind = raw[Cursor.token]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 113)
    guard let _accessorKindTokenKind = _accessorKind.tokenKind else {
      fatalError("expected token child, got \(_accessorKind.kind)")
    }
    precondition(["get", "set", "didSet", "willSet", "unsafeAddress", "addressWithOwner", "addressWithNativeOwner", "unsafeMutableAddress", "mutableAddressWithOwner", "mutableAddressWithNativeOwner", "_read", "_modify"].contains(_accessorKindTokenKind.text),
                 "expected one of '[get, set, didSet, willSet, unsafeAddress, addressWithOwner, addressWithNativeOwner, unsafeMutableAddress, mutableAddressWithOwner, mutableAddressWithNativeOwner, _read, _modify]', got " +
                 "'\(_accessorKindTokenKind.text)'")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _parameter = raw[Cursor.accessorParameter]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_parameter.kind == .accessorParameter,
                 "expected child of kind .accessorParameter, " +
                 "got \(_parameter.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _body = raw[Cursor.codeBlock]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_body.kind == .codeBlock,
                 "expected child of kind .codeBlock, " +
                 "got \(_body.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var attributes: AttributeListSyntax? {
    let child = data.cachedChild(at: Cursor.attributes)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? AttributeListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `Attribute` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: AttributeSyntax) -> AccessorDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.attributes] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.attributeList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.attributes)
    return AccessorDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `attributes` replaced.
  /// - param newChild: The new `attributes` to replace the node's
  ///                   current `attributes`, if present.
  public func withAttributes(
    _ newChild: AttributeListSyntax?) -> AccessorDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.attributeList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.attributes)
    return AccessorDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var modifier: DeclModifierSyntax? {
    let child = data.cachedChild(at: Cursor.modifier)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? DeclModifierSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `modifier` replaced.
  /// - param newChild: The new `modifier` to replace the node's
  ///                   current `modifier`, if present.
  public func withModifier(
    _ newChild: DeclModifierSyntax?) -> AccessorDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.declModifier)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.modifier)
    return AccessorDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var accessorKind: TokenSyntax {
    let child = data.cachedChild(at: Cursor.accessorKind)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `accessorKind` replaced.
  /// - param newChild: The new `accessorKind` to replace the node's
  ///                   current `accessorKind`, if present.
  public func withAccessorKind(
    _ newChild: TokenSyntax?) -> AccessorDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.unknown(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.accessorKind)
    return AccessorDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var parameter: AccessorParameterSyntax? {
    let child = data.cachedChild(at: Cursor.parameter)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? AccessorParameterSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `parameter` replaced.
  /// - param newChild: The new `parameter` to replace the node's
  ///                   current `parameter`, if present.
  public func withParameter(
    _ newChild: AccessorParameterSyntax?) -> AccessorDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.accessorParameter)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.parameter)
    return AccessorDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var body: CodeBlockSyntax? {
    let child = data.cachedChild(at: Cursor.body)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? CodeBlockSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `body` replaced.
  /// - param newChild: The new `body` to replace the node's
  ///                   current `body`, if present.
  public func withBody(
    _ newChild: CodeBlockSyntax?) -> AccessorDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.codeBlock)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.body)
    return AccessorDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `AccessorDeclSyntax` nodes are equal to each other.
  public static func ==(lhs: AccessorDeclSyntax, rhs: AccessorDeclSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct AccessorBlockSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case leftBrace
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case accessorListOrStmtList
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case rightBrace
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `AccessorBlockSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 3)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _leftBrace = raw[Cursor.leftBraceToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _leftBraceTokenKind = _leftBrace.tokenKind else {
      fatalError("expected token child, got \(_leftBrace.kind)")
    }
    precondition([.leftBrace].contains(_leftBraceTokenKind),
      "expected one of [.leftBrace] for 'leftBrace' " + 
      "in node of kind accessorBlock")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _accessorListOrStmtList = raw[Cursor.syntax]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_accessorListOrStmtList.kind == .syntax,
                 "expected child of kind .syntax, " +
                 "got \(_accessorListOrStmtList.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _rightBrace = raw[Cursor.rightBraceToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _rightBraceTokenKind = _rightBrace.tokenKind else {
      fatalError("expected token child, got \(_rightBrace.kind)")
    }
    precondition([.rightBrace].contains(_rightBraceTokenKind),
      "expected one of [.rightBrace] for 'rightBrace' " + 
      "in node of kind accessorBlock")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var leftBrace: TokenSyntax {
    let child = data.cachedChild(at: Cursor.leftBrace)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `leftBrace` replaced.
  /// - param newChild: The new `leftBrace` to replace the node's
  ///                   current `leftBrace`, if present.
  public func withLeftBrace(
    _ newChild: TokenSyntax?) -> AccessorBlockSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftBrace)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.leftBrace)
    return AccessorBlockSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var accessorListOrStmtList: Syntax {
    let child = data.cachedChild(at: Cursor.accessorListOrStmtList)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) 
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `accessorListOrStmtList` replaced.
  /// - param newChild: The new `accessorListOrStmtList` to replace the node's
  ///                   current `accessorListOrStmtList`, if present.
  public func withAccessorListOrStmtList(
    _ newChild: Syntax?) -> AccessorBlockSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.unknown)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.accessorListOrStmtList)
    return AccessorBlockSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var rightBrace: TokenSyntax {
    let child = data.cachedChild(at: Cursor.rightBrace)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `rightBrace` replaced.
  /// - param newChild: The new `rightBrace` to replace the node's
  ///                   current `rightBrace`, if present.
  public func withRightBrace(
    _ newChild: TokenSyntax?) -> AccessorBlockSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightBrace)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.rightBrace)
    return AccessorBlockSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `AccessorBlockSyntax` nodes are equal to each other.
  public static func ==(lhs: AccessorBlockSyntax, rhs: AccessorBlockSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct PatternBindingSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case pattern
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case typeAnnotation
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case initializer
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case accessor
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case trailingComma
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `PatternBindingSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 5)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _pattern = raw[Cursor.pattern]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_pattern.kind == .pattern,
                 "expected child of kind .pattern, " +
                 "got \(_pattern.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _typeAnnotation = raw[Cursor.typeAnnotation]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_typeAnnotation.kind == .typeAnnotation,
                 "expected child of kind .typeAnnotation, " +
                 "got \(_typeAnnotation.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _initializer = raw[Cursor.initializerClause]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_initializer.kind == .initializerClause,
                 "expected child of kind .initializerClause, " +
                 "got \(_initializer.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _accessor = raw[Cursor.accessorBlock]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_accessor.kind == .accessorBlock,
                 "expected child of kind .accessorBlock, " +
                 "got \(_accessor.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _trailingComma = raw[Cursor.commaToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _trailingCommaTokenKind = _trailingComma.tokenKind else {
      fatalError("expected token child, got \(_trailingComma.kind)")
    }
    precondition([.comma].contains(_trailingCommaTokenKind),
      "expected one of [.comma] for 'trailingComma' " + 
      "in node of kind patternBinding")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var pattern: PatternSyntax {
    let child = data.cachedChild(at: Cursor.pattern)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! PatternSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `pattern` replaced.
  /// - param newChild: The new `pattern` to replace the node's
  ///                   current `pattern`, if present.
  public func withPattern(
    _ newChild: PatternSyntax?) -> PatternBindingSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.pattern)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.pattern)
    return PatternBindingSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var typeAnnotation: TypeAnnotationSyntax? {
    let child = data.cachedChild(at: Cursor.typeAnnotation)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TypeAnnotationSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `typeAnnotation` replaced.
  /// - param newChild: The new `typeAnnotation` to replace the node's
  ///                   current `typeAnnotation`, if present.
  public func withTypeAnnotation(
    _ newChild: TypeAnnotationSyntax?) -> PatternBindingSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.typeAnnotation)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.typeAnnotation)
    return PatternBindingSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var initializer: InitializerClauseSyntax? {
    let child = data.cachedChild(at: Cursor.initializer)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? InitializerClauseSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `initializer` replaced.
  /// - param newChild: The new `initializer` to replace the node's
  ///                   current `initializer`, if present.
  public func withInitializer(
    _ newChild: InitializerClauseSyntax?) -> PatternBindingSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.initializerClause)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.initializer)
    return PatternBindingSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var accessor: AccessorBlockSyntax? {
    let child = data.cachedChild(at: Cursor.accessor)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? AccessorBlockSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `accessor` replaced.
  /// - param newChild: The new `accessor` to replace the node's
  ///                   current `accessor`, if present.
  public func withAccessor(
    _ newChild: AccessorBlockSyntax?) -> PatternBindingSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.accessorBlock)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.accessor)
    return PatternBindingSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var trailingComma: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.trailingComma)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `trailingComma` replaced.
  /// - param newChild: The new `trailingComma` to replace the node's
  ///                   current `trailingComma`, if present.
  public func withTrailingComma(
    _ newChild: TokenSyntax?) -> PatternBindingSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.comma)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.trailingComma)
    return PatternBindingSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `PatternBindingSyntax` nodes are equal to each other.
  public static func ==(lhs: PatternBindingSyntax, rhs: PatternBindingSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct VariableDeclSyntax: DeclSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case attributes
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case modifiers
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case letOrVarKeyword
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case bindings
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `VariableDeclSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 4)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _attributes = raw[Cursor.attributeList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_attributes.kind == .attributeList,
                 "expected child of kind .attributeList, " +
                 "got \(_attributes.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _modifiers = raw[Cursor.modifierList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_modifiers.kind == .modifierList,
                 "expected child of kind .modifierList, " +
                 "got \(_modifiers.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _letOrVarKeyword = raw[Cursor.token]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _letOrVarKeywordTokenKind = _letOrVarKeyword.tokenKind else {
      fatalError("expected token child, got \(_letOrVarKeyword.kind)")
    }
    precondition([.letKeyword, .varKeyword].contains(_letOrVarKeywordTokenKind),
      "expected one of [.letKeyword, .varKeyword] for 'letOrVarKeyword' " + 
      "in node of kind variableDecl")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _bindings = raw[Cursor.patternBindingList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_bindings.kind == .patternBindingList,
                 "expected child of kind .patternBindingList, " +
                 "got \(_bindings.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var attributes: AttributeListSyntax? {
    let child = data.cachedChild(at: Cursor.attributes)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? AttributeListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `Attribute` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: AttributeSyntax) -> VariableDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.attributes] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.attributeList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.attributes)
    return VariableDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `attributes` replaced.
  /// - param newChild: The new `attributes` to replace the node's
  ///                   current `attributes`, if present.
  public func withAttributes(
    _ newChild: AttributeListSyntax?) -> VariableDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.attributeList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.attributes)
    return VariableDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var modifiers: ModifierListSyntax? {
    let child = data.cachedChild(at: Cursor.modifiers)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? ModifierListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `Modifier` to the node's `modifiers`
  /// collection.
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  public func addModifier(_ element: DeclModifierSyntax) -> VariableDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.modifiers] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.modifierList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.modifiers)
    return VariableDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `modifiers` replaced.
  /// - param newChild: The new `modifiers` to replace the node's
  ///                   current `modifiers`, if present.
  public func withModifiers(
    _ newChild: ModifierListSyntax?) -> VariableDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.modifierList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.modifiers)
    return VariableDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var letOrVarKeyword: TokenSyntax {
    let child = data.cachedChild(at: Cursor.letOrVarKeyword)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `letOrVarKeyword` replaced.
  /// - param newChild: The new `letOrVarKeyword` to replace the node's
  ///                   current `letOrVarKeyword`, if present.
  public func withLetOrVarKeyword(
    _ newChild: TokenSyntax?) -> VariableDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.letKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.letOrVarKeyword)
    return VariableDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var bindings: PatternBindingListSyntax {
    let child = data.cachedChild(at: Cursor.bindings)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! PatternBindingListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `PatternBinding` to the node's `bindings`
  /// collection.
  /// - param element: The new `PatternBinding` to add to the node's
  ///                  `bindings` collection.
  /// - returns: A copy of the receiver with the provided `PatternBinding`
  ///            appended to its `bindings` collection.
  public func addPatternBinding(_ element: PatternBindingSyntax) -> VariableDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.bindings] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.patternBindingList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.bindings)
    return VariableDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `bindings` replaced.
  /// - param newChild: The new `bindings` to replace the node's
  ///                   current `bindings`, if present.
  public func withBindings(
    _ newChild: PatternBindingListSyntax?) -> VariableDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.patternBindingList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.bindings)
    return VariableDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `VariableDeclSyntax` nodes are equal to each other.
  public static func ==(lhs: VariableDeclSyntax, rhs: VariableDeclSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 70)
/// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 70)
/// An element of an enum case, containing the name of the case and,          optionally, either associated values or an assignment to a raw value.
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 70)
/// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct EnumCaseElementSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case identifier
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case associatedValue
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case rawValue
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case trailingComma
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `EnumCaseElementSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 4)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _identifier = raw[Cursor.identifierToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _identifierTokenKind = _identifier.tokenKind else {
      fatalError("expected token child, got \(_identifier.kind)")
    }
    precondition([.identifier].contains(_identifierTokenKind),
      "expected one of [.identifier] for 'identifier' " + 
      "in node of kind enumCaseElement")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _associatedValue = raw[Cursor.parameterClause]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_associatedValue.kind == .parameterClause,
                 "expected child of kind .parameterClause, " +
                 "got \(_associatedValue.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _rawValue = raw[Cursor.initializerClause]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_rawValue.kind == .initializerClause,
                 "expected child of kind .initializerClause, " +
                 "got \(_rawValue.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _trailingComma = raw[Cursor.commaToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _trailingCommaTokenKind = _trailingComma.tokenKind else {
      fatalError("expected token child, got \(_trailingComma.kind)")
    }
    precondition([.comma].contains(_trailingCommaTokenKind),
      "expected one of [.comma] for 'trailingComma' " + 
      "in node of kind enumCaseElement")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// The name of this case.
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var identifier: TokenSyntax {
    let child = data.cachedChild(at: Cursor.identifier)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `identifier` replaced.
  /// - param newChild: The new `identifier` to replace the node's
  ///                   current `identifier`, if present.
  public func withIdentifier(
    _ newChild: TokenSyntax?) -> EnumCaseElementSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.identifier)
    return EnumCaseElementSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// The set of associated values of the case.
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var associatedValue: ParameterClauseSyntax? {
    let child = data.cachedChild(at: Cursor.associatedValue)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? ParameterClauseSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `associatedValue` replaced.
  /// - param newChild: The new `associatedValue` to replace the node's
  ///                   current `associatedValue`, if present.
  public func withAssociatedValue(
    _ newChild: ParameterClauseSyntax?) -> EnumCaseElementSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.parameterClause)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.associatedValue)
    return EnumCaseElementSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// The raw value of this enum element, if present.
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var rawValue: InitializerClauseSyntax? {
    let child = data.cachedChild(at: Cursor.rawValue)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? InitializerClauseSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `rawValue` replaced.
  /// - param newChild: The new `rawValue` to replace the node's
  ///                   current `rawValue`, if present.
  public func withRawValue(
    _ newChild: InitializerClauseSyntax?) -> EnumCaseElementSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.initializerClause)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.rawValue)
    return EnumCaseElementSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// The trailing comma of this element, if the case has                    multiple elements.
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var trailingComma: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.trailingComma)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `trailingComma` replaced.
  /// - param newChild: The new `trailingComma` to replace the node's
  ///                   current `trailingComma`, if present.
  public func withTrailingComma(
    _ newChild: TokenSyntax?) -> EnumCaseElementSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.comma)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.trailingComma)
    return EnumCaseElementSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `EnumCaseElementSyntax` nodes are equal to each other.
  public static func ==(lhs: EnumCaseElementSyntax, rhs: EnumCaseElementSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 70)
/// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 70)
/// A `case` declaration of a Swift `enum`. It can have 1 or more          `EnumCaseElement`s inside, each declaring a different case of the
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 70)
/// enum.
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 70)
/// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct EnumCaseDeclSyntax: DeclSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case attributes
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case modifiers
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case caseKeyword
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case elements
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `EnumCaseDeclSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 4)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _attributes = raw[Cursor.attributeList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_attributes.kind == .attributeList,
                 "expected child of kind .attributeList, " +
                 "got \(_attributes.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _modifiers = raw[Cursor.modifierList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_modifiers.kind == .modifierList,
                 "expected child of kind .modifierList, " +
                 "got \(_modifiers.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _caseKeyword = raw[Cursor.caseToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _caseKeywordTokenKind = _caseKeyword.tokenKind else {
      fatalError("expected token child, got \(_caseKeyword.kind)")
    }
    precondition([.caseKeyword].contains(_caseKeywordTokenKind),
      "expected one of [.caseKeyword] for 'caseKeyword' " + 
      "in node of kind enumCaseDecl")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _elements = raw[Cursor.enumCaseElementList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_elements.kind == .enumCaseElementList,
                 "expected child of kind .enumCaseElementList, " +
                 "got \(_elements.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// The attributes applied to the case declaration.
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var attributes: AttributeListSyntax? {
    let child = data.cachedChild(at: Cursor.attributes)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? AttributeListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `Attribute` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: AttributeSyntax) -> EnumCaseDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.attributes] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.attributeList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.attributes)
    return EnumCaseDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `attributes` replaced.
  /// - param newChild: The new `attributes` to replace the node's
  ///                   current `attributes`, if present.
  public func withAttributes(
    _ newChild: AttributeListSyntax?) -> EnumCaseDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.attributeList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.attributes)
    return EnumCaseDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// The declaration modifiers applied to the case declaration.
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var modifiers: ModifierListSyntax? {
    let child = data.cachedChild(at: Cursor.modifiers)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? ModifierListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `Modifier` to the node's `modifiers`
  /// collection.
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  public func addModifier(_ element: DeclModifierSyntax) -> EnumCaseDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.modifiers] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.modifierList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.modifiers)
    return EnumCaseDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `modifiers` replaced.
  /// - param newChild: The new `modifiers` to replace the node's
  ///                   current `modifiers`, if present.
  public func withModifiers(
    _ newChild: ModifierListSyntax?) -> EnumCaseDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.modifierList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.modifiers)
    return EnumCaseDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// The `case` keyword for this case.
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var caseKeyword: TokenSyntax {
    let child = data.cachedChild(at: Cursor.caseKeyword)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `caseKeyword` replaced.
  /// - param newChild: The new `caseKeyword` to replace the node's
  ///                   current `caseKeyword`, if present.
  public func withCaseKeyword(
    _ newChild: TokenSyntax?) -> EnumCaseDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.caseKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.caseKeyword)
    return EnumCaseDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// The elements this case declares.
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var elements: EnumCaseElementListSyntax {
    let child = data.cachedChild(at: Cursor.elements)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! EnumCaseElementListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `EnumCaseElement` to the node's `elements`
  /// collection.
  /// - param element: The new `EnumCaseElement` to add to the node's
  ///                  `elements` collection.
  /// - returns: A copy of the receiver with the provided `EnumCaseElement`
  ///            appended to its `elements` collection.
  public func addEnumCaseElement(_ element: EnumCaseElementSyntax) -> EnumCaseDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.elements] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.enumCaseElementList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.elements)
    return EnumCaseDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `elements` replaced.
  /// - param newChild: The new `elements` to replace the node's
  ///                   current `elements`, if present.
  public func withElements(
    _ newChild: EnumCaseElementListSyntax?) -> EnumCaseDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.enumCaseElementList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.elements)
    return EnumCaseDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `EnumCaseDeclSyntax` nodes are equal to each other.
  public static func ==(lhs: EnumCaseDeclSyntax, rhs: EnumCaseDeclSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 70)
/// A Swift `enum` declaration.
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct EnumDeclSyntax: DeclSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case attributes
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case modifiers
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case enumKeyword
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case identifier
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case genericParameters
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case inheritanceClause
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case genericWhereClause
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case members
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `EnumDeclSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 8)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _attributes = raw[Cursor.attributeList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_attributes.kind == .attributeList,
                 "expected child of kind .attributeList, " +
                 "got \(_attributes.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _modifiers = raw[Cursor.modifierList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_modifiers.kind == .modifierList,
                 "expected child of kind .modifierList, " +
                 "got \(_modifiers.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _enumKeyword = raw[Cursor.enumToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _enumKeywordTokenKind = _enumKeyword.tokenKind else {
      fatalError("expected token child, got \(_enumKeyword.kind)")
    }
    precondition([.enumKeyword].contains(_enumKeywordTokenKind),
      "expected one of [.enumKeyword] for 'enumKeyword' " + 
      "in node of kind enumDecl")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _identifier = raw[Cursor.identifierToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _identifierTokenKind = _identifier.tokenKind else {
      fatalError("expected token child, got \(_identifier.kind)")
    }
    precondition([.identifier].contains(_identifierTokenKind),
      "expected one of [.identifier] for 'identifier' " + 
      "in node of kind enumDecl")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _genericParameters = raw[Cursor.genericParameterClause]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_genericParameters.kind == .genericParameterClause,
                 "expected child of kind .genericParameterClause, " +
                 "got \(_genericParameters.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _inheritanceClause = raw[Cursor.typeInheritanceClause]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_inheritanceClause.kind == .typeInheritanceClause,
                 "expected child of kind .typeInheritanceClause, " +
                 "got \(_inheritanceClause.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _genericWhereClause = raw[Cursor.genericWhereClause]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_genericWhereClause.kind == .genericWhereClause,
                 "expected child of kind .genericWhereClause, " +
                 "got \(_genericWhereClause.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _members = raw[Cursor.memberDeclBlock]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_members.kind == .memberDeclBlock,
                 "expected child of kind .memberDeclBlock, " +
                 "got \(_members.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// The attributes applied to the enum declaration.
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var attributes: AttributeListSyntax? {
    let child = data.cachedChild(at: Cursor.attributes)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? AttributeListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `Attribute` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: AttributeSyntax) -> EnumDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.attributes] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.attributeList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.attributes)
    return EnumDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `attributes` replaced.
  /// - param newChild: The new `attributes` to replace the node's
  ///                   current `attributes`, if present.
  public func withAttributes(
    _ newChild: AttributeListSyntax?) -> EnumDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.attributeList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.attributes)
    return EnumDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// The declaration modifiers applied to the enum declaration.
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var modifiers: ModifierListSyntax? {
    let child = data.cachedChild(at: Cursor.modifiers)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? ModifierListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `Modifier` to the node's `modifiers`
  /// collection.
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  public func addModifier(_ element: DeclModifierSyntax) -> EnumDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.modifiers] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.modifierList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.modifiers)
    return EnumDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `modifiers` replaced.
  /// - param newChild: The new `modifiers` to replace the node's
  ///                   current `modifiers`, if present.
  public func withModifiers(
    _ newChild: ModifierListSyntax?) -> EnumDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.modifierList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.modifiers)
    return EnumDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// The `enum` keyword for this declaration.
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var enumKeyword: TokenSyntax {
    let child = data.cachedChild(at: Cursor.enumKeyword)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `enumKeyword` replaced.
  /// - param newChild: The new `enumKeyword` to replace the node's
  ///                   current `enumKeyword`, if present.
  public func withEnumKeyword(
    _ newChild: TokenSyntax?) -> EnumDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.enumKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.enumKeyword)
    return EnumDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// The name of this enum.
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var identifier: TokenSyntax {
    let child = data.cachedChild(at: Cursor.identifier)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `identifier` replaced.
  /// - param newChild: The new `identifier` to replace the node's
  ///                   current `identifier`, if present.
  public func withIdentifier(
    _ newChild: TokenSyntax?) -> EnumDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.identifier)
    return EnumDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// The generic parameters, if any, for this enum.
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var genericParameters: GenericParameterClauseSyntax? {
    let child = data.cachedChild(at: Cursor.genericParameters)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? GenericParameterClauseSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `genericParameters` replaced.
  /// - param newChild: The new `genericParameters` to replace the node's
  ///                   current `genericParameters`, if present.
  public func withGenericParameters(
    _ newChild: GenericParameterClauseSyntax?) -> EnumDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.genericParameterClause)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.genericParameters)
    return EnumDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// The inheritance clause describing conformances or raw                    values for this enum.
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var inheritanceClause: TypeInheritanceClauseSyntax? {
    let child = data.cachedChild(at: Cursor.inheritanceClause)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TypeInheritanceClauseSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `inheritanceClause` replaced.
  /// - param newChild: The new `inheritanceClause` to replace the node's
  ///                   current `inheritanceClause`, if present.
  public func withInheritanceClause(
    _ newChild: TypeInheritanceClauseSyntax?) -> EnumDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.typeInheritanceClause)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.inheritanceClause)
    return EnumDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// The `where` clause that applies to the generic parameters of                    this enum.
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var genericWhereClause: GenericWhereClauseSyntax? {
    let child = data.cachedChild(at: Cursor.genericWhereClause)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? GenericWhereClauseSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `genericWhereClause` replaced.
  /// - param newChild: The new `genericWhereClause` to replace the node's
  ///                   current `genericWhereClause`, if present.
  public func withGenericWhereClause(
    _ newChild: GenericWhereClauseSyntax?) -> EnumDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.genericWhereClause)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.genericWhereClause)
    return EnumDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// The cases and other members of this enum.
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var members: MemberDeclBlockSyntax {
    let child = data.cachedChild(at: Cursor.members)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! MemberDeclBlockSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `members` replaced.
  /// - param newChild: The new `members` to replace the node's
  ///                   current `members`, if present.
  public func withMembers(
    _ newChild: MemberDeclBlockSyntax?) -> EnumDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.memberDeclBlock)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.members)
    return EnumDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `EnumDeclSyntax` nodes are equal to each other.
  public static func ==(lhs: EnumDeclSyntax, rhs: EnumDeclSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 70)
/// A Swift `operator` declaration.
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct OperatorDeclSyntax: DeclSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case attributes
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case modifiers
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case operatorKeyword
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case identifier
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case infixOperatorGroup
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `OperatorDeclSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 5)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _attributes = raw[Cursor.attributeList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_attributes.kind == .attributeList,
                 "expected child of kind .attributeList, " +
                 "got \(_attributes.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _modifiers = raw[Cursor.modifierList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_modifiers.kind == .modifierList,
                 "expected child of kind .modifierList, " +
                 "got \(_modifiers.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _operatorKeyword = raw[Cursor.operatorToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _operatorKeywordTokenKind = _operatorKeyword.tokenKind else {
      fatalError("expected token child, got \(_operatorKeyword.kind)")
    }
    precondition([.operatorKeyword].contains(_operatorKeywordTokenKind),
      "expected one of [.operatorKeyword] for 'operatorKeyword' " + 
      "in node of kind operatorDecl")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _identifier = raw[Cursor.token]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _identifierTokenKind = _identifier.tokenKind else {
      fatalError("expected token child, got \(_identifier.kind)")
    }
    precondition([.unspacedBinaryOperator, .spacedBinaryOperator, .prefixOperator, .postfixOperator].contains(_identifierTokenKind),
      "expected one of [.unspacedBinaryOperator, .spacedBinaryOperator, .prefixOperator, .postfixOperator] for 'identifier' " + 
      "in node of kind operatorDecl")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _infixOperatorGroup = raw[Cursor.infixOperatorGroup]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_infixOperatorGroup.kind == .infixOperatorGroup,
                 "expected child of kind .infixOperatorGroup, " +
                 "got \(_infixOperatorGroup.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// The attributes applied to the 'operator' declaration.
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var attributes: AttributeListSyntax? {
    let child = data.cachedChild(at: Cursor.attributes)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? AttributeListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `Attribute` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: AttributeSyntax) -> OperatorDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.attributes] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.attributeList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.attributes)
    return OperatorDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `attributes` replaced.
  /// - param newChild: The new `attributes` to replace the node's
  ///                   current `attributes`, if present.
  public func withAttributes(
    _ newChild: AttributeListSyntax?) -> OperatorDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.attributeList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.attributes)
    return OperatorDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// The declaration modifiers applied to the 'operator'
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// declaration.
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var modifiers: ModifierListSyntax? {
    let child = data.cachedChild(at: Cursor.modifiers)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? ModifierListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `Modifier` to the node's `modifiers`
  /// collection.
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  public func addModifier(_ element: DeclModifierSyntax) -> OperatorDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.modifiers] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.modifierList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.modifiers)
    return OperatorDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `modifiers` replaced.
  /// - param newChild: The new `modifiers` to replace the node's
  ///                   current `modifiers`, if present.
  public func withModifiers(
    _ newChild: ModifierListSyntax?) -> OperatorDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.modifierList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.modifiers)
    return OperatorDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var operatorKeyword: TokenSyntax {
    let child = data.cachedChild(at: Cursor.operatorKeyword)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `operatorKeyword` replaced.
  /// - param newChild: The new `operatorKeyword` to replace the node's
  ///                   current `operatorKeyword`, if present.
  public func withOperatorKeyword(
    _ newChild: TokenSyntax?) -> OperatorDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.operatorKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.operatorKeyword)
    return OperatorDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var identifier: TokenSyntax {
    let child = data.cachedChild(at: Cursor.identifier)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `identifier` replaced.
  /// - param newChild: The new `identifier` to replace the node's
  ///                   current `identifier`, if present.
  public func withIdentifier(
    _ newChild: TokenSyntax?) -> OperatorDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.unspacedBinaryOperator(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.identifier)
    return OperatorDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// Optionally specify a precedence group
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var infixOperatorGroup: InfixOperatorGroupSyntax? {
    let child = data.cachedChild(at: Cursor.infixOperatorGroup)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? InfixOperatorGroupSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `infixOperatorGroup` replaced.
  /// - param newChild: The new `infixOperatorGroup` to replace the node's
  ///                   current `infixOperatorGroup`, if present.
  public func withInfixOperatorGroup(
    _ newChild: InfixOperatorGroupSyntax?) -> OperatorDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.infixOperatorGroup)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.infixOperatorGroup)
    return OperatorDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `OperatorDeclSyntax` nodes are equal to each other.
  public static func ==(lhs: OperatorDeclSyntax, rhs: OperatorDeclSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 70)
/// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 70)
/// A clause to specify precedence group in infix operator declaration.
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 70)
/// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct InfixOperatorGroupSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case colon
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case precedenceGroupName
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `InfixOperatorGroupSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 2)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _colon = raw[Cursor.colonToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _colonTokenKind = _colon.tokenKind else {
      fatalError("expected token child, got \(_colon.kind)")
    }
    precondition([.colon].contains(_colonTokenKind),
      "expected one of [.colon] for 'colon' " + 
      "in node of kind infixOperatorGroup")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _precedenceGroupName = raw[Cursor.identifierToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _precedenceGroupNameTokenKind = _precedenceGroupName.tokenKind else {
      fatalError("expected token child, got \(_precedenceGroupName.kind)")
    }
    precondition([.identifier].contains(_precedenceGroupNameTokenKind),
      "expected one of [.identifier] for 'precedenceGroupName' " + 
      "in node of kind infixOperatorGroup")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var colon: TokenSyntax {
    let child = data.cachedChild(at: Cursor.colon)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `colon` replaced.
  /// - param newChild: The new `colon` to replace the node's
  ///                   current `colon`, if present.
  public func withColon(
    _ newChild: TokenSyntax?) -> InfixOperatorGroupSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.colon)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.colon)
    return InfixOperatorGroupSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// The name of the precedence group for the operator
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var precedenceGroupName: TokenSyntax {
    let child = data.cachedChild(at: Cursor.precedenceGroupName)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `precedenceGroupName` replaced.
  /// - param newChild: The new `precedenceGroupName` to replace the node's
  ///                   current `precedenceGroupName`, if present.
  public func withPrecedenceGroupName(
    _ newChild: TokenSyntax?) -> InfixOperatorGroupSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.precedenceGroupName)
    return InfixOperatorGroupSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `InfixOperatorGroupSyntax` nodes are equal to each other.
  public static func ==(lhs: InfixOperatorGroupSyntax, rhs: InfixOperatorGroupSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 70)
/// A Swift `precedencegroup` declaration.
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct PrecedenceGroupDeclSyntax: DeclSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case attributes
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case modifiers
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case precedencegroupKeyword
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case identifier
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case leftBrace
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case groupAttributes
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case rightBrace
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `PrecedenceGroupDeclSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 7)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _attributes = raw[Cursor.attributeList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_attributes.kind == .attributeList,
                 "expected child of kind .attributeList, " +
                 "got \(_attributes.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _modifiers = raw[Cursor.modifierList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_modifiers.kind == .modifierList,
                 "expected child of kind .modifierList, " +
                 "got \(_modifiers.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _precedencegroupKeyword = raw[Cursor.precedencegroupToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _precedencegroupKeywordTokenKind = _precedencegroupKeyword.tokenKind else {
      fatalError("expected token child, got \(_precedencegroupKeyword.kind)")
    }
    precondition([.precedencegroupKeyword].contains(_precedencegroupKeywordTokenKind),
      "expected one of [.precedencegroupKeyword] for 'precedencegroupKeyword' " + 
      "in node of kind precedenceGroupDecl")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _identifier = raw[Cursor.identifierToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _identifierTokenKind = _identifier.tokenKind else {
      fatalError("expected token child, got \(_identifier.kind)")
    }
    precondition([.identifier].contains(_identifierTokenKind),
      "expected one of [.identifier] for 'identifier' " + 
      "in node of kind precedenceGroupDecl")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _leftBrace = raw[Cursor.leftBraceToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _leftBraceTokenKind = _leftBrace.tokenKind else {
      fatalError("expected token child, got \(_leftBrace.kind)")
    }
    precondition([.leftBrace].contains(_leftBraceTokenKind),
      "expected one of [.leftBrace] for 'leftBrace' " + 
      "in node of kind precedenceGroupDecl")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _groupAttributes = raw[Cursor.precedenceGroupAttributeList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_groupAttributes.kind == .precedenceGroupAttributeList,
                 "expected child of kind .precedenceGroupAttributeList, " +
                 "got \(_groupAttributes.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _rightBrace = raw[Cursor.rightBraceToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _rightBraceTokenKind = _rightBrace.tokenKind else {
      fatalError("expected token child, got \(_rightBrace.kind)")
    }
    precondition([.rightBrace].contains(_rightBraceTokenKind),
      "expected one of [.rightBrace] for 'rightBrace' " + 
      "in node of kind precedenceGroupDecl")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// The attributes applied to the 'precedencegroup' declaration.
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var attributes: AttributeListSyntax? {
    let child = data.cachedChild(at: Cursor.attributes)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? AttributeListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `Attribute` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: AttributeSyntax) -> PrecedenceGroupDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.attributes] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.attributeList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.attributes)
    return PrecedenceGroupDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `attributes` replaced.
  /// - param newChild: The new `attributes` to replace the node's
  ///                   current `attributes`, if present.
  public func withAttributes(
    _ newChild: AttributeListSyntax?) -> PrecedenceGroupDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.attributeList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.attributes)
    return PrecedenceGroupDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// The declaration modifiers applied to the 'precedencegroup'
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// declaration.
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var modifiers: ModifierListSyntax? {
    let child = data.cachedChild(at: Cursor.modifiers)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? ModifierListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `Modifier` to the node's `modifiers`
  /// collection.
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  public func addModifier(_ element: DeclModifierSyntax) -> PrecedenceGroupDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.modifiers] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.modifierList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.modifiers)
    return PrecedenceGroupDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `modifiers` replaced.
  /// - param newChild: The new `modifiers` to replace the node's
  ///                   current `modifiers`, if present.
  public func withModifiers(
    _ newChild: ModifierListSyntax?) -> PrecedenceGroupDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.modifierList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.modifiers)
    return PrecedenceGroupDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var precedencegroupKeyword: TokenSyntax {
    let child = data.cachedChild(at: Cursor.precedencegroupKeyword)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `precedencegroupKeyword` replaced.
  /// - param newChild: The new `precedencegroupKeyword` to replace the node's
  ///                   current `precedencegroupKeyword`, if present.
  public func withPrecedencegroupKeyword(
    _ newChild: TokenSyntax?) -> PrecedenceGroupDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.precedencegroupKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.precedencegroupKeyword)
    return PrecedenceGroupDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// The name of this precedence group.
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var identifier: TokenSyntax {
    let child = data.cachedChild(at: Cursor.identifier)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `identifier` replaced.
  /// - param newChild: The new `identifier` to replace the node's
  ///                   current `identifier`, if present.
  public func withIdentifier(
    _ newChild: TokenSyntax?) -> PrecedenceGroupDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.identifier)
    return PrecedenceGroupDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var leftBrace: TokenSyntax {
    let child = data.cachedChild(at: Cursor.leftBrace)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `leftBrace` replaced.
  /// - param newChild: The new `leftBrace` to replace the node's
  ///                   current `leftBrace`, if present.
  public func withLeftBrace(
    _ newChild: TokenSyntax?) -> PrecedenceGroupDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftBrace)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.leftBrace)
    return PrecedenceGroupDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// The characteristics of this precedence group.
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var groupAttributes: PrecedenceGroupAttributeListSyntax {
    let child = data.cachedChild(at: Cursor.groupAttributes)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! PrecedenceGroupAttributeListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `Syntax` to the node's `groupAttributes`
  /// collection.
  /// - param element: The new `Syntax` to add to the node's
  ///                  `groupAttributes` collection.
  /// - returns: A copy of the receiver with the provided `Syntax`
  ///            appended to its `groupAttributes` collection.
  public func addSyntax(_ element: Syntax) -> PrecedenceGroupDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.groupAttributes] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.precedenceGroupAttributeList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.groupAttributes)
    return PrecedenceGroupDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `groupAttributes` replaced.
  /// - param newChild: The new `groupAttributes` to replace the node's
  ///                   current `groupAttributes`, if present.
  public func withGroupAttributes(
    _ newChild: PrecedenceGroupAttributeListSyntax?) -> PrecedenceGroupDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.precedenceGroupAttributeList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.groupAttributes)
    return PrecedenceGroupDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var rightBrace: TokenSyntax {
    let child = data.cachedChild(at: Cursor.rightBrace)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `rightBrace` replaced.
  /// - param newChild: The new `rightBrace` to replace the node's
  ///                   current `rightBrace`, if present.
  public func withRightBrace(
    _ newChild: TokenSyntax?) -> PrecedenceGroupDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightBrace)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.rightBrace)
    return PrecedenceGroupDeclSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `PrecedenceGroupDeclSyntax` nodes are equal to each other.
  public static func ==(lhs: PrecedenceGroupDeclSyntax, rhs: PrecedenceGroupDeclSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 70)
/// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 70)
/// Specify the new precedence group's relation to existing precedence
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 70)
/// groups.
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 70)
/// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct PrecedenceGroupRelationSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case higherThanOrLowerThan
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case colon
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case otherNames
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `PrecedenceGroupRelationSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 3)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _higherThanOrLowerThan = raw[Cursor.identifierToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _higherThanOrLowerThanTokenKind = _higherThanOrLowerThan.tokenKind else {
      fatalError("expected token child, got \(_higherThanOrLowerThan.kind)")
    }
    precondition([.identifier].contains(_higherThanOrLowerThanTokenKind),
      "expected one of [.identifier] for 'higherThanOrLowerThan' " + 
      "in node of kind precedenceGroupRelation")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _colon = raw[Cursor.colonToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _colonTokenKind = _colon.tokenKind else {
      fatalError("expected token child, got \(_colon.kind)")
    }
    precondition([.colon].contains(_colonTokenKind),
      "expected one of [.colon] for 'colon' " + 
      "in node of kind precedenceGroupRelation")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _otherNames = raw[Cursor.precedenceGroupNameList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_otherNames.kind == .precedenceGroupNameList,
                 "expected child of kind .precedenceGroupNameList, " +
                 "got \(_otherNames.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// The relation to specified other precedence groups.
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var higherThanOrLowerThan: TokenSyntax {
    let child = data.cachedChild(at: Cursor.higherThanOrLowerThan)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `higherThanOrLowerThan` replaced.
  /// - param newChild: The new `higherThanOrLowerThan` to replace the node's
  ///                   current `higherThanOrLowerThan`, if present.
  public func withHigherThanOrLowerThan(
    _ newChild: TokenSyntax?) -> PrecedenceGroupRelationSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.higherThanOrLowerThan)
    return PrecedenceGroupRelationSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var colon: TokenSyntax {
    let child = data.cachedChild(at: Cursor.colon)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `colon` replaced.
  /// - param newChild: The new `colon` to replace the node's
  ///                   current `colon`, if present.
  public func withColon(
    _ newChild: TokenSyntax?) -> PrecedenceGroupRelationSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.colon)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.colon)
    return PrecedenceGroupRelationSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// The name of other precedence group to which this precedence
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// group relates.
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var otherNames: PrecedenceGroupNameListSyntax {
    let child = data.cachedChild(at: Cursor.otherNames)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! PrecedenceGroupNameListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `PrecedenceGroupNameElement` to the node's `otherNames`
  /// collection.
  /// - param element: The new `PrecedenceGroupNameElement` to add to the node's
  ///                  `otherNames` collection.
  /// - returns: A copy of the receiver with the provided `PrecedenceGroupNameElement`
  ///            appended to its `otherNames` collection.
  public func addPrecedenceGroupNameElement(_ element: PrecedenceGroupNameElementSyntax) -> PrecedenceGroupRelationSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.otherNames] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.precedenceGroupNameList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.otherNames)
    return PrecedenceGroupRelationSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `otherNames` replaced.
  /// - param newChild: The new `otherNames` to replace the node's
  ///                   current `otherNames`, if present.
  public func withOtherNames(
    _ newChild: PrecedenceGroupNameListSyntax?) -> PrecedenceGroupRelationSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.precedenceGroupNameList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.otherNames)
    return PrecedenceGroupRelationSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `PrecedenceGroupRelationSyntax` nodes are equal to each other.
  public static func ==(lhs: PrecedenceGroupRelationSyntax, rhs: PrecedenceGroupRelationSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct PrecedenceGroupNameElementSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case name
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case trailingComma
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `PrecedenceGroupNameElementSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 2)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _name = raw[Cursor.identifierToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _nameTokenKind = _name.tokenKind else {
      fatalError("expected token child, got \(_name.kind)")
    }
    precondition([.identifier].contains(_nameTokenKind),
      "expected one of [.identifier] for 'name' " + 
      "in node of kind precedenceGroupNameElement")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _trailingComma = raw[Cursor.commaToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _trailingCommaTokenKind = _trailingComma.tokenKind else {
      fatalError("expected token child, got \(_trailingComma.kind)")
    }
    precondition([.comma].contains(_trailingCommaTokenKind),
      "expected one of [.comma] for 'trailingComma' " + 
      "in node of kind precedenceGroupNameElement")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var name: TokenSyntax {
    let child = data.cachedChild(at: Cursor.name)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `name` replaced.
  /// - param newChild: The new `name` to replace the node's
  ///                   current `name`, if present.
  public func withName(
    _ newChild: TokenSyntax?) -> PrecedenceGroupNameElementSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.name)
    return PrecedenceGroupNameElementSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var trailingComma: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.trailingComma)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `trailingComma` replaced.
  /// - param newChild: The new `trailingComma` to replace the node's
  ///                   current `trailingComma`, if present.
  public func withTrailingComma(
    _ newChild: TokenSyntax?) -> PrecedenceGroupNameElementSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.comma)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.trailingComma)
    return PrecedenceGroupNameElementSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `PrecedenceGroupNameElementSyntax` nodes are equal to each other.
  public static func ==(lhs: PrecedenceGroupNameElementSyntax, rhs: PrecedenceGroupNameElementSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 70)
/// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 70)
/// Specifies the precedence of an operator when used in an operation
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 70)
/// that includes optional chaining.
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 70)
/// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct PrecedenceGroupAssignmentSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case assignmentKeyword
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case colon
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case flag
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `PrecedenceGroupAssignmentSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 3)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _assignmentKeyword = raw[Cursor.identifierToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _assignmentKeywordTokenKind = _assignmentKeyword.tokenKind else {
      fatalError("expected token child, got \(_assignmentKeyword.kind)")
    }
    precondition([.identifier].contains(_assignmentKeywordTokenKind),
      "expected one of [.identifier] for 'assignmentKeyword' " + 
      "in node of kind precedenceGroupAssignment")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _colon = raw[Cursor.colonToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _colonTokenKind = _colon.tokenKind else {
      fatalError("expected token child, got \(_colon.kind)")
    }
    precondition([.colon].contains(_colonTokenKind),
      "expected one of [.colon] for 'colon' " + 
      "in node of kind precedenceGroupAssignment")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _flag = raw[Cursor.token]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _flagTokenKind = _flag.tokenKind else {
      fatalError("expected token child, got \(_flag.kind)")
    }
    precondition([.trueKeyword, .falseKeyword].contains(_flagTokenKind),
      "expected one of [.trueKeyword, .falseKeyword] for 'flag' " + 
      "in node of kind precedenceGroupAssignment")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var assignmentKeyword: TokenSyntax {
    let child = data.cachedChild(at: Cursor.assignmentKeyword)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `assignmentKeyword` replaced.
  /// - param newChild: The new `assignmentKeyword` to replace the node's
  ///                   current `assignmentKeyword`, if present.
  public func withAssignmentKeyword(
    _ newChild: TokenSyntax?) -> PrecedenceGroupAssignmentSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.assignmentKeyword)
    return PrecedenceGroupAssignmentSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var colon: TokenSyntax {
    let child = data.cachedChild(at: Cursor.colon)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `colon` replaced.
  /// - param newChild: The new `colon` to replace the node's
  ///                   current `colon`, if present.
  public func withColon(
    _ newChild: TokenSyntax?) -> PrecedenceGroupAssignmentSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.colon)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.colon)
    return PrecedenceGroupAssignmentSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// When true, an operator in the corresponding precedence group
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// uses the same grouping rules during optional chaining as the
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// assignment operators from the standard library. Otherwise,
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// operators in the precedence group follows the same optional
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// chaining rules as operators that don't perform assignment.
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var flag: TokenSyntax {
    let child = data.cachedChild(at: Cursor.flag)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `flag` replaced.
  /// - param newChild: The new `flag` to replace the node's
  ///                   current `flag`, if present.
  public func withFlag(
    _ newChild: TokenSyntax?) -> PrecedenceGroupAssignmentSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.trueKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.flag)
    return PrecedenceGroupAssignmentSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `PrecedenceGroupAssignmentSyntax` nodes are equal to each other.
  public static func ==(lhs: PrecedenceGroupAssignmentSyntax, rhs: PrecedenceGroupAssignmentSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 70)
/// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 70)
/// Specifies how a sequence of operators with the same precedence level
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 70)
/// are grouped together in the absence of grouping parentheses.
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 70)
/// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct PrecedenceGroupAssociativitySyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case associativityKeyword
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case colon
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case value
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `PrecedenceGroupAssociativitySyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 3)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _associativityKeyword = raw[Cursor.identifierToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _associativityKeywordTokenKind = _associativityKeyword.tokenKind else {
      fatalError("expected token child, got \(_associativityKeyword.kind)")
    }
    precondition([.identifier].contains(_associativityKeywordTokenKind),
      "expected one of [.identifier] for 'associativityKeyword' " + 
      "in node of kind precedenceGroupAssociativity")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _colon = raw[Cursor.colonToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _colonTokenKind = _colon.tokenKind else {
      fatalError("expected token child, got \(_colon.kind)")
    }
    precondition([.colon].contains(_colonTokenKind),
      "expected one of [.colon] for 'colon' " + 
      "in node of kind precedenceGroupAssociativity")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _value = raw[Cursor.identifierToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _valueTokenKind = _value.tokenKind else {
      fatalError("expected token child, got \(_value.kind)")
    }
    precondition([.identifier].contains(_valueTokenKind),
      "expected one of [.identifier] for 'value' " + 
      "in node of kind precedenceGroupAssociativity")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var associativityKeyword: TokenSyntax {
    let child = data.cachedChild(at: Cursor.associativityKeyword)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `associativityKeyword` replaced.
  /// - param newChild: The new `associativityKeyword` to replace the node's
  ///                   current `associativityKeyword`, if present.
  public func withAssociativityKeyword(
    _ newChild: TokenSyntax?) -> PrecedenceGroupAssociativitySyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.associativityKeyword)
    return PrecedenceGroupAssociativitySyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var colon: TokenSyntax {
    let child = data.cachedChild(at: Cursor.colon)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `colon` replaced.
  /// - param newChild: The new `colon` to replace the node's
  ///                   current `colon`, if present.
  public func withColon(
    _ newChild: TokenSyntax?) -> PrecedenceGroupAssociativitySyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.colon)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.colon)
    return PrecedenceGroupAssociativitySyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// Operators that are `left`-associative group left-to-right.
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// Operators that are `right`-associative group right-to-left.
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// Operators that are specified with an associativity of `none`
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// don't associate at all
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var value: TokenSyntax {
    let child = data.cachedChild(at: Cursor.value)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `value` replaced.
  /// - param newChild: The new `value` to replace the node's
  ///                   current `value`, if present.
  public func withValue(
    _ newChild: TokenSyntax?) -> PrecedenceGroupAssociativitySyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.value)
    return PrecedenceGroupAssociativitySyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `PrecedenceGroupAssociativitySyntax` nodes are equal to each other.
  public static func ==(lhs: PrecedenceGroupAssociativitySyntax, rhs: PrecedenceGroupAssociativitySyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 70)
/// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 70)
/// An `@` attribute.
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 70)
/// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct AttributeSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case atSignToken
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case attributeName
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case leftParen
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case argument
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case rightParen
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case tokenList
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `AttributeSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 6)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _atSignToken = raw[Cursor.atSignToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _atSignTokenTokenKind = _atSignToken.tokenKind else {
      fatalError("expected token child, got \(_atSignToken.kind)")
    }
    precondition([.atSign].contains(_atSignTokenTokenKind),
      "expected one of [.atSign] for 'atSignToken' " + 
      "in node of kind attribute")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _attributeName = raw[Cursor.token]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_attributeName.kind == .token,
                 "expected child of kind .token, " +
                 "got \(_attributeName.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _leftParen = raw[Cursor.leftParenToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _leftParenTokenKind = _leftParen.tokenKind else {
      fatalError("expected token child, got \(_leftParen.kind)")
    }
    precondition([.leftParen].contains(_leftParenTokenKind),
      "expected one of [.leftParen] for 'leftParen' " + 
      "in node of kind attribute")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _argument = raw[Cursor.syntax]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_argument.kind == .syntax,
                 "expected child of kind .syntax, " +
                 "got \(_argument.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _rightParen = raw[Cursor.rightParenToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _rightParenTokenKind = _rightParen.tokenKind else {
      fatalError("expected token child, got \(_rightParen.kind)")
    }
    precondition([.rightParen].contains(_rightParenTokenKind),
      "expected one of [.rightParen] for 'rightParen' " + 
      "in node of kind attribute")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _tokenList = raw[Cursor.tokenList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_tokenList.kind == .tokenList,
                 "expected child of kind .tokenList, " +
                 "got \(_tokenList.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// The `@` sign.
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var atSignToken: TokenSyntax {
    let child = data.cachedChild(at: Cursor.atSignToken)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `atSignToken` replaced.
  /// - param newChild: The new `atSignToken` to replace the node's
  ///                   current `atSignToken`, if present.
  public func withAtSignToken(
    _ newChild: TokenSyntax?) -> AttributeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.atSign)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.atSignToken)
    return AttributeSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// The name of the attribute.
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var attributeName: TokenSyntax {
    let child = data.cachedChild(at: Cursor.attributeName)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `attributeName` replaced.
  /// - param newChild: The new `attributeName` to replace the node's
  ///                   current `attributeName`, if present.
  public func withAttributeName(
    _ newChild: TokenSyntax?) -> AttributeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.unknown(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.attributeName)
    return AttributeSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// If the attribute takes arguments, the opening parenthesis.
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var leftParen: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.leftParen)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `leftParen` replaced.
  /// - param newChild: The new `leftParen` to replace the node's
  ///                   current `leftParen`, if present.
  public func withLeftParen(
    _ newChild: TokenSyntax?) -> AttributeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftParen)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.leftParen)
    return AttributeSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// The arguments of the attribute. In case the attribute                     takes multiple arguments, they are gather in the                    appropriate takes first.
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var argument: Syntax? {
    let child = data.cachedChild(at: Cursor.argument)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) 
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `argument` replaced.
  /// - param newChild: The new `argument` to replace the node's
  ///                   current `argument`, if present.
  public func withArgument(
    _ newChild: Syntax?) -> AttributeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.unknown)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.argument)
    return AttributeSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// If the attribute takes arguments, the closing parenthesis.
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var rightParen: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.rightParen)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `rightParen` replaced.
  /// - param newChild: The new `rightParen` to replace the node's
  ///                   current `rightParen`, if present.
  public func withRightParen(
    _ newChild: TokenSyntax?) -> AttributeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightParen)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.rightParen)
    return AttributeSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var tokenList: TokenListSyntax? {
    let child = data.cachedChild(at: Cursor.tokenList)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `Token` to the node's `tokenList`
  /// collection.
  /// - param element: The new `Token` to add to the node's
  ///                  `tokenList` collection.
  /// - returns: A copy of the receiver with the provided `Token`
  ///            appended to its `tokenList` collection.
  public func addToken(_ element: TokenSyntax) -> AttributeSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.tokenList] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.tokenList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.tokenList)
    return AttributeSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `tokenList` replaced.
  /// - param newChild: The new `tokenList` to replace the node's
  ///                   current `tokenList`, if present.
  public func withTokenList(
    _ newChild: TokenListSyntax?) -> AttributeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.unknown(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.tokenList)
    return AttributeSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `AttributeSyntax` nodes are equal to each other.
  public static func ==(lhs: AttributeSyntax, rhs: AttributeSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 70)
/// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 70)
/// A labeled argument for the `@_specialize` attribute like          `exported: true`
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 70)
/// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct LabeledSpecializeEntrySyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case label
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case colon
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case value
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case trailingComma
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `LabeledSpecializeEntrySyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 4)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _label = raw[Cursor.identifierToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _labelTokenKind = _label.tokenKind else {
      fatalError("expected token child, got \(_label.kind)")
    }
    precondition([.identifier].contains(_labelTokenKind),
      "expected one of [.identifier] for 'label' " + 
      "in node of kind labeledSpecializeEntry")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _colon = raw[Cursor.colonToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _colonTokenKind = _colon.tokenKind else {
      fatalError("expected token child, got \(_colon.kind)")
    }
    precondition([.colon].contains(_colonTokenKind),
      "expected one of [.colon] for 'colon' " + 
      "in node of kind labeledSpecializeEntry")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _value = raw[Cursor.token]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_value.kind == .token,
                 "expected child of kind .token, " +
                 "got \(_value.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _trailingComma = raw[Cursor.commaToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _trailingCommaTokenKind = _trailingComma.tokenKind else {
      fatalError("expected token child, got \(_trailingComma.kind)")
    }
    precondition([.comma].contains(_trailingCommaTokenKind),
      "expected one of [.comma] for 'trailingComma' " + 
      "in node of kind labeledSpecializeEntry")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// The label of the argument
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var label: TokenSyntax {
    let child = data.cachedChild(at: Cursor.label)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `label` replaced.
  /// - param newChild: The new `label` to replace the node's
  ///                   current `label`, if present.
  public func withLabel(
    _ newChild: TokenSyntax?) -> LabeledSpecializeEntrySyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.label)
    return LabeledSpecializeEntrySyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// The colon separating the label and the value
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var colon: TokenSyntax {
    let child = data.cachedChild(at: Cursor.colon)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `colon` replaced.
  /// - param newChild: The new `colon` to replace the node's
  ///                   current `colon`, if present.
  public func withColon(
    _ newChild: TokenSyntax?) -> LabeledSpecializeEntrySyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.colon)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.colon)
    return LabeledSpecializeEntrySyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// The value for this argument
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var value: TokenSyntax {
    let child = data.cachedChild(at: Cursor.value)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `value` replaced.
  /// - param newChild: The new `value` to replace the node's
  ///                   current `value`, if present.
  public func withValue(
    _ newChild: TokenSyntax?) -> LabeledSpecializeEntrySyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.unknown(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.value)
    return LabeledSpecializeEntrySyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// A trailing comma if this argument is followed by another one
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var trailingComma: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.trailingComma)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `trailingComma` replaced.
  /// - param newChild: The new `trailingComma` to replace the node's
  ///                   current `trailingComma`, if present.
  public func withTrailingComma(
    _ newChild: TokenSyntax?) -> LabeledSpecializeEntrySyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.comma)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.trailingComma)
    return LabeledSpecializeEntrySyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `LabeledSpecializeEntrySyntax` nodes are equal to each other.
  public static func ==(lhs: LabeledSpecializeEntrySyntax, rhs: LabeledSpecializeEntrySyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 70)
/// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 70)
/// The arguments for the `@_implements` attribute of the form          `Type, methodName(arg1Label:arg2Label:)`
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 70)
/// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct ImplementsAttributeArgumentsSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case type
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case comma
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case declBaseName
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case declNameArguments
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `ImplementsAttributeArgumentsSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 4)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _type = raw[Cursor.simpleTypeIdentifier]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_type.kind == .simpleTypeIdentifier,
                 "expected child of kind .simpleTypeIdentifier, " +
                 "got \(_type.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _comma = raw[Cursor.commaToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _commaTokenKind = _comma.tokenKind else {
      fatalError("expected token child, got \(_comma.kind)")
    }
    precondition([.comma].contains(_commaTokenKind),
      "expected one of [.comma] for 'comma' " + 
      "in node of kind implementsAttributeArguments")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _declBaseName = raw[Cursor.syntax]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_declBaseName.kind == .syntax,
                 "expected child of kind .syntax, " +
                 "got \(_declBaseName.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _declNameArguments = raw[Cursor.declNameArguments]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_declNameArguments.kind == .declNameArguments,
                 "expected child of kind .declNameArguments, " +
                 "got \(_declNameArguments.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// The type for which the method with this attribute                    implements a requirement.
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var type: SimpleTypeIdentifierSyntax {
    let child = data.cachedChild(at: Cursor.type)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! SimpleTypeIdentifierSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `type` replaced.
  /// - param newChild: The new `type` to replace the node's
  ///                   current `type`, if present.
  public func withType(
    _ newChild: SimpleTypeIdentifierSyntax?) -> ImplementsAttributeArgumentsSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.simpleTypeIdentifier)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.type)
    return ImplementsAttributeArgumentsSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// The comma separating the type and method name
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var comma: TokenSyntax {
    let child = data.cachedChild(at: Cursor.comma)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `comma` replaced.
  /// - param newChild: The new `comma` to replace the node's
  ///                   current `comma`, if present.
  public func withComma(
    _ newChild: TokenSyntax?) -> ImplementsAttributeArgumentsSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.comma)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.comma)
    return ImplementsAttributeArgumentsSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// The base name of the protocol's requirement.
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var declBaseName: Syntax {
    let child = data.cachedChild(at: Cursor.declBaseName)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) 
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `declBaseName` replaced.
  /// - param newChild: The new `declBaseName` to replace the node's
  ///                   current `declBaseName`, if present.
  public func withDeclBaseName(
    _ newChild: Syntax?) -> ImplementsAttributeArgumentsSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.unknown)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.declBaseName)
    return ImplementsAttributeArgumentsSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// The argument labels of the protocol's requirement if it                    is a function requirement.
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var declNameArguments: DeclNameArgumentsSyntax? {
    let child = data.cachedChild(at: Cursor.declNameArguments)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? DeclNameArgumentsSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `declNameArguments` replaced.
  /// - param newChild: The new `declNameArguments` to replace the node's
  ///                   current `declNameArguments`, if present.
  public func withDeclNameArguments(
    _ newChild: DeclNameArgumentsSyntax?) -> ImplementsAttributeArgumentsSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.declNameArguments)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.declNameArguments)
    return ImplementsAttributeArgumentsSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `ImplementsAttributeArgumentsSyntax` nodes are equal to each other.
  public static func ==(lhs: ImplementsAttributeArgumentsSyntax, rhs: ImplementsAttributeArgumentsSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 70)
/// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 70)
/// A piece of an Objective-C selector. Either consisiting of just an          identifier for a nullary selector, an identifier and a colon for a          labeled argument or just a colon for an unlabeled argument
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 70)
/// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct ObjCSelectorPieceSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case name
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case colon
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `ObjCSelectorPieceSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 2)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _name = raw[Cursor.identifierToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _nameTokenKind = _name.tokenKind else {
      fatalError("expected token child, got \(_name.kind)")
    }
    precondition([.identifier].contains(_nameTokenKind),
      "expected one of [.identifier] for 'name' " + 
      "in node of kind objCSelectorPiece")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _colon = raw[Cursor.colonToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _colonTokenKind = _colon.tokenKind else {
      fatalError("expected token child, got \(_colon.kind)")
    }
    precondition([.colon].contains(_colonTokenKind),
      "expected one of [.colon] for 'colon' " + 
      "in node of kind objCSelectorPiece")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var name: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.name)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `name` replaced.
  /// - param newChild: The new `name` to replace the node's
  ///                   current `name`, if present.
  public func withName(
    _ newChild: TokenSyntax?) -> ObjCSelectorPieceSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.name)
    return ObjCSelectorPieceSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var colon: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.colon)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `colon` replaced.
  /// - param newChild: The new `colon` to replace the node's
  ///                   current `colon`, if present.
  public func withColon(
    _ newChild: TokenSyntax?) -> ObjCSelectorPieceSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.colon)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.colon)
    return ObjCSelectorPieceSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `ObjCSelectorPieceSyntax` nodes are equal to each other.
  public static func ==(lhs: ObjCSelectorPieceSyntax, rhs: ObjCSelectorPieceSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct ContinueStmtSyntax: StmtSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case continueKeyword
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case label
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `ContinueStmtSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 2)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _continueKeyword = raw[Cursor.continueToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _continueKeywordTokenKind = _continueKeyword.tokenKind else {
      fatalError("expected token child, got \(_continueKeyword.kind)")
    }
    precondition([.continueKeyword].contains(_continueKeywordTokenKind),
      "expected one of [.continueKeyword] for 'continueKeyword' " + 
      "in node of kind continueStmt")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _label = raw[Cursor.identifierToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _labelTokenKind = _label.tokenKind else {
      fatalError("expected token child, got \(_label.kind)")
    }
    precondition([.identifier].contains(_labelTokenKind),
      "expected one of [.identifier] for 'label' " + 
      "in node of kind continueStmt")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var continueKeyword: TokenSyntax {
    let child = data.cachedChild(at: Cursor.continueKeyword)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `continueKeyword` replaced.
  /// - param newChild: The new `continueKeyword` to replace the node's
  ///                   current `continueKeyword`, if present.
  public func withContinueKeyword(
    _ newChild: TokenSyntax?) -> ContinueStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.continueKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.continueKeyword)
    return ContinueStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var label: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.label)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `label` replaced.
  /// - param newChild: The new `label` to replace the node's
  ///                   current `label`, if present.
  public func withLabel(
    _ newChild: TokenSyntax?) -> ContinueStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.label)
    return ContinueStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `ContinueStmtSyntax` nodes are equal to each other.
  public static func ==(lhs: ContinueStmtSyntax, rhs: ContinueStmtSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct WhileStmtSyntax: StmtSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case labelName
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case labelColon
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case whileKeyword
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case conditions
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case body
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `WhileStmtSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 5)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _labelName = raw[Cursor.identifierToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _labelNameTokenKind = _labelName.tokenKind else {
      fatalError("expected token child, got \(_labelName.kind)")
    }
    precondition([.identifier].contains(_labelNameTokenKind),
      "expected one of [.identifier] for 'labelName' " + 
      "in node of kind whileStmt")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _labelColon = raw[Cursor.colonToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _labelColonTokenKind = _labelColon.tokenKind else {
      fatalError("expected token child, got \(_labelColon.kind)")
    }
    precondition([.colon].contains(_labelColonTokenKind),
      "expected one of [.colon] for 'labelColon' " + 
      "in node of kind whileStmt")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _whileKeyword = raw[Cursor.whileToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _whileKeywordTokenKind = _whileKeyword.tokenKind else {
      fatalError("expected token child, got \(_whileKeyword.kind)")
    }
    precondition([.whileKeyword].contains(_whileKeywordTokenKind),
      "expected one of [.whileKeyword] for 'whileKeyword' " + 
      "in node of kind whileStmt")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _conditions = raw[Cursor.conditionElementList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_conditions.kind == .conditionElementList,
                 "expected child of kind .conditionElementList, " +
                 "got \(_conditions.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _body = raw[Cursor.codeBlock]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_body.kind == .codeBlock,
                 "expected child of kind .codeBlock, " +
                 "got \(_body.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var labelName: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.labelName)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `labelName` replaced.
  /// - param newChild: The new `labelName` to replace the node's
  ///                   current `labelName`, if present.
  public func withLabelName(
    _ newChild: TokenSyntax?) -> WhileStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.labelName)
    return WhileStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var labelColon: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.labelColon)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `labelColon` replaced.
  /// - param newChild: The new `labelColon` to replace the node's
  ///                   current `labelColon`, if present.
  public func withLabelColon(
    _ newChild: TokenSyntax?) -> WhileStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.colon)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.labelColon)
    return WhileStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var whileKeyword: TokenSyntax {
    let child = data.cachedChild(at: Cursor.whileKeyword)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `whileKeyword` replaced.
  /// - param newChild: The new `whileKeyword` to replace the node's
  ///                   current `whileKeyword`, if present.
  public func withWhileKeyword(
    _ newChild: TokenSyntax?) -> WhileStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.whileKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.whileKeyword)
    return WhileStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var conditions: ConditionElementListSyntax {
    let child = data.cachedChild(at: Cursor.conditions)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! ConditionElementListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `ConditionElement` to the node's `conditions`
  /// collection.
  /// - param element: The new `ConditionElement` to add to the node's
  ///                  `conditions` collection.
  /// - returns: A copy of the receiver with the provided `ConditionElement`
  ///            appended to its `conditions` collection.
  public func addConditionElement(_ element: ConditionElementSyntax) -> WhileStmtSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.conditions] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.conditionElementList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.conditions)
    return WhileStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `conditions` replaced.
  /// - param newChild: The new `conditions` to replace the node's
  ///                   current `conditions`, if present.
  public func withConditions(
    _ newChild: ConditionElementListSyntax?) -> WhileStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.conditionElementList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.conditions)
    return WhileStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var body: CodeBlockSyntax {
    let child = data.cachedChild(at: Cursor.body)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! CodeBlockSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `body` replaced.
  /// - param newChild: The new `body` to replace the node's
  ///                   current `body`, if present.
  public func withBody(
    _ newChild: CodeBlockSyntax?) -> WhileStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.codeBlock)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.body)
    return WhileStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `WhileStmtSyntax` nodes are equal to each other.
  public static func ==(lhs: WhileStmtSyntax, rhs: WhileStmtSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct DeferStmtSyntax: StmtSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case deferKeyword
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case body
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `DeferStmtSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 2)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _deferKeyword = raw[Cursor.deferToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _deferKeywordTokenKind = _deferKeyword.tokenKind else {
      fatalError("expected token child, got \(_deferKeyword.kind)")
    }
    precondition([.deferKeyword].contains(_deferKeywordTokenKind),
      "expected one of [.deferKeyword] for 'deferKeyword' " + 
      "in node of kind deferStmt")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _body = raw[Cursor.codeBlock]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_body.kind == .codeBlock,
                 "expected child of kind .codeBlock, " +
                 "got \(_body.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var deferKeyword: TokenSyntax {
    let child = data.cachedChild(at: Cursor.deferKeyword)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `deferKeyword` replaced.
  /// - param newChild: The new `deferKeyword` to replace the node's
  ///                   current `deferKeyword`, if present.
  public func withDeferKeyword(
    _ newChild: TokenSyntax?) -> DeferStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.deferKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.deferKeyword)
    return DeferStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var body: CodeBlockSyntax {
    let child = data.cachedChild(at: Cursor.body)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! CodeBlockSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `body` replaced.
  /// - param newChild: The new `body` to replace the node's
  ///                   current `body`, if present.
  public func withBody(
    _ newChild: CodeBlockSyntax?) -> DeferStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.codeBlock)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.body)
    return DeferStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `DeferStmtSyntax` nodes are equal to each other.
  public static func ==(lhs: DeferStmtSyntax, rhs: DeferStmtSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct ExpressionStmtSyntax: StmtSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case expression
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `ExpressionStmtSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 1)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _expression = raw[Cursor.expr]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_expression.kind == .expr,
                 "expected child of kind .expr, " +
                 "got \(_expression.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var expression: ExprSyntax {
    let child = data.cachedChild(at: Cursor.expression)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! ExprSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `expression` replaced.
  /// - param newChild: The new `expression` to replace the node's
  ///                   current `expression`, if present.
  public func withExpression(
    _ newChild: ExprSyntax?) -> ExpressionStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.expression)
    return ExpressionStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `ExpressionStmtSyntax` nodes are equal to each other.
  public static func ==(lhs: ExpressionStmtSyntax, rhs: ExpressionStmtSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct RepeatWhileStmtSyntax: StmtSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case labelName
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case labelColon
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case repeatKeyword
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case body
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case whileKeyword
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case condition
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `RepeatWhileStmtSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 6)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _labelName = raw[Cursor.identifierToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _labelNameTokenKind = _labelName.tokenKind else {
      fatalError("expected token child, got \(_labelName.kind)")
    }
    precondition([.identifier].contains(_labelNameTokenKind),
      "expected one of [.identifier] for 'labelName' " + 
      "in node of kind repeatWhileStmt")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _labelColon = raw[Cursor.colonToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _labelColonTokenKind = _labelColon.tokenKind else {
      fatalError("expected token child, got \(_labelColon.kind)")
    }
    precondition([.colon].contains(_labelColonTokenKind),
      "expected one of [.colon] for 'labelColon' " + 
      "in node of kind repeatWhileStmt")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _repeatKeyword = raw[Cursor.repeatToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _repeatKeywordTokenKind = _repeatKeyword.tokenKind else {
      fatalError("expected token child, got \(_repeatKeyword.kind)")
    }
    precondition([.repeatKeyword].contains(_repeatKeywordTokenKind),
      "expected one of [.repeatKeyword] for 'repeatKeyword' " + 
      "in node of kind repeatWhileStmt")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _body = raw[Cursor.codeBlock]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_body.kind == .codeBlock,
                 "expected child of kind .codeBlock, " +
                 "got \(_body.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _whileKeyword = raw[Cursor.whileToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _whileKeywordTokenKind = _whileKeyword.tokenKind else {
      fatalError("expected token child, got \(_whileKeyword.kind)")
    }
    precondition([.whileKeyword].contains(_whileKeywordTokenKind),
      "expected one of [.whileKeyword] for 'whileKeyword' " + 
      "in node of kind repeatWhileStmt")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _condition = raw[Cursor.expr]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_condition.kind == .expr,
                 "expected child of kind .expr, " +
                 "got \(_condition.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var labelName: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.labelName)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `labelName` replaced.
  /// - param newChild: The new `labelName` to replace the node's
  ///                   current `labelName`, if present.
  public func withLabelName(
    _ newChild: TokenSyntax?) -> RepeatWhileStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.labelName)
    return RepeatWhileStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var labelColon: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.labelColon)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `labelColon` replaced.
  /// - param newChild: The new `labelColon` to replace the node's
  ///                   current `labelColon`, if present.
  public func withLabelColon(
    _ newChild: TokenSyntax?) -> RepeatWhileStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.colon)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.labelColon)
    return RepeatWhileStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var repeatKeyword: TokenSyntax {
    let child = data.cachedChild(at: Cursor.repeatKeyword)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `repeatKeyword` replaced.
  /// - param newChild: The new `repeatKeyword` to replace the node's
  ///                   current `repeatKeyword`, if present.
  public func withRepeatKeyword(
    _ newChild: TokenSyntax?) -> RepeatWhileStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.repeatKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.repeatKeyword)
    return RepeatWhileStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var body: CodeBlockSyntax {
    let child = data.cachedChild(at: Cursor.body)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! CodeBlockSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `body` replaced.
  /// - param newChild: The new `body` to replace the node's
  ///                   current `body`, if present.
  public func withBody(
    _ newChild: CodeBlockSyntax?) -> RepeatWhileStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.codeBlock)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.body)
    return RepeatWhileStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var whileKeyword: TokenSyntax {
    let child = data.cachedChild(at: Cursor.whileKeyword)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `whileKeyword` replaced.
  /// - param newChild: The new `whileKeyword` to replace the node's
  ///                   current `whileKeyword`, if present.
  public func withWhileKeyword(
    _ newChild: TokenSyntax?) -> RepeatWhileStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.whileKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.whileKeyword)
    return RepeatWhileStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var condition: ExprSyntax {
    let child = data.cachedChild(at: Cursor.condition)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! ExprSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `condition` replaced.
  /// - param newChild: The new `condition` to replace the node's
  ///                   current `condition`, if present.
  public func withCondition(
    _ newChild: ExprSyntax?) -> RepeatWhileStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.condition)
    return RepeatWhileStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `RepeatWhileStmtSyntax` nodes are equal to each other.
  public static func ==(lhs: RepeatWhileStmtSyntax, rhs: RepeatWhileStmtSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct GuardStmtSyntax: StmtSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case guardKeyword
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case conditions
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case elseKeyword
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case body
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `GuardStmtSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 4)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _guardKeyword = raw[Cursor.guardToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _guardKeywordTokenKind = _guardKeyword.tokenKind else {
      fatalError("expected token child, got \(_guardKeyword.kind)")
    }
    precondition([.guardKeyword].contains(_guardKeywordTokenKind),
      "expected one of [.guardKeyword] for 'guardKeyword' " + 
      "in node of kind guardStmt")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _conditions = raw[Cursor.conditionElementList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_conditions.kind == .conditionElementList,
                 "expected child of kind .conditionElementList, " +
                 "got \(_conditions.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _elseKeyword = raw[Cursor.elseToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _elseKeywordTokenKind = _elseKeyword.tokenKind else {
      fatalError("expected token child, got \(_elseKeyword.kind)")
    }
    precondition([.elseKeyword].contains(_elseKeywordTokenKind),
      "expected one of [.elseKeyword] for 'elseKeyword' " + 
      "in node of kind guardStmt")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _body = raw[Cursor.codeBlock]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_body.kind == .codeBlock,
                 "expected child of kind .codeBlock, " +
                 "got \(_body.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var guardKeyword: TokenSyntax {
    let child = data.cachedChild(at: Cursor.guardKeyword)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `guardKeyword` replaced.
  /// - param newChild: The new `guardKeyword` to replace the node's
  ///                   current `guardKeyword`, if present.
  public func withGuardKeyword(
    _ newChild: TokenSyntax?) -> GuardStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.guardKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.guardKeyword)
    return GuardStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var conditions: ConditionElementListSyntax {
    let child = data.cachedChild(at: Cursor.conditions)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! ConditionElementListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `ConditionElement` to the node's `conditions`
  /// collection.
  /// - param element: The new `ConditionElement` to add to the node's
  ///                  `conditions` collection.
  /// - returns: A copy of the receiver with the provided `ConditionElement`
  ///            appended to its `conditions` collection.
  public func addConditionElement(_ element: ConditionElementSyntax) -> GuardStmtSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.conditions] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.conditionElementList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.conditions)
    return GuardStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `conditions` replaced.
  /// - param newChild: The new `conditions` to replace the node's
  ///                   current `conditions`, if present.
  public func withConditions(
    _ newChild: ConditionElementListSyntax?) -> GuardStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.conditionElementList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.conditions)
    return GuardStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var elseKeyword: TokenSyntax {
    let child = data.cachedChild(at: Cursor.elseKeyword)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `elseKeyword` replaced.
  /// - param newChild: The new `elseKeyword` to replace the node's
  ///                   current `elseKeyword`, if present.
  public func withElseKeyword(
    _ newChild: TokenSyntax?) -> GuardStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.elseKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.elseKeyword)
    return GuardStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var body: CodeBlockSyntax {
    let child = data.cachedChild(at: Cursor.body)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! CodeBlockSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `body` replaced.
  /// - param newChild: The new `body` to replace the node's
  ///                   current `body`, if present.
  public func withBody(
    _ newChild: CodeBlockSyntax?) -> GuardStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.codeBlock)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.body)
    return GuardStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `GuardStmtSyntax` nodes are equal to each other.
  public static func ==(lhs: GuardStmtSyntax, rhs: GuardStmtSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct WhereClauseSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case whereKeyword
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case guardResult
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `WhereClauseSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 2)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _whereKeyword = raw[Cursor.whereToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _whereKeywordTokenKind = _whereKeyword.tokenKind else {
      fatalError("expected token child, got \(_whereKeyword.kind)")
    }
    precondition([.whereKeyword].contains(_whereKeywordTokenKind),
      "expected one of [.whereKeyword] for 'whereKeyword' " + 
      "in node of kind whereClause")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _guardResult = raw[Cursor.expr]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_guardResult.kind == .expr,
                 "expected child of kind .expr, " +
                 "got \(_guardResult.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var whereKeyword: TokenSyntax {
    let child = data.cachedChild(at: Cursor.whereKeyword)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `whereKeyword` replaced.
  /// - param newChild: The new `whereKeyword` to replace the node's
  ///                   current `whereKeyword`, if present.
  public func withWhereKeyword(
    _ newChild: TokenSyntax?) -> WhereClauseSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.whereKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.whereKeyword)
    return WhereClauseSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var guardResult: ExprSyntax {
    let child = data.cachedChild(at: Cursor.guardResult)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! ExprSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `guardResult` replaced.
  /// - param newChild: The new `guardResult` to replace the node's
  ///                   current `guardResult`, if present.
  public func withGuardResult(
    _ newChild: ExprSyntax?) -> WhereClauseSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.guardResult)
    return WhereClauseSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `WhereClauseSyntax` nodes are equal to each other.
  public static func ==(lhs: WhereClauseSyntax, rhs: WhereClauseSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct ForInStmtSyntax: StmtSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case labelName
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case labelColon
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case forKeyword
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case caseKeyword
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case pattern
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case typeAnnotation
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case inKeyword
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case sequenceExpr
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case whereClause
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case body
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `ForInStmtSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 10)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _labelName = raw[Cursor.identifierToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _labelNameTokenKind = _labelName.tokenKind else {
      fatalError("expected token child, got \(_labelName.kind)")
    }
    precondition([.identifier].contains(_labelNameTokenKind),
      "expected one of [.identifier] for 'labelName' " + 
      "in node of kind forInStmt")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _labelColon = raw[Cursor.colonToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _labelColonTokenKind = _labelColon.tokenKind else {
      fatalError("expected token child, got \(_labelColon.kind)")
    }
    precondition([.colon].contains(_labelColonTokenKind),
      "expected one of [.colon] for 'labelColon' " + 
      "in node of kind forInStmt")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _forKeyword = raw[Cursor.forToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _forKeywordTokenKind = _forKeyword.tokenKind else {
      fatalError("expected token child, got \(_forKeyword.kind)")
    }
    precondition([.forKeyword].contains(_forKeywordTokenKind),
      "expected one of [.forKeyword] for 'forKeyword' " + 
      "in node of kind forInStmt")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _caseKeyword = raw[Cursor.caseToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _caseKeywordTokenKind = _caseKeyword.tokenKind else {
      fatalError("expected token child, got \(_caseKeyword.kind)")
    }
    precondition([.caseKeyword].contains(_caseKeywordTokenKind),
      "expected one of [.caseKeyword] for 'caseKeyword' " + 
      "in node of kind forInStmt")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _pattern = raw[Cursor.pattern]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_pattern.kind == .pattern,
                 "expected child of kind .pattern, " +
                 "got \(_pattern.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _typeAnnotation = raw[Cursor.typeAnnotation]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_typeAnnotation.kind == .typeAnnotation,
                 "expected child of kind .typeAnnotation, " +
                 "got \(_typeAnnotation.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _inKeyword = raw[Cursor.inToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _inKeywordTokenKind = _inKeyword.tokenKind else {
      fatalError("expected token child, got \(_inKeyword.kind)")
    }
    precondition([.inKeyword].contains(_inKeywordTokenKind),
      "expected one of [.inKeyword] for 'inKeyword' " + 
      "in node of kind forInStmt")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _sequenceExpr = raw[Cursor.expr]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_sequenceExpr.kind == .expr,
                 "expected child of kind .expr, " +
                 "got \(_sequenceExpr.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _whereClause = raw[Cursor.whereClause]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_whereClause.kind == .whereClause,
                 "expected child of kind .whereClause, " +
                 "got \(_whereClause.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _body = raw[Cursor.codeBlock]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_body.kind == .codeBlock,
                 "expected child of kind .codeBlock, " +
                 "got \(_body.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var labelName: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.labelName)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `labelName` replaced.
  /// - param newChild: The new `labelName` to replace the node's
  ///                   current `labelName`, if present.
  public func withLabelName(
    _ newChild: TokenSyntax?) -> ForInStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.labelName)
    return ForInStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var labelColon: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.labelColon)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `labelColon` replaced.
  /// - param newChild: The new `labelColon` to replace the node's
  ///                   current `labelColon`, if present.
  public func withLabelColon(
    _ newChild: TokenSyntax?) -> ForInStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.colon)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.labelColon)
    return ForInStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var forKeyword: TokenSyntax {
    let child = data.cachedChild(at: Cursor.forKeyword)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `forKeyword` replaced.
  /// - param newChild: The new `forKeyword` to replace the node's
  ///                   current `forKeyword`, if present.
  public func withForKeyword(
    _ newChild: TokenSyntax?) -> ForInStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.forKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.forKeyword)
    return ForInStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var caseKeyword: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.caseKeyword)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `caseKeyword` replaced.
  /// - param newChild: The new `caseKeyword` to replace the node's
  ///                   current `caseKeyword`, if present.
  public func withCaseKeyword(
    _ newChild: TokenSyntax?) -> ForInStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.caseKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.caseKeyword)
    return ForInStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var pattern: PatternSyntax {
    let child = data.cachedChild(at: Cursor.pattern)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! PatternSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `pattern` replaced.
  /// - param newChild: The new `pattern` to replace the node's
  ///                   current `pattern`, if present.
  public func withPattern(
    _ newChild: PatternSyntax?) -> ForInStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.pattern)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.pattern)
    return ForInStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var typeAnnotation: TypeAnnotationSyntax? {
    let child = data.cachedChild(at: Cursor.typeAnnotation)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TypeAnnotationSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `typeAnnotation` replaced.
  /// - param newChild: The new `typeAnnotation` to replace the node's
  ///                   current `typeAnnotation`, if present.
  public func withTypeAnnotation(
    _ newChild: TypeAnnotationSyntax?) -> ForInStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.typeAnnotation)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.typeAnnotation)
    return ForInStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var inKeyword: TokenSyntax {
    let child = data.cachedChild(at: Cursor.inKeyword)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `inKeyword` replaced.
  /// - param newChild: The new `inKeyword` to replace the node's
  ///                   current `inKeyword`, if present.
  public func withInKeyword(
    _ newChild: TokenSyntax?) -> ForInStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.inKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.inKeyword)
    return ForInStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var sequenceExpr: ExprSyntax {
    let child = data.cachedChild(at: Cursor.sequenceExpr)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! ExprSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `sequenceExpr` replaced.
  /// - param newChild: The new `sequenceExpr` to replace the node's
  ///                   current `sequenceExpr`, if present.
  public func withSequenceExpr(
    _ newChild: ExprSyntax?) -> ForInStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.sequenceExpr)
    return ForInStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var whereClause: WhereClauseSyntax? {
    let child = data.cachedChild(at: Cursor.whereClause)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? WhereClauseSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `whereClause` replaced.
  /// - param newChild: The new `whereClause` to replace the node's
  ///                   current `whereClause`, if present.
  public func withWhereClause(
    _ newChild: WhereClauseSyntax?) -> ForInStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.whereClause)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.whereClause)
    return ForInStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var body: CodeBlockSyntax {
    let child = data.cachedChild(at: Cursor.body)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! CodeBlockSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `body` replaced.
  /// - param newChild: The new `body` to replace the node's
  ///                   current `body`, if present.
  public func withBody(
    _ newChild: CodeBlockSyntax?) -> ForInStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.codeBlock)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.body)
    return ForInStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `ForInStmtSyntax` nodes are equal to each other.
  public static func ==(lhs: ForInStmtSyntax, rhs: ForInStmtSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct SwitchStmtSyntax: StmtSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case labelName
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case labelColon
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case switchKeyword
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case expression
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case leftBrace
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case cases
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case rightBrace
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `SwitchStmtSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 7)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _labelName = raw[Cursor.identifierToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _labelNameTokenKind = _labelName.tokenKind else {
      fatalError("expected token child, got \(_labelName.kind)")
    }
    precondition([.identifier].contains(_labelNameTokenKind),
      "expected one of [.identifier] for 'labelName' " + 
      "in node of kind switchStmt")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _labelColon = raw[Cursor.colonToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _labelColonTokenKind = _labelColon.tokenKind else {
      fatalError("expected token child, got \(_labelColon.kind)")
    }
    precondition([.colon].contains(_labelColonTokenKind),
      "expected one of [.colon] for 'labelColon' " + 
      "in node of kind switchStmt")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _switchKeyword = raw[Cursor.switchToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _switchKeywordTokenKind = _switchKeyword.tokenKind else {
      fatalError("expected token child, got \(_switchKeyword.kind)")
    }
    precondition([.switchKeyword].contains(_switchKeywordTokenKind),
      "expected one of [.switchKeyword] for 'switchKeyword' " + 
      "in node of kind switchStmt")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _expression = raw[Cursor.expr]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_expression.kind == .expr,
                 "expected child of kind .expr, " +
                 "got \(_expression.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _leftBrace = raw[Cursor.leftBraceToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _leftBraceTokenKind = _leftBrace.tokenKind else {
      fatalError("expected token child, got \(_leftBrace.kind)")
    }
    precondition([.leftBrace].contains(_leftBraceTokenKind),
      "expected one of [.leftBrace] for 'leftBrace' " + 
      "in node of kind switchStmt")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _cases = raw[Cursor.switchCaseList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_cases.kind == .switchCaseList,
                 "expected child of kind .switchCaseList, " +
                 "got \(_cases.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _rightBrace = raw[Cursor.rightBraceToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _rightBraceTokenKind = _rightBrace.tokenKind else {
      fatalError("expected token child, got \(_rightBrace.kind)")
    }
    precondition([.rightBrace].contains(_rightBraceTokenKind),
      "expected one of [.rightBrace] for 'rightBrace' " + 
      "in node of kind switchStmt")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var labelName: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.labelName)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `labelName` replaced.
  /// - param newChild: The new `labelName` to replace the node's
  ///                   current `labelName`, if present.
  public func withLabelName(
    _ newChild: TokenSyntax?) -> SwitchStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.labelName)
    return SwitchStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var labelColon: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.labelColon)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `labelColon` replaced.
  /// - param newChild: The new `labelColon` to replace the node's
  ///                   current `labelColon`, if present.
  public func withLabelColon(
    _ newChild: TokenSyntax?) -> SwitchStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.colon)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.labelColon)
    return SwitchStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var switchKeyword: TokenSyntax {
    let child = data.cachedChild(at: Cursor.switchKeyword)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `switchKeyword` replaced.
  /// - param newChild: The new `switchKeyword` to replace the node's
  ///                   current `switchKeyword`, if present.
  public func withSwitchKeyword(
    _ newChild: TokenSyntax?) -> SwitchStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.switchKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.switchKeyword)
    return SwitchStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var expression: ExprSyntax {
    let child = data.cachedChild(at: Cursor.expression)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! ExprSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `expression` replaced.
  /// - param newChild: The new `expression` to replace the node's
  ///                   current `expression`, if present.
  public func withExpression(
    _ newChild: ExprSyntax?) -> SwitchStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.expression)
    return SwitchStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var leftBrace: TokenSyntax {
    let child = data.cachedChild(at: Cursor.leftBrace)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `leftBrace` replaced.
  /// - param newChild: The new `leftBrace` to replace the node's
  ///                   current `leftBrace`, if present.
  public func withLeftBrace(
    _ newChild: TokenSyntax?) -> SwitchStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftBrace)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.leftBrace)
    return SwitchStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var cases: SwitchCaseListSyntax {
    let child = data.cachedChild(at: Cursor.cases)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! SwitchCaseListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `Syntax` to the node's `cases`
  /// collection.
  /// - param element: The new `Syntax` to add to the node's
  ///                  `cases` collection.
  /// - returns: A copy of the receiver with the provided `Syntax`
  ///            appended to its `cases` collection.
  public func addSyntax(_ element: Syntax) -> SwitchStmtSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.cases] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.switchCaseList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.cases)
    return SwitchStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `cases` replaced.
  /// - param newChild: The new `cases` to replace the node's
  ///                   current `cases`, if present.
  public func withCases(
    _ newChild: SwitchCaseListSyntax?) -> SwitchStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.switchCaseList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.cases)
    return SwitchStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var rightBrace: TokenSyntax {
    let child = data.cachedChild(at: Cursor.rightBrace)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `rightBrace` replaced.
  /// - param newChild: The new `rightBrace` to replace the node's
  ///                   current `rightBrace`, if present.
  public func withRightBrace(
    _ newChild: TokenSyntax?) -> SwitchStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightBrace)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.rightBrace)
    return SwitchStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `SwitchStmtSyntax` nodes are equal to each other.
  public static func ==(lhs: SwitchStmtSyntax, rhs: SwitchStmtSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct DoStmtSyntax: StmtSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case labelName
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case labelColon
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case doKeyword
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case body
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case catchClauses
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `DoStmtSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 5)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _labelName = raw[Cursor.identifierToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _labelNameTokenKind = _labelName.tokenKind else {
      fatalError("expected token child, got \(_labelName.kind)")
    }
    precondition([.identifier].contains(_labelNameTokenKind),
      "expected one of [.identifier] for 'labelName' " + 
      "in node of kind doStmt")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _labelColon = raw[Cursor.colonToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _labelColonTokenKind = _labelColon.tokenKind else {
      fatalError("expected token child, got \(_labelColon.kind)")
    }
    precondition([.colon].contains(_labelColonTokenKind),
      "expected one of [.colon] for 'labelColon' " + 
      "in node of kind doStmt")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _doKeyword = raw[Cursor.doToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _doKeywordTokenKind = _doKeyword.tokenKind else {
      fatalError("expected token child, got \(_doKeyword.kind)")
    }
    precondition([.doKeyword].contains(_doKeywordTokenKind),
      "expected one of [.doKeyword] for 'doKeyword' " + 
      "in node of kind doStmt")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _body = raw[Cursor.codeBlock]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_body.kind == .codeBlock,
                 "expected child of kind .codeBlock, " +
                 "got \(_body.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _catchClauses = raw[Cursor.catchClauseList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_catchClauses.kind == .catchClauseList,
                 "expected child of kind .catchClauseList, " +
                 "got \(_catchClauses.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var labelName: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.labelName)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `labelName` replaced.
  /// - param newChild: The new `labelName` to replace the node's
  ///                   current `labelName`, if present.
  public func withLabelName(
    _ newChild: TokenSyntax?) -> DoStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.labelName)
    return DoStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var labelColon: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.labelColon)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `labelColon` replaced.
  /// - param newChild: The new `labelColon` to replace the node's
  ///                   current `labelColon`, if present.
  public func withLabelColon(
    _ newChild: TokenSyntax?) -> DoStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.colon)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.labelColon)
    return DoStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var doKeyword: TokenSyntax {
    let child = data.cachedChild(at: Cursor.doKeyword)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `doKeyword` replaced.
  /// - param newChild: The new `doKeyword` to replace the node's
  ///                   current `doKeyword`, if present.
  public func withDoKeyword(
    _ newChild: TokenSyntax?) -> DoStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.doKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.doKeyword)
    return DoStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var body: CodeBlockSyntax {
    let child = data.cachedChild(at: Cursor.body)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! CodeBlockSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `body` replaced.
  /// - param newChild: The new `body` to replace the node's
  ///                   current `body`, if present.
  public func withBody(
    _ newChild: CodeBlockSyntax?) -> DoStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.codeBlock)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.body)
    return DoStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var catchClauses: CatchClauseListSyntax? {
    let child = data.cachedChild(at: Cursor.catchClauses)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? CatchClauseListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `CatchClause` to the node's `catchClauses`
  /// collection.
  /// - param element: The new `CatchClause` to add to the node's
  ///                  `catchClauses` collection.
  /// - returns: A copy of the receiver with the provided `CatchClause`
  ///            appended to its `catchClauses` collection.
  public func addCatchClause(_ element: CatchClauseSyntax) -> DoStmtSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.catchClauses] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.catchClauseList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.catchClauses)
    return DoStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `catchClauses` replaced.
  /// - param newChild: The new `catchClauses` to replace the node's
  ///                   current `catchClauses`, if present.
  public func withCatchClauses(
    _ newChild: CatchClauseListSyntax?) -> DoStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.catchClauseList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.catchClauses)
    return DoStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `DoStmtSyntax` nodes are equal to each other.
  public static func ==(lhs: DoStmtSyntax, rhs: DoStmtSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct ReturnStmtSyntax: StmtSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case returnKeyword
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case expression
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `ReturnStmtSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 2)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _returnKeyword = raw[Cursor.returnToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _returnKeywordTokenKind = _returnKeyword.tokenKind else {
      fatalError("expected token child, got \(_returnKeyword.kind)")
    }
    precondition([.returnKeyword].contains(_returnKeywordTokenKind),
      "expected one of [.returnKeyword] for 'returnKeyword' " + 
      "in node of kind returnStmt")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _expression = raw[Cursor.expr]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_expression.kind == .expr,
                 "expected child of kind .expr, " +
                 "got \(_expression.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var returnKeyword: TokenSyntax {
    let child = data.cachedChild(at: Cursor.returnKeyword)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `returnKeyword` replaced.
  /// - param newChild: The new `returnKeyword` to replace the node's
  ///                   current `returnKeyword`, if present.
  public func withReturnKeyword(
    _ newChild: TokenSyntax?) -> ReturnStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.returnKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.returnKeyword)
    return ReturnStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var expression: ExprSyntax? {
    let child = data.cachedChild(at: Cursor.expression)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? ExprSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `expression` replaced.
  /// - param newChild: The new `expression` to replace the node's
  ///                   current `expression`, if present.
  public func withExpression(
    _ newChild: ExprSyntax?) -> ReturnStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.expression)
    return ReturnStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `ReturnStmtSyntax` nodes are equal to each other.
  public static func ==(lhs: ReturnStmtSyntax, rhs: ReturnStmtSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct YieldStmtSyntax: StmtSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case yieldKeyword
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case leftParen
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case expression
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case rightParen
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case semicolon
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `YieldStmtSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 5)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _yieldKeyword = raw[Cursor.yieldToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _yieldKeywordTokenKind = _yieldKeyword.tokenKind else {
      fatalError("expected token child, got \(_yieldKeyword.kind)")
    }
    precondition([.yield].contains(_yieldKeywordTokenKind),
      "expected one of [.yield] for 'yieldKeyword' " + 
      "in node of kind yieldStmt")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _leftParen = raw[Cursor.leftParenToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _leftParenTokenKind = _leftParen.tokenKind else {
      fatalError("expected token child, got \(_leftParen.kind)")
    }
    precondition([.leftParen].contains(_leftParenTokenKind),
      "expected one of [.leftParen] for 'leftParen' " + 
      "in node of kind yieldStmt")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _expression = raw[Cursor.expr]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_expression.kind == .expr,
                 "expected child of kind .expr, " +
                 "got \(_expression.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _rightParen = raw[Cursor.rightParenToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _rightParenTokenKind = _rightParen.tokenKind else {
      fatalError("expected token child, got \(_rightParen.kind)")
    }
    precondition([.rightParen].contains(_rightParenTokenKind),
      "expected one of [.rightParen] for 'rightParen' " + 
      "in node of kind yieldStmt")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _semicolon = raw[Cursor.semicolonToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _semicolonTokenKind = _semicolon.tokenKind else {
      fatalError("expected token child, got \(_semicolon.kind)")
    }
    precondition([.semicolon].contains(_semicolonTokenKind),
      "expected one of [.semicolon] for 'semicolon' " + 
      "in node of kind yieldStmt")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var yieldKeyword: TokenSyntax {
    let child = data.cachedChild(at: Cursor.yieldKeyword)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `yieldKeyword` replaced.
  /// - param newChild: The new `yieldKeyword` to replace the node's
  ///                   current `yieldKeyword`, if present.
  public func withYieldKeyword(
    _ newChild: TokenSyntax?) -> YieldStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.yield)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.yieldKeyword)
    return YieldStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var leftParen: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.leftParen)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `leftParen` replaced.
  /// - param newChild: The new `leftParen` to replace the node's
  ///                   current `leftParen`, if present.
  public func withLeftParen(
    _ newChild: TokenSyntax?) -> YieldStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftParen)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.leftParen)
    return YieldStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var expression: ExprSyntax {
    let child = data.cachedChild(at: Cursor.expression)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! ExprSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `expression` replaced.
  /// - param newChild: The new `expression` to replace the node's
  ///                   current `expression`, if present.
  public func withExpression(
    _ newChild: ExprSyntax?) -> YieldStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.expression)
    return YieldStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var rightParen: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.rightParen)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `rightParen` replaced.
  /// - param newChild: The new `rightParen` to replace the node's
  ///                   current `rightParen`, if present.
  public func withRightParen(
    _ newChild: TokenSyntax?) -> YieldStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightParen)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.rightParen)
    return YieldStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var semicolon: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.semicolon)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `semicolon` replaced.
  /// - param newChild: The new `semicolon` to replace the node's
  ///                   current `semicolon`, if present.
  public func withSemicolon(
    _ newChild: TokenSyntax?) -> YieldStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.semicolon)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.semicolon)
    return YieldStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `YieldStmtSyntax` nodes are equal to each other.
  public static func ==(lhs: YieldStmtSyntax, rhs: YieldStmtSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct FallthroughStmtSyntax: StmtSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case fallthroughKeyword
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `FallthroughStmtSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 1)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _fallthroughKeyword = raw[Cursor.fallthroughToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _fallthroughKeywordTokenKind = _fallthroughKeyword.tokenKind else {
      fatalError("expected token child, got \(_fallthroughKeyword.kind)")
    }
    precondition([.fallthroughKeyword].contains(_fallthroughKeywordTokenKind),
      "expected one of [.fallthroughKeyword] for 'fallthroughKeyword' " + 
      "in node of kind fallthroughStmt")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var fallthroughKeyword: TokenSyntax {
    let child = data.cachedChild(at: Cursor.fallthroughKeyword)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `fallthroughKeyword` replaced.
  /// - param newChild: The new `fallthroughKeyword` to replace the node's
  ///                   current `fallthroughKeyword`, if present.
  public func withFallthroughKeyword(
    _ newChild: TokenSyntax?) -> FallthroughStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.fallthroughKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.fallthroughKeyword)
    return FallthroughStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `FallthroughStmtSyntax` nodes are equal to each other.
  public static func ==(lhs: FallthroughStmtSyntax, rhs: FallthroughStmtSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct BreakStmtSyntax: StmtSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case breakKeyword
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case label
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `BreakStmtSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 2)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _breakKeyword = raw[Cursor.breakToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _breakKeywordTokenKind = _breakKeyword.tokenKind else {
      fatalError("expected token child, got \(_breakKeyword.kind)")
    }
    precondition([.breakKeyword].contains(_breakKeywordTokenKind),
      "expected one of [.breakKeyword] for 'breakKeyword' " + 
      "in node of kind breakStmt")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _label = raw[Cursor.identifierToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _labelTokenKind = _label.tokenKind else {
      fatalError("expected token child, got \(_label.kind)")
    }
    precondition([.identifier].contains(_labelTokenKind),
      "expected one of [.identifier] for 'label' " + 
      "in node of kind breakStmt")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var breakKeyword: TokenSyntax {
    let child = data.cachedChild(at: Cursor.breakKeyword)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `breakKeyword` replaced.
  /// - param newChild: The new `breakKeyword` to replace the node's
  ///                   current `breakKeyword`, if present.
  public func withBreakKeyword(
    _ newChild: TokenSyntax?) -> BreakStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.breakKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.breakKeyword)
    return BreakStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var label: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.label)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `label` replaced.
  /// - param newChild: The new `label` to replace the node's
  ///                   current `label`, if present.
  public func withLabel(
    _ newChild: TokenSyntax?) -> BreakStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.label)
    return BreakStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `BreakStmtSyntax` nodes are equal to each other.
  public static func ==(lhs: BreakStmtSyntax, rhs: BreakStmtSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct ConditionElementSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case condition
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case trailingComma
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `ConditionElementSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 2)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _condition = raw[Cursor.syntax]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_condition.kind == .syntax,
                 "expected child of kind .syntax, " +
                 "got \(_condition.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _trailingComma = raw[Cursor.commaToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _trailingCommaTokenKind = _trailingComma.tokenKind else {
      fatalError("expected token child, got \(_trailingComma.kind)")
    }
    precondition([.comma].contains(_trailingCommaTokenKind),
      "expected one of [.comma] for 'trailingComma' " + 
      "in node of kind conditionElement")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var condition: Syntax {
    let child = data.cachedChild(at: Cursor.condition)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) 
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `condition` replaced.
  /// - param newChild: The new `condition` to replace the node's
  ///                   current `condition`, if present.
  public func withCondition(
    _ newChild: Syntax?) -> ConditionElementSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.unknown)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.condition)
    return ConditionElementSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var trailingComma: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.trailingComma)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `trailingComma` replaced.
  /// - param newChild: The new `trailingComma` to replace the node's
  ///                   current `trailingComma`, if present.
  public func withTrailingComma(
    _ newChild: TokenSyntax?) -> ConditionElementSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.comma)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.trailingComma)
    return ConditionElementSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `ConditionElementSyntax` nodes are equal to each other.
  public static func ==(lhs: ConditionElementSyntax, rhs: ConditionElementSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct AvailabilityConditionSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case poundAvailableKeyword
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case leftParen
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case availabilitySpec
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case rightParen
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `AvailabilityConditionSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 4)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _poundAvailableKeyword = raw[Cursor.poundAvailableToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _poundAvailableKeywordTokenKind = _poundAvailableKeyword.tokenKind else {
      fatalError("expected token child, got \(_poundAvailableKeyword.kind)")
    }
    precondition([.poundAvailableKeyword].contains(_poundAvailableKeywordTokenKind),
      "expected one of [.poundAvailableKeyword] for 'poundAvailableKeyword' " + 
      "in node of kind availabilityCondition")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _leftParen = raw[Cursor.leftParenToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _leftParenTokenKind = _leftParen.tokenKind else {
      fatalError("expected token child, got \(_leftParen.kind)")
    }
    precondition([.leftParen].contains(_leftParenTokenKind),
      "expected one of [.leftParen] for 'leftParen' " + 
      "in node of kind availabilityCondition")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _availabilitySpec = raw[Cursor.availabilitySpecList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_availabilitySpec.kind == .availabilitySpecList,
                 "expected child of kind .availabilitySpecList, " +
                 "got \(_availabilitySpec.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _rightParen = raw[Cursor.rightParenToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _rightParenTokenKind = _rightParen.tokenKind else {
      fatalError("expected token child, got \(_rightParen.kind)")
    }
    precondition([.rightParen].contains(_rightParenTokenKind),
      "expected one of [.rightParen] for 'rightParen' " + 
      "in node of kind availabilityCondition")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var poundAvailableKeyword: TokenSyntax {
    let child = data.cachedChild(at: Cursor.poundAvailableKeyword)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `poundAvailableKeyword` replaced.
  /// - param newChild: The new `poundAvailableKeyword` to replace the node's
  ///                   current `poundAvailableKeyword`, if present.
  public func withPoundAvailableKeyword(
    _ newChild: TokenSyntax?) -> AvailabilityConditionSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.poundAvailableKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.poundAvailableKeyword)
    return AvailabilityConditionSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var leftParen: TokenSyntax {
    let child = data.cachedChild(at: Cursor.leftParen)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `leftParen` replaced.
  /// - param newChild: The new `leftParen` to replace the node's
  ///                   current `leftParen`, if present.
  public func withLeftParen(
    _ newChild: TokenSyntax?) -> AvailabilityConditionSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftParen)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.leftParen)
    return AvailabilityConditionSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var availabilitySpec: AvailabilitySpecListSyntax {
    let child = data.cachedChild(at: Cursor.availabilitySpec)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! AvailabilitySpecListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `AvailabilityArgument` to the node's `availabilitySpec`
  /// collection.
  /// - param element: The new `AvailabilityArgument` to add to the node's
  ///                  `availabilitySpec` collection.
  /// - returns: A copy of the receiver with the provided `AvailabilityArgument`
  ///            appended to its `availabilitySpec` collection.
  public func addAvailabilityArgument(_ element: AvailabilityArgumentSyntax) -> AvailabilityConditionSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.availabilitySpec] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.availabilitySpecList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.availabilitySpec)
    return AvailabilityConditionSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `availabilitySpec` replaced.
  /// - param newChild: The new `availabilitySpec` to replace the node's
  ///                   current `availabilitySpec`, if present.
  public func withAvailabilitySpec(
    _ newChild: AvailabilitySpecListSyntax?) -> AvailabilityConditionSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.availabilitySpecList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.availabilitySpec)
    return AvailabilityConditionSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var rightParen: TokenSyntax {
    let child = data.cachedChild(at: Cursor.rightParen)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `rightParen` replaced.
  /// - param newChild: The new `rightParen` to replace the node's
  ///                   current `rightParen`, if present.
  public func withRightParen(
    _ newChild: TokenSyntax?) -> AvailabilityConditionSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightParen)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.rightParen)
    return AvailabilityConditionSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `AvailabilityConditionSyntax` nodes are equal to each other.
  public static func ==(lhs: AvailabilityConditionSyntax, rhs: AvailabilityConditionSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct MatchingPatternConditionSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case caseKeyword
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case pattern
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case typeAnnotation
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case initializer
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `MatchingPatternConditionSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 4)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _caseKeyword = raw[Cursor.caseToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _caseKeywordTokenKind = _caseKeyword.tokenKind else {
      fatalError("expected token child, got \(_caseKeyword.kind)")
    }
    precondition([.caseKeyword].contains(_caseKeywordTokenKind),
      "expected one of [.caseKeyword] for 'caseKeyword' " + 
      "in node of kind matchingPatternCondition")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _pattern = raw[Cursor.pattern]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_pattern.kind == .pattern,
                 "expected child of kind .pattern, " +
                 "got \(_pattern.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _typeAnnotation = raw[Cursor.typeAnnotation]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_typeAnnotation.kind == .typeAnnotation,
                 "expected child of kind .typeAnnotation, " +
                 "got \(_typeAnnotation.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _initializer = raw[Cursor.initializerClause]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_initializer.kind == .initializerClause,
                 "expected child of kind .initializerClause, " +
                 "got \(_initializer.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var caseKeyword: TokenSyntax {
    let child = data.cachedChild(at: Cursor.caseKeyword)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `caseKeyword` replaced.
  /// - param newChild: The new `caseKeyword` to replace the node's
  ///                   current `caseKeyword`, if present.
  public func withCaseKeyword(
    _ newChild: TokenSyntax?) -> MatchingPatternConditionSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.caseKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.caseKeyword)
    return MatchingPatternConditionSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var pattern: PatternSyntax {
    let child = data.cachedChild(at: Cursor.pattern)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! PatternSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `pattern` replaced.
  /// - param newChild: The new `pattern` to replace the node's
  ///                   current `pattern`, if present.
  public func withPattern(
    _ newChild: PatternSyntax?) -> MatchingPatternConditionSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.pattern)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.pattern)
    return MatchingPatternConditionSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var typeAnnotation: TypeAnnotationSyntax? {
    let child = data.cachedChild(at: Cursor.typeAnnotation)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TypeAnnotationSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `typeAnnotation` replaced.
  /// - param newChild: The new `typeAnnotation` to replace the node's
  ///                   current `typeAnnotation`, if present.
  public func withTypeAnnotation(
    _ newChild: TypeAnnotationSyntax?) -> MatchingPatternConditionSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.typeAnnotation)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.typeAnnotation)
    return MatchingPatternConditionSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var initializer: InitializerClauseSyntax {
    let child = data.cachedChild(at: Cursor.initializer)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! InitializerClauseSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `initializer` replaced.
  /// - param newChild: The new `initializer` to replace the node's
  ///                   current `initializer`, if present.
  public func withInitializer(
    _ newChild: InitializerClauseSyntax?) -> MatchingPatternConditionSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.initializerClause)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.initializer)
    return MatchingPatternConditionSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `MatchingPatternConditionSyntax` nodes are equal to each other.
  public static func ==(lhs: MatchingPatternConditionSyntax, rhs: MatchingPatternConditionSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct OptionalBindingConditionSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case letOrVarKeyword
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case pattern
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case typeAnnotation
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case initializer
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `OptionalBindingConditionSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 4)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _letOrVarKeyword = raw[Cursor.token]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _letOrVarKeywordTokenKind = _letOrVarKeyword.tokenKind else {
      fatalError("expected token child, got \(_letOrVarKeyword.kind)")
    }
    precondition([.letKeyword, .varKeyword].contains(_letOrVarKeywordTokenKind),
      "expected one of [.letKeyword, .varKeyword] for 'letOrVarKeyword' " + 
      "in node of kind optionalBindingCondition")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _pattern = raw[Cursor.pattern]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_pattern.kind == .pattern,
                 "expected child of kind .pattern, " +
                 "got \(_pattern.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _typeAnnotation = raw[Cursor.typeAnnotation]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_typeAnnotation.kind == .typeAnnotation,
                 "expected child of kind .typeAnnotation, " +
                 "got \(_typeAnnotation.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _initializer = raw[Cursor.initializerClause]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_initializer.kind == .initializerClause,
                 "expected child of kind .initializerClause, " +
                 "got \(_initializer.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var letOrVarKeyword: TokenSyntax {
    let child = data.cachedChild(at: Cursor.letOrVarKeyword)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `letOrVarKeyword` replaced.
  /// - param newChild: The new `letOrVarKeyword` to replace the node's
  ///                   current `letOrVarKeyword`, if present.
  public func withLetOrVarKeyword(
    _ newChild: TokenSyntax?) -> OptionalBindingConditionSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.letKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.letOrVarKeyword)
    return OptionalBindingConditionSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var pattern: PatternSyntax {
    let child = data.cachedChild(at: Cursor.pattern)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! PatternSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `pattern` replaced.
  /// - param newChild: The new `pattern` to replace the node's
  ///                   current `pattern`, if present.
  public func withPattern(
    _ newChild: PatternSyntax?) -> OptionalBindingConditionSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.pattern)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.pattern)
    return OptionalBindingConditionSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var typeAnnotation: TypeAnnotationSyntax? {
    let child = data.cachedChild(at: Cursor.typeAnnotation)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TypeAnnotationSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `typeAnnotation` replaced.
  /// - param newChild: The new `typeAnnotation` to replace the node's
  ///                   current `typeAnnotation`, if present.
  public func withTypeAnnotation(
    _ newChild: TypeAnnotationSyntax?) -> OptionalBindingConditionSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.typeAnnotation)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.typeAnnotation)
    return OptionalBindingConditionSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var initializer: InitializerClauseSyntax {
    let child = data.cachedChild(at: Cursor.initializer)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! InitializerClauseSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `initializer` replaced.
  /// - param newChild: The new `initializer` to replace the node's
  ///                   current `initializer`, if present.
  public func withInitializer(
    _ newChild: InitializerClauseSyntax?) -> OptionalBindingConditionSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.initializerClause)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.initializer)
    return OptionalBindingConditionSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `OptionalBindingConditionSyntax` nodes are equal to each other.
  public static func ==(lhs: OptionalBindingConditionSyntax, rhs: OptionalBindingConditionSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct DeclarationStmtSyntax: StmtSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case declaration
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `DeclarationStmtSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 1)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _declaration = raw[Cursor.decl]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_declaration.kind == .decl,
                 "expected child of kind .decl, " +
                 "got \(_declaration.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var declaration: DeclSyntax {
    let child = data.cachedChild(at: Cursor.declaration)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! DeclSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `declaration` replaced.
  /// - param newChild: The new `declaration` to replace the node's
  ///                   current `declaration`, if present.
  public func withDeclaration(
    _ newChild: DeclSyntax?) -> DeclarationStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.decl)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.declaration)
    return DeclarationStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `DeclarationStmtSyntax` nodes are equal to each other.
  public static func ==(lhs: DeclarationStmtSyntax, rhs: DeclarationStmtSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct ThrowStmtSyntax: StmtSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case throwKeyword
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case expression
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `ThrowStmtSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 2)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _throwKeyword = raw[Cursor.throwToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _throwKeywordTokenKind = _throwKeyword.tokenKind else {
      fatalError("expected token child, got \(_throwKeyword.kind)")
    }
    precondition([.throwKeyword].contains(_throwKeywordTokenKind),
      "expected one of [.throwKeyword] for 'throwKeyword' " + 
      "in node of kind throwStmt")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _expression = raw[Cursor.expr]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_expression.kind == .expr,
                 "expected child of kind .expr, " +
                 "got \(_expression.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var throwKeyword: TokenSyntax {
    let child = data.cachedChild(at: Cursor.throwKeyword)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `throwKeyword` replaced.
  /// - param newChild: The new `throwKeyword` to replace the node's
  ///                   current `throwKeyword`, if present.
  public func withThrowKeyword(
    _ newChild: TokenSyntax?) -> ThrowStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.throwKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.throwKeyword)
    return ThrowStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var expression: ExprSyntax {
    let child = data.cachedChild(at: Cursor.expression)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! ExprSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `expression` replaced.
  /// - param newChild: The new `expression` to replace the node's
  ///                   current `expression`, if present.
  public func withExpression(
    _ newChild: ExprSyntax?) -> ThrowStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.expression)
    return ThrowStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `ThrowStmtSyntax` nodes are equal to each other.
  public static func ==(lhs: ThrowStmtSyntax, rhs: ThrowStmtSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct IfStmtSyntax: StmtSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case labelName
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case labelColon
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case ifKeyword
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case conditions
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case body
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case elseKeyword
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case elseBody
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `IfStmtSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 7)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _labelName = raw[Cursor.identifierToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _labelNameTokenKind = _labelName.tokenKind else {
      fatalError("expected token child, got \(_labelName.kind)")
    }
    precondition([.identifier].contains(_labelNameTokenKind),
      "expected one of [.identifier] for 'labelName' " + 
      "in node of kind ifStmt")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _labelColon = raw[Cursor.colonToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _labelColonTokenKind = _labelColon.tokenKind else {
      fatalError("expected token child, got \(_labelColon.kind)")
    }
    precondition([.colon].contains(_labelColonTokenKind),
      "expected one of [.colon] for 'labelColon' " + 
      "in node of kind ifStmt")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _ifKeyword = raw[Cursor.ifToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _ifKeywordTokenKind = _ifKeyword.tokenKind else {
      fatalError("expected token child, got \(_ifKeyword.kind)")
    }
    precondition([.ifKeyword].contains(_ifKeywordTokenKind),
      "expected one of [.ifKeyword] for 'ifKeyword' " + 
      "in node of kind ifStmt")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _conditions = raw[Cursor.conditionElementList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_conditions.kind == .conditionElementList,
                 "expected child of kind .conditionElementList, " +
                 "got \(_conditions.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _body = raw[Cursor.codeBlock]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_body.kind == .codeBlock,
                 "expected child of kind .codeBlock, " +
                 "got \(_body.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _elseKeyword = raw[Cursor.elseToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _elseKeywordTokenKind = _elseKeyword.tokenKind else {
      fatalError("expected token child, got \(_elseKeyword.kind)")
    }
    precondition([.elseKeyword].contains(_elseKeywordTokenKind),
      "expected one of [.elseKeyword] for 'elseKeyword' " + 
      "in node of kind ifStmt")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _elseBody = raw[Cursor.syntax]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_elseBody.kind == .syntax,
                 "expected child of kind .syntax, " +
                 "got \(_elseBody.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var labelName: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.labelName)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `labelName` replaced.
  /// - param newChild: The new `labelName` to replace the node's
  ///                   current `labelName`, if present.
  public func withLabelName(
    _ newChild: TokenSyntax?) -> IfStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.labelName)
    return IfStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var labelColon: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.labelColon)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `labelColon` replaced.
  /// - param newChild: The new `labelColon` to replace the node's
  ///                   current `labelColon`, if present.
  public func withLabelColon(
    _ newChild: TokenSyntax?) -> IfStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.colon)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.labelColon)
    return IfStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var ifKeyword: TokenSyntax {
    let child = data.cachedChild(at: Cursor.ifKeyword)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `ifKeyword` replaced.
  /// - param newChild: The new `ifKeyword` to replace the node's
  ///                   current `ifKeyword`, if present.
  public func withIfKeyword(
    _ newChild: TokenSyntax?) -> IfStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.ifKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.ifKeyword)
    return IfStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var conditions: ConditionElementListSyntax {
    let child = data.cachedChild(at: Cursor.conditions)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! ConditionElementListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `ConditionElement` to the node's `conditions`
  /// collection.
  /// - param element: The new `ConditionElement` to add to the node's
  ///                  `conditions` collection.
  /// - returns: A copy of the receiver with the provided `ConditionElement`
  ///            appended to its `conditions` collection.
  public func addConditionElement(_ element: ConditionElementSyntax) -> IfStmtSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.conditions] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.conditionElementList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.conditions)
    return IfStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `conditions` replaced.
  /// - param newChild: The new `conditions` to replace the node's
  ///                   current `conditions`, if present.
  public func withConditions(
    _ newChild: ConditionElementListSyntax?) -> IfStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.conditionElementList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.conditions)
    return IfStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var body: CodeBlockSyntax {
    let child = data.cachedChild(at: Cursor.body)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! CodeBlockSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `body` replaced.
  /// - param newChild: The new `body` to replace the node's
  ///                   current `body`, if present.
  public func withBody(
    _ newChild: CodeBlockSyntax?) -> IfStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.codeBlock)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.body)
    return IfStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var elseKeyword: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.elseKeyword)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `elseKeyword` replaced.
  /// - param newChild: The new `elseKeyword` to replace the node's
  ///                   current `elseKeyword`, if present.
  public func withElseKeyword(
    _ newChild: TokenSyntax?) -> IfStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.elseKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.elseKeyword)
    return IfStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var elseBody: Syntax? {
    let child = data.cachedChild(at: Cursor.elseBody)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) 
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `elseBody` replaced.
  /// - param newChild: The new `elseBody` to replace the node's
  ///                   current `elseBody`, if present.
  public func withElseBody(
    _ newChild: Syntax?) -> IfStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.unknown)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.elseBody)
    return IfStmtSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `IfStmtSyntax` nodes are equal to each other.
  public static func ==(lhs: IfStmtSyntax, rhs: IfStmtSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct ElseIfContinuationSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case ifStatement
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `ElseIfContinuationSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 1)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _ifStatement = raw[Cursor.ifStmt]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_ifStatement.kind == .ifStmt,
                 "expected child of kind .ifStmt, " +
                 "got \(_ifStatement.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var ifStatement: IfStmtSyntax {
    let child = data.cachedChild(at: Cursor.ifStatement)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! IfStmtSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `ifStatement` replaced.
  /// - param newChild: The new `ifStatement` to replace the node's
  ///                   current `ifStatement`, if present.
  public func withIfStatement(
    _ newChild: IfStmtSyntax?) -> ElseIfContinuationSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.ifStmt)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.ifStatement)
    return ElseIfContinuationSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `ElseIfContinuationSyntax` nodes are equal to each other.
  public static func ==(lhs: ElseIfContinuationSyntax, rhs: ElseIfContinuationSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct ElseBlockSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case elseKeyword
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case body
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `ElseBlockSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 2)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _elseKeyword = raw[Cursor.elseToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _elseKeywordTokenKind = _elseKeyword.tokenKind else {
      fatalError("expected token child, got \(_elseKeyword.kind)")
    }
    precondition([.elseKeyword].contains(_elseKeywordTokenKind),
      "expected one of [.elseKeyword] for 'elseKeyword' " + 
      "in node of kind elseBlock")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _body = raw[Cursor.codeBlock]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_body.kind == .codeBlock,
                 "expected child of kind .codeBlock, " +
                 "got \(_body.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var elseKeyword: TokenSyntax {
    let child = data.cachedChild(at: Cursor.elseKeyword)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `elseKeyword` replaced.
  /// - param newChild: The new `elseKeyword` to replace the node's
  ///                   current `elseKeyword`, if present.
  public func withElseKeyword(
    _ newChild: TokenSyntax?) -> ElseBlockSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.elseKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.elseKeyword)
    return ElseBlockSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var body: CodeBlockSyntax {
    let child = data.cachedChild(at: Cursor.body)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! CodeBlockSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `body` replaced.
  /// - param newChild: The new `body` to replace the node's
  ///                   current `body`, if present.
  public func withBody(
    _ newChild: CodeBlockSyntax?) -> ElseBlockSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.codeBlock)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.body)
    return ElseBlockSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `ElseBlockSyntax` nodes are equal to each other.
  public static func ==(lhs: ElseBlockSyntax, rhs: ElseBlockSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct SwitchCaseSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case unknownAttr
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case label
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case statements
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `SwitchCaseSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 3)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _unknownAttr = raw[Cursor.attribute]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_unknownAttr.kind == .attribute,
                 "expected child of kind .attribute, " +
                 "got \(_unknownAttr.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _label = raw[Cursor.syntax]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_label.kind == .syntax,
                 "expected child of kind .syntax, " +
                 "got \(_label.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _statements = raw[Cursor.codeBlockItemList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_statements.kind == .codeBlockItemList,
                 "expected child of kind .codeBlockItemList, " +
                 "got \(_statements.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var unknownAttr: AttributeSyntax? {
    let child = data.cachedChild(at: Cursor.unknownAttr)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? AttributeSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `unknownAttr` replaced.
  /// - param newChild: The new `unknownAttr` to replace the node's
  ///                   current `unknownAttr`, if present.
  public func withUnknownAttr(
    _ newChild: AttributeSyntax?) -> SwitchCaseSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.attribute)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.unknownAttr)
    return SwitchCaseSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var label: Syntax {
    let child = data.cachedChild(at: Cursor.label)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) 
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `label` replaced.
  /// - param newChild: The new `label` to replace the node's
  ///                   current `label`, if present.
  public func withLabel(
    _ newChild: Syntax?) -> SwitchCaseSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.unknown)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.label)
    return SwitchCaseSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var statements: CodeBlockItemListSyntax {
    let child = data.cachedChild(at: Cursor.statements)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! CodeBlockItemListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `CodeBlockItem` to the node's `statements`
  /// collection.
  /// - param element: The new `CodeBlockItem` to add to the node's
  ///                  `statements` collection.
  /// - returns: A copy of the receiver with the provided `CodeBlockItem`
  ///            appended to its `statements` collection.
  public func addCodeBlockItem(_ element: CodeBlockItemSyntax) -> SwitchCaseSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.statements] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.codeBlockItemList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.statements)
    return SwitchCaseSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `statements` replaced.
  /// - param newChild: The new `statements` to replace the node's
  ///                   current `statements`, if present.
  public func withStatements(
    _ newChild: CodeBlockItemListSyntax?) -> SwitchCaseSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.codeBlockItemList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.statements)
    return SwitchCaseSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `SwitchCaseSyntax` nodes are equal to each other.
  public static func ==(lhs: SwitchCaseSyntax, rhs: SwitchCaseSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct SwitchDefaultLabelSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case defaultKeyword
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case colon
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `SwitchDefaultLabelSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 2)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _defaultKeyword = raw[Cursor.defaultToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _defaultKeywordTokenKind = _defaultKeyword.tokenKind else {
      fatalError("expected token child, got \(_defaultKeyword.kind)")
    }
    precondition([.defaultKeyword].contains(_defaultKeywordTokenKind),
      "expected one of [.defaultKeyword] for 'defaultKeyword' " + 
      "in node of kind switchDefaultLabel")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _colon = raw[Cursor.colonToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _colonTokenKind = _colon.tokenKind else {
      fatalError("expected token child, got \(_colon.kind)")
    }
    precondition([.colon].contains(_colonTokenKind),
      "expected one of [.colon] for 'colon' " + 
      "in node of kind switchDefaultLabel")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var defaultKeyword: TokenSyntax {
    let child = data.cachedChild(at: Cursor.defaultKeyword)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `defaultKeyword` replaced.
  /// - param newChild: The new `defaultKeyword` to replace the node's
  ///                   current `defaultKeyword`, if present.
  public func withDefaultKeyword(
    _ newChild: TokenSyntax?) -> SwitchDefaultLabelSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.defaultKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.defaultKeyword)
    return SwitchDefaultLabelSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var colon: TokenSyntax {
    let child = data.cachedChild(at: Cursor.colon)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `colon` replaced.
  /// - param newChild: The new `colon` to replace the node's
  ///                   current `colon`, if present.
  public func withColon(
    _ newChild: TokenSyntax?) -> SwitchDefaultLabelSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.colon)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.colon)
    return SwitchDefaultLabelSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `SwitchDefaultLabelSyntax` nodes are equal to each other.
  public static func ==(lhs: SwitchDefaultLabelSyntax, rhs: SwitchDefaultLabelSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct CaseItemSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case pattern
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case whereClause
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case trailingComma
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `CaseItemSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 3)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _pattern = raw[Cursor.pattern]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_pattern.kind == .pattern,
                 "expected child of kind .pattern, " +
                 "got \(_pattern.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _whereClause = raw[Cursor.whereClause]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_whereClause.kind == .whereClause,
                 "expected child of kind .whereClause, " +
                 "got \(_whereClause.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _trailingComma = raw[Cursor.commaToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _trailingCommaTokenKind = _trailingComma.tokenKind else {
      fatalError("expected token child, got \(_trailingComma.kind)")
    }
    precondition([.comma].contains(_trailingCommaTokenKind),
      "expected one of [.comma] for 'trailingComma' " + 
      "in node of kind caseItem")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var pattern: PatternSyntax {
    let child = data.cachedChild(at: Cursor.pattern)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! PatternSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `pattern` replaced.
  /// - param newChild: The new `pattern` to replace the node's
  ///                   current `pattern`, if present.
  public func withPattern(
    _ newChild: PatternSyntax?) -> CaseItemSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.pattern)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.pattern)
    return CaseItemSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var whereClause: WhereClauseSyntax? {
    let child = data.cachedChild(at: Cursor.whereClause)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? WhereClauseSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `whereClause` replaced.
  /// - param newChild: The new `whereClause` to replace the node's
  ///                   current `whereClause`, if present.
  public func withWhereClause(
    _ newChild: WhereClauseSyntax?) -> CaseItemSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.whereClause)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.whereClause)
    return CaseItemSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var trailingComma: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.trailingComma)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `trailingComma` replaced.
  /// - param newChild: The new `trailingComma` to replace the node's
  ///                   current `trailingComma`, if present.
  public func withTrailingComma(
    _ newChild: TokenSyntax?) -> CaseItemSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.comma)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.trailingComma)
    return CaseItemSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `CaseItemSyntax` nodes are equal to each other.
  public static func ==(lhs: CaseItemSyntax, rhs: CaseItemSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct SwitchCaseLabelSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case caseKeyword
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case caseItems
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case colon
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `SwitchCaseLabelSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 3)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _caseKeyword = raw[Cursor.caseToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _caseKeywordTokenKind = _caseKeyword.tokenKind else {
      fatalError("expected token child, got \(_caseKeyword.kind)")
    }
    precondition([.caseKeyword].contains(_caseKeywordTokenKind),
      "expected one of [.caseKeyword] for 'caseKeyword' " + 
      "in node of kind switchCaseLabel")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _caseItems = raw[Cursor.caseItemList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_caseItems.kind == .caseItemList,
                 "expected child of kind .caseItemList, " +
                 "got \(_caseItems.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _colon = raw[Cursor.colonToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _colonTokenKind = _colon.tokenKind else {
      fatalError("expected token child, got \(_colon.kind)")
    }
    precondition([.colon].contains(_colonTokenKind),
      "expected one of [.colon] for 'colon' " + 
      "in node of kind switchCaseLabel")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var caseKeyword: TokenSyntax {
    let child = data.cachedChild(at: Cursor.caseKeyword)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `caseKeyword` replaced.
  /// - param newChild: The new `caseKeyword` to replace the node's
  ///                   current `caseKeyword`, if present.
  public func withCaseKeyword(
    _ newChild: TokenSyntax?) -> SwitchCaseLabelSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.caseKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.caseKeyword)
    return SwitchCaseLabelSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var caseItems: CaseItemListSyntax {
    let child = data.cachedChild(at: Cursor.caseItems)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! CaseItemListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `CaseItem` to the node's `caseItems`
  /// collection.
  /// - param element: The new `CaseItem` to add to the node's
  ///                  `caseItems` collection.
  /// - returns: A copy of the receiver with the provided `CaseItem`
  ///            appended to its `caseItems` collection.
  public func addCaseItem(_ element: CaseItemSyntax) -> SwitchCaseLabelSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.caseItems] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.caseItemList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.caseItems)
    return SwitchCaseLabelSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `caseItems` replaced.
  /// - param newChild: The new `caseItems` to replace the node's
  ///                   current `caseItems`, if present.
  public func withCaseItems(
    _ newChild: CaseItemListSyntax?) -> SwitchCaseLabelSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.caseItemList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.caseItems)
    return SwitchCaseLabelSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var colon: TokenSyntax {
    let child = data.cachedChild(at: Cursor.colon)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `colon` replaced.
  /// - param newChild: The new `colon` to replace the node's
  ///                   current `colon`, if present.
  public func withColon(
    _ newChild: TokenSyntax?) -> SwitchCaseLabelSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.colon)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.colon)
    return SwitchCaseLabelSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `SwitchCaseLabelSyntax` nodes are equal to each other.
  public static func ==(lhs: SwitchCaseLabelSyntax, rhs: SwitchCaseLabelSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct CatchClauseSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case catchKeyword
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case pattern
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case whereClause
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case body
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `CatchClauseSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 4)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _catchKeyword = raw[Cursor.catchToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _catchKeywordTokenKind = _catchKeyword.tokenKind else {
      fatalError("expected token child, got \(_catchKeyword.kind)")
    }
    precondition([.catchKeyword].contains(_catchKeywordTokenKind),
      "expected one of [.catchKeyword] for 'catchKeyword' " + 
      "in node of kind catchClause")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _pattern = raw[Cursor.pattern]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_pattern.kind == .pattern,
                 "expected child of kind .pattern, " +
                 "got \(_pattern.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _whereClause = raw[Cursor.whereClause]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_whereClause.kind == .whereClause,
                 "expected child of kind .whereClause, " +
                 "got \(_whereClause.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _body = raw[Cursor.codeBlock]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_body.kind == .codeBlock,
                 "expected child of kind .codeBlock, " +
                 "got \(_body.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var catchKeyword: TokenSyntax {
    let child = data.cachedChild(at: Cursor.catchKeyword)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `catchKeyword` replaced.
  /// - param newChild: The new `catchKeyword` to replace the node's
  ///                   current `catchKeyword`, if present.
  public func withCatchKeyword(
    _ newChild: TokenSyntax?) -> CatchClauseSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.catchKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.catchKeyword)
    return CatchClauseSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var pattern: PatternSyntax? {
    let child = data.cachedChild(at: Cursor.pattern)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? PatternSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `pattern` replaced.
  /// - param newChild: The new `pattern` to replace the node's
  ///                   current `pattern`, if present.
  public func withPattern(
    _ newChild: PatternSyntax?) -> CatchClauseSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.pattern)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.pattern)
    return CatchClauseSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var whereClause: WhereClauseSyntax? {
    let child = data.cachedChild(at: Cursor.whereClause)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? WhereClauseSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `whereClause` replaced.
  /// - param newChild: The new `whereClause` to replace the node's
  ///                   current `whereClause`, if present.
  public func withWhereClause(
    _ newChild: WhereClauseSyntax?) -> CatchClauseSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.whereClause)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.whereClause)
    return CatchClauseSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var body: CodeBlockSyntax {
    let child = data.cachedChild(at: Cursor.body)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! CodeBlockSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `body` replaced.
  /// - param newChild: The new `body` to replace the node's
  ///                   current `body`, if present.
  public func withBody(
    _ newChild: CodeBlockSyntax?) -> CatchClauseSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.codeBlock)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.body)
    return CatchClauseSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `CatchClauseSyntax` nodes are equal to each other.
  public static func ==(lhs: CatchClauseSyntax, rhs: CatchClauseSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct GenericWhereClauseSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case whereKeyword
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case requirementList
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `GenericWhereClauseSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 2)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _whereKeyword = raw[Cursor.whereToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _whereKeywordTokenKind = _whereKeyword.tokenKind else {
      fatalError("expected token child, got \(_whereKeyword.kind)")
    }
    precondition([.whereKeyword].contains(_whereKeywordTokenKind),
      "expected one of [.whereKeyword] for 'whereKeyword' " + 
      "in node of kind genericWhereClause")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _requirementList = raw[Cursor.genericRequirementList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_requirementList.kind == .genericRequirementList,
                 "expected child of kind .genericRequirementList, " +
                 "got \(_requirementList.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var whereKeyword: TokenSyntax {
    let child = data.cachedChild(at: Cursor.whereKeyword)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `whereKeyword` replaced.
  /// - param newChild: The new `whereKeyword` to replace the node's
  ///                   current `whereKeyword`, if present.
  public func withWhereKeyword(
    _ newChild: TokenSyntax?) -> GenericWhereClauseSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.whereKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.whereKeyword)
    return GenericWhereClauseSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var requirementList: GenericRequirementListSyntax {
    let child = data.cachedChild(at: Cursor.requirementList)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! GenericRequirementListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `GenericRequirement` to the node's `requirementList`
  /// collection.
  /// - param element: The new `GenericRequirement` to add to the node's
  ///                  `requirementList` collection.
  /// - returns: A copy of the receiver with the provided `GenericRequirement`
  ///            appended to its `requirementList` collection.
  public func addGenericRequirement(_ element: Syntax) -> GenericWhereClauseSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.requirementList] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.genericRequirementList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.requirementList)
    return GenericWhereClauseSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `requirementList` replaced.
  /// - param newChild: The new `requirementList` to replace the node's
  ///                   current `requirementList`, if present.
  public func withRequirementList(
    _ newChild: GenericRequirementListSyntax?) -> GenericWhereClauseSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.genericRequirementList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.requirementList)
    return GenericWhereClauseSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `GenericWhereClauseSyntax` nodes are equal to each other.
  public static func ==(lhs: GenericWhereClauseSyntax, rhs: GenericWhereClauseSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct SameTypeRequirementSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case leftTypeIdentifier
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case equalityToken
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case rightTypeIdentifier
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case trailingComma
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `SameTypeRequirementSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 4)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _leftTypeIdentifier = raw[Cursor.type]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_leftTypeIdentifier.kind == .type,
                 "expected child of kind .type, " +
                 "got \(_leftTypeIdentifier.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _equalityToken = raw[Cursor.token]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _equalityTokenTokenKind = _equalityToken.tokenKind else {
      fatalError("expected token child, got \(_equalityToken.kind)")
    }
    precondition([.spacedBinaryOperator, .unspacedBinaryOperator].contains(_equalityTokenTokenKind),
      "expected one of [.spacedBinaryOperator, .unspacedBinaryOperator] for 'equalityToken' " + 
      "in node of kind sameTypeRequirement")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _rightTypeIdentifier = raw[Cursor.type]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_rightTypeIdentifier.kind == .type,
                 "expected child of kind .type, " +
                 "got \(_rightTypeIdentifier.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _trailingComma = raw[Cursor.commaToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _trailingCommaTokenKind = _trailingComma.tokenKind else {
      fatalError("expected token child, got \(_trailingComma.kind)")
    }
    precondition([.comma].contains(_trailingCommaTokenKind),
      "expected one of [.comma] for 'trailingComma' " + 
      "in node of kind sameTypeRequirement")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var leftTypeIdentifier: TypeSyntax {
    let child = data.cachedChild(at: Cursor.leftTypeIdentifier)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TypeSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `leftTypeIdentifier` replaced.
  /// - param newChild: The new `leftTypeIdentifier` to replace the node's
  ///                   current `leftTypeIdentifier`, if present.
  public func withLeftTypeIdentifier(
    _ newChild: TypeSyntax?) -> SameTypeRequirementSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.type)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.leftTypeIdentifier)
    return SameTypeRequirementSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var equalityToken: TokenSyntax {
    let child = data.cachedChild(at: Cursor.equalityToken)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `equalityToken` replaced.
  /// - param newChild: The new `equalityToken` to replace the node's
  ///                   current `equalityToken`, if present.
  public func withEqualityToken(
    _ newChild: TokenSyntax?) -> SameTypeRequirementSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.spacedBinaryOperator(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.equalityToken)
    return SameTypeRequirementSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var rightTypeIdentifier: TypeSyntax {
    let child = data.cachedChild(at: Cursor.rightTypeIdentifier)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TypeSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `rightTypeIdentifier` replaced.
  /// - param newChild: The new `rightTypeIdentifier` to replace the node's
  ///                   current `rightTypeIdentifier`, if present.
  public func withRightTypeIdentifier(
    _ newChild: TypeSyntax?) -> SameTypeRequirementSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.type)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.rightTypeIdentifier)
    return SameTypeRequirementSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var trailingComma: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.trailingComma)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `trailingComma` replaced.
  /// - param newChild: The new `trailingComma` to replace the node's
  ///                   current `trailingComma`, if present.
  public func withTrailingComma(
    _ newChild: TokenSyntax?) -> SameTypeRequirementSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.comma)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.trailingComma)
    return SameTypeRequirementSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `SameTypeRequirementSyntax` nodes are equal to each other.
  public static func ==(lhs: SameTypeRequirementSyntax, rhs: SameTypeRequirementSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct GenericParameterSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case attributes
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case name
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case colon
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case inheritedType
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case trailingComma
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `GenericParameterSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 5)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _attributes = raw[Cursor.attributeList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_attributes.kind == .attributeList,
                 "expected child of kind .attributeList, " +
                 "got \(_attributes.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _name = raw[Cursor.identifierToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _nameTokenKind = _name.tokenKind else {
      fatalError("expected token child, got \(_name.kind)")
    }
    precondition([.identifier].contains(_nameTokenKind),
      "expected one of [.identifier] for 'name' " + 
      "in node of kind genericParameter")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _colon = raw[Cursor.colonToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _colonTokenKind = _colon.tokenKind else {
      fatalError("expected token child, got \(_colon.kind)")
    }
    precondition([.colon].contains(_colonTokenKind),
      "expected one of [.colon] for 'colon' " + 
      "in node of kind genericParameter")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _inheritedType = raw[Cursor.type]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_inheritedType.kind == .type,
                 "expected child of kind .type, " +
                 "got \(_inheritedType.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _trailingComma = raw[Cursor.commaToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _trailingCommaTokenKind = _trailingComma.tokenKind else {
      fatalError("expected token child, got \(_trailingComma.kind)")
    }
    precondition([.comma].contains(_trailingCommaTokenKind),
      "expected one of [.comma] for 'trailingComma' " + 
      "in node of kind genericParameter")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var attributes: AttributeListSyntax? {
    let child = data.cachedChild(at: Cursor.attributes)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? AttributeListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `Attribute` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: AttributeSyntax) -> GenericParameterSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.attributes] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.attributeList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.attributes)
    return GenericParameterSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `attributes` replaced.
  /// - param newChild: The new `attributes` to replace the node's
  ///                   current `attributes`, if present.
  public func withAttributes(
    _ newChild: AttributeListSyntax?) -> GenericParameterSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.attributeList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.attributes)
    return GenericParameterSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var name: TokenSyntax {
    let child = data.cachedChild(at: Cursor.name)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `name` replaced.
  /// - param newChild: The new `name` to replace the node's
  ///                   current `name`, if present.
  public func withName(
    _ newChild: TokenSyntax?) -> GenericParameterSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.name)
    return GenericParameterSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var colon: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.colon)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `colon` replaced.
  /// - param newChild: The new `colon` to replace the node's
  ///                   current `colon`, if present.
  public func withColon(
    _ newChild: TokenSyntax?) -> GenericParameterSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.colon)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.colon)
    return GenericParameterSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var inheritedType: TypeSyntax? {
    let child = data.cachedChild(at: Cursor.inheritedType)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TypeSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `inheritedType` replaced.
  /// - param newChild: The new `inheritedType` to replace the node's
  ///                   current `inheritedType`, if present.
  public func withInheritedType(
    _ newChild: TypeSyntax?) -> GenericParameterSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.type)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.inheritedType)
    return GenericParameterSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var trailingComma: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.trailingComma)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `trailingComma` replaced.
  /// - param newChild: The new `trailingComma` to replace the node's
  ///                   current `trailingComma`, if present.
  public func withTrailingComma(
    _ newChild: TokenSyntax?) -> GenericParameterSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.comma)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.trailingComma)
    return GenericParameterSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `GenericParameterSyntax` nodes are equal to each other.
  public static func ==(lhs: GenericParameterSyntax, rhs: GenericParameterSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct GenericParameterClauseSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case leftAngleBracket
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case genericParameterList
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case rightAngleBracket
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `GenericParameterClauseSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 3)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _leftAngleBracket = raw[Cursor.leftAngleToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _leftAngleBracketTokenKind = _leftAngleBracket.tokenKind else {
      fatalError("expected token child, got \(_leftAngleBracket.kind)")
    }
    precondition([.leftAngle].contains(_leftAngleBracketTokenKind),
      "expected one of [.leftAngle] for 'leftAngleBracket' " + 
      "in node of kind genericParameterClause")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _genericParameterList = raw[Cursor.genericParameterList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_genericParameterList.kind == .genericParameterList,
                 "expected child of kind .genericParameterList, " +
                 "got \(_genericParameterList.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _rightAngleBracket = raw[Cursor.rightAngleToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _rightAngleBracketTokenKind = _rightAngleBracket.tokenKind else {
      fatalError("expected token child, got \(_rightAngleBracket.kind)")
    }
    precondition([.rightAngle].contains(_rightAngleBracketTokenKind),
      "expected one of [.rightAngle] for 'rightAngleBracket' " + 
      "in node of kind genericParameterClause")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var leftAngleBracket: TokenSyntax {
    let child = data.cachedChild(at: Cursor.leftAngleBracket)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `leftAngleBracket` replaced.
  /// - param newChild: The new `leftAngleBracket` to replace the node's
  ///                   current `leftAngleBracket`, if present.
  public func withLeftAngleBracket(
    _ newChild: TokenSyntax?) -> GenericParameterClauseSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftAngle)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.leftAngleBracket)
    return GenericParameterClauseSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var genericParameterList: GenericParameterListSyntax {
    let child = data.cachedChild(at: Cursor.genericParameterList)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! GenericParameterListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `GenericParameter` to the node's `genericParameterList`
  /// collection.
  /// - param element: The new `GenericParameter` to add to the node's
  ///                  `genericParameterList` collection.
  /// - returns: A copy of the receiver with the provided `GenericParameter`
  ///            appended to its `genericParameterList` collection.
  public func addGenericParameter(_ element: GenericParameterSyntax) -> GenericParameterClauseSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.genericParameterList] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.genericParameterList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.genericParameterList)
    return GenericParameterClauseSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `genericParameterList` replaced.
  /// - param newChild: The new `genericParameterList` to replace the node's
  ///                   current `genericParameterList`, if present.
  public func withGenericParameterList(
    _ newChild: GenericParameterListSyntax?) -> GenericParameterClauseSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.genericParameterList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.genericParameterList)
    return GenericParameterClauseSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var rightAngleBracket: TokenSyntax {
    let child = data.cachedChild(at: Cursor.rightAngleBracket)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `rightAngleBracket` replaced.
  /// - param newChild: The new `rightAngleBracket` to replace the node's
  ///                   current `rightAngleBracket`, if present.
  public func withRightAngleBracket(
    _ newChild: TokenSyntax?) -> GenericParameterClauseSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightAngle)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.rightAngleBracket)
    return GenericParameterClauseSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `GenericParameterClauseSyntax` nodes are equal to each other.
  public static func ==(lhs: GenericParameterClauseSyntax, rhs: GenericParameterClauseSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct ConformanceRequirementSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case leftTypeIdentifier
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case colon
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case rightTypeIdentifier
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case trailingComma
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `ConformanceRequirementSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 4)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _leftTypeIdentifier = raw[Cursor.type]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_leftTypeIdentifier.kind == .type,
                 "expected child of kind .type, " +
                 "got \(_leftTypeIdentifier.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _colon = raw[Cursor.colonToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _colonTokenKind = _colon.tokenKind else {
      fatalError("expected token child, got \(_colon.kind)")
    }
    precondition([.colon].contains(_colonTokenKind),
      "expected one of [.colon] for 'colon' " + 
      "in node of kind conformanceRequirement")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _rightTypeIdentifier = raw[Cursor.type]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_rightTypeIdentifier.kind == .type,
                 "expected child of kind .type, " +
                 "got \(_rightTypeIdentifier.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _trailingComma = raw[Cursor.commaToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _trailingCommaTokenKind = _trailingComma.tokenKind else {
      fatalError("expected token child, got \(_trailingComma.kind)")
    }
    precondition([.comma].contains(_trailingCommaTokenKind),
      "expected one of [.comma] for 'trailingComma' " + 
      "in node of kind conformanceRequirement")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var leftTypeIdentifier: TypeSyntax {
    let child = data.cachedChild(at: Cursor.leftTypeIdentifier)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TypeSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `leftTypeIdentifier` replaced.
  /// - param newChild: The new `leftTypeIdentifier` to replace the node's
  ///                   current `leftTypeIdentifier`, if present.
  public func withLeftTypeIdentifier(
    _ newChild: TypeSyntax?) -> ConformanceRequirementSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.type)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.leftTypeIdentifier)
    return ConformanceRequirementSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var colon: TokenSyntax {
    let child = data.cachedChild(at: Cursor.colon)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `colon` replaced.
  /// - param newChild: The new `colon` to replace the node's
  ///                   current `colon`, if present.
  public func withColon(
    _ newChild: TokenSyntax?) -> ConformanceRequirementSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.colon)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.colon)
    return ConformanceRequirementSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var rightTypeIdentifier: TypeSyntax {
    let child = data.cachedChild(at: Cursor.rightTypeIdentifier)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TypeSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `rightTypeIdentifier` replaced.
  /// - param newChild: The new `rightTypeIdentifier` to replace the node's
  ///                   current `rightTypeIdentifier`, if present.
  public func withRightTypeIdentifier(
    _ newChild: TypeSyntax?) -> ConformanceRequirementSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.type)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.rightTypeIdentifier)
    return ConformanceRequirementSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var trailingComma: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.trailingComma)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `trailingComma` replaced.
  /// - param newChild: The new `trailingComma` to replace the node's
  ///                   current `trailingComma`, if present.
  public func withTrailingComma(
    _ newChild: TokenSyntax?) -> ConformanceRequirementSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.comma)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.trailingComma)
    return ConformanceRequirementSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `ConformanceRequirementSyntax` nodes are equal to each other.
  public static func ==(lhs: ConformanceRequirementSyntax, rhs: ConformanceRequirementSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct SimpleTypeIdentifierSyntax: TypeSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case name
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case genericArgumentClause
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `SimpleTypeIdentifierSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 2)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _name = raw[Cursor.token]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _nameTokenKind = _name.tokenKind else {
      fatalError("expected token child, got \(_name.kind)")
    }
    precondition([.identifier, .capitalSelfKeyword, .anyKeyword].contains(_nameTokenKind),
      "expected one of [.identifier, .capitalSelfKeyword, .anyKeyword] for 'name' " + 
      "in node of kind simpleTypeIdentifier")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _genericArgumentClause = raw[Cursor.genericArgumentClause]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_genericArgumentClause.kind == .genericArgumentClause,
                 "expected child of kind .genericArgumentClause, " +
                 "got \(_genericArgumentClause.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var name: TokenSyntax {
    let child = data.cachedChild(at: Cursor.name)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `name` replaced.
  /// - param newChild: The new `name` to replace the node's
  ///                   current `name`, if present.
  public func withName(
    _ newChild: TokenSyntax?) -> SimpleTypeIdentifierSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.name)
    return SimpleTypeIdentifierSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var genericArgumentClause: GenericArgumentClauseSyntax? {
    let child = data.cachedChild(at: Cursor.genericArgumentClause)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? GenericArgumentClauseSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `genericArgumentClause` replaced.
  /// - param newChild: The new `genericArgumentClause` to replace the node's
  ///                   current `genericArgumentClause`, if present.
  public func withGenericArgumentClause(
    _ newChild: GenericArgumentClauseSyntax?) -> SimpleTypeIdentifierSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.genericArgumentClause)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.genericArgumentClause)
    return SimpleTypeIdentifierSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `SimpleTypeIdentifierSyntax` nodes are equal to each other.
  public static func ==(lhs: SimpleTypeIdentifierSyntax, rhs: SimpleTypeIdentifierSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct MemberTypeIdentifierSyntax: TypeSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case baseType
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case period
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case name
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case genericArgumentClause
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `MemberTypeIdentifierSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 4)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _baseType = raw[Cursor.type]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_baseType.kind == .type,
                 "expected child of kind .type, " +
                 "got \(_baseType.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _period = raw[Cursor.token]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _periodTokenKind = _period.tokenKind else {
      fatalError("expected token child, got \(_period.kind)")
    }
    precondition([.period, .prefixPeriod].contains(_periodTokenKind),
      "expected one of [.period, .prefixPeriod] for 'period' " + 
      "in node of kind memberTypeIdentifier")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _name = raw[Cursor.token]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _nameTokenKind = _name.tokenKind else {
      fatalError("expected token child, got \(_name.kind)")
    }
    precondition([.identifier, .capitalSelfKeyword, .anyKeyword].contains(_nameTokenKind),
      "expected one of [.identifier, .capitalSelfKeyword, .anyKeyword] for 'name' " + 
      "in node of kind memberTypeIdentifier")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _genericArgumentClause = raw[Cursor.genericArgumentClause]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_genericArgumentClause.kind == .genericArgumentClause,
                 "expected child of kind .genericArgumentClause, " +
                 "got \(_genericArgumentClause.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var baseType: TypeSyntax {
    let child = data.cachedChild(at: Cursor.baseType)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TypeSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `baseType` replaced.
  /// - param newChild: The new `baseType` to replace the node's
  ///                   current `baseType`, if present.
  public func withBaseType(
    _ newChild: TypeSyntax?) -> MemberTypeIdentifierSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.type)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.baseType)
    return MemberTypeIdentifierSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var period: TokenSyntax {
    let child = data.cachedChild(at: Cursor.period)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `period` replaced.
  /// - param newChild: The new `period` to replace the node's
  ///                   current `period`, if present.
  public func withPeriod(
    _ newChild: TokenSyntax?) -> MemberTypeIdentifierSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.period)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.period)
    return MemberTypeIdentifierSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var name: TokenSyntax {
    let child = data.cachedChild(at: Cursor.name)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `name` replaced.
  /// - param newChild: The new `name` to replace the node's
  ///                   current `name`, if present.
  public func withName(
    _ newChild: TokenSyntax?) -> MemberTypeIdentifierSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.name)
    return MemberTypeIdentifierSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var genericArgumentClause: GenericArgumentClauseSyntax? {
    let child = data.cachedChild(at: Cursor.genericArgumentClause)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? GenericArgumentClauseSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `genericArgumentClause` replaced.
  /// - param newChild: The new `genericArgumentClause` to replace the node's
  ///                   current `genericArgumentClause`, if present.
  public func withGenericArgumentClause(
    _ newChild: GenericArgumentClauseSyntax?) -> MemberTypeIdentifierSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.genericArgumentClause)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.genericArgumentClause)
    return MemberTypeIdentifierSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `MemberTypeIdentifierSyntax` nodes are equal to each other.
  public static func ==(lhs: MemberTypeIdentifierSyntax, rhs: MemberTypeIdentifierSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct ClassRestrictionTypeSyntax: TypeSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case classKeyword
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `ClassRestrictionTypeSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 1)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _classKeyword = raw[Cursor.classToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _classKeywordTokenKind = _classKeyword.tokenKind else {
      fatalError("expected token child, got \(_classKeyword.kind)")
    }
    precondition([.classKeyword].contains(_classKeywordTokenKind),
      "expected one of [.classKeyword] for 'classKeyword' " + 
      "in node of kind classRestrictionType")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var classKeyword: TokenSyntax {
    let child = data.cachedChild(at: Cursor.classKeyword)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `classKeyword` replaced.
  /// - param newChild: The new `classKeyword` to replace the node's
  ///                   current `classKeyword`, if present.
  public func withClassKeyword(
    _ newChild: TokenSyntax?) -> ClassRestrictionTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.classKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.classKeyword)
    return ClassRestrictionTypeSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `ClassRestrictionTypeSyntax` nodes are equal to each other.
  public static func ==(lhs: ClassRestrictionTypeSyntax, rhs: ClassRestrictionTypeSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct ArrayTypeSyntax: TypeSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case leftSquareBracket
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case elementType
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case rightSquareBracket
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `ArrayTypeSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 3)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _leftSquareBracket = raw[Cursor.leftSquareBracketToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _leftSquareBracketTokenKind = _leftSquareBracket.tokenKind else {
      fatalError("expected token child, got \(_leftSquareBracket.kind)")
    }
    precondition([.leftSquareBracket].contains(_leftSquareBracketTokenKind),
      "expected one of [.leftSquareBracket] for 'leftSquareBracket' " + 
      "in node of kind arrayType")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _elementType = raw[Cursor.type]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_elementType.kind == .type,
                 "expected child of kind .type, " +
                 "got \(_elementType.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _rightSquareBracket = raw[Cursor.rightSquareBracketToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _rightSquareBracketTokenKind = _rightSquareBracket.tokenKind else {
      fatalError("expected token child, got \(_rightSquareBracket.kind)")
    }
    precondition([.rightSquareBracket].contains(_rightSquareBracketTokenKind),
      "expected one of [.rightSquareBracket] for 'rightSquareBracket' " + 
      "in node of kind arrayType")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var leftSquareBracket: TokenSyntax {
    let child = data.cachedChild(at: Cursor.leftSquareBracket)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `leftSquareBracket` replaced.
  /// - param newChild: The new `leftSquareBracket` to replace the node's
  ///                   current `leftSquareBracket`, if present.
  public func withLeftSquareBracket(
    _ newChild: TokenSyntax?) -> ArrayTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftSquareBracket)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.leftSquareBracket)
    return ArrayTypeSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var elementType: TypeSyntax {
    let child = data.cachedChild(at: Cursor.elementType)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TypeSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `elementType` replaced.
  /// - param newChild: The new `elementType` to replace the node's
  ///                   current `elementType`, if present.
  public func withElementType(
    _ newChild: TypeSyntax?) -> ArrayTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.type)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.elementType)
    return ArrayTypeSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var rightSquareBracket: TokenSyntax {
    let child = data.cachedChild(at: Cursor.rightSquareBracket)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `rightSquareBracket` replaced.
  /// - param newChild: The new `rightSquareBracket` to replace the node's
  ///                   current `rightSquareBracket`, if present.
  public func withRightSquareBracket(
    _ newChild: TokenSyntax?) -> ArrayTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightSquareBracket)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.rightSquareBracket)
    return ArrayTypeSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `ArrayTypeSyntax` nodes are equal to each other.
  public static func ==(lhs: ArrayTypeSyntax, rhs: ArrayTypeSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct DictionaryTypeSyntax: TypeSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case leftSquareBracket
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case keyType
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case colon
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case valueType
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case rightSquareBracket
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `DictionaryTypeSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 5)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _leftSquareBracket = raw[Cursor.leftSquareBracketToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _leftSquareBracketTokenKind = _leftSquareBracket.tokenKind else {
      fatalError("expected token child, got \(_leftSquareBracket.kind)")
    }
    precondition([.leftSquareBracket].contains(_leftSquareBracketTokenKind),
      "expected one of [.leftSquareBracket] for 'leftSquareBracket' " + 
      "in node of kind dictionaryType")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _keyType = raw[Cursor.type]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_keyType.kind == .type,
                 "expected child of kind .type, " +
                 "got \(_keyType.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _colon = raw[Cursor.colonToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _colonTokenKind = _colon.tokenKind else {
      fatalError("expected token child, got \(_colon.kind)")
    }
    precondition([.colon].contains(_colonTokenKind),
      "expected one of [.colon] for 'colon' " + 
      "in node of kind dictionaryType")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _valueType = raw[Cursor.type]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_valueType.kind == .type,
                 "expected child of kind .type, " +
                 "got \(_valueType.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _rightSquareBracket = raw[Cursor.rightSquareBracketToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _rightSquareBracketTokenKind = _rightSquareBracket.tokenKind else {
      fatalError("expected token child, got \(_rightSquareBracket.kind)")
    }
    precondition([.rightSquareBracket].contains(_rightSquareBracketTokenKind),
      "expected one of [.rightSquareBracket] for 'rightSquareBracket' " + 
      "in node of kind dictionaryType")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var leftSquareBracket: TokenSyntax {
    let child = data.cachedChild(at: Cursor.leftSquareBracket)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `leftSquareBracket` replaced.
  /// - param newChild: The new `leftSquareBracket` to replace the node's
  ///                   current `leftSquareBracket`, if present.
  public func withLeftSquareBracket(
    _ newChild: TokenSyntax?) -> DictionaryTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftSquareBracket)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.leftSquareBracket)
    return DictionaryTypeSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var keyType: TypeSyntax {
    let child = data.cachedChild(at: Cursor.keyType)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TypeSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `keyType` replaced.
  /// - param newChild: The new `keyType` to replace the node's
  ///                   current `keyType`, if present.
  public func withKeyType(
    _ newChild: TypeSyntax?) -> DictionaryTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.type)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.keyType)
    return DictionaryTypeSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var colon: TokenSyntax {
    let child = data.cachedChild(at: Cursor.colon)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `colon` replaced.
  /// - param newChild: The new `colon` to replace the node's
  ///                   current `colon`, if present.
  public func withColon(
    _ newChild: TokenSyntax?) -> DictionaryTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.colon)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.colon)
    return DictionaryTypeSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var valueType: TypeSyntax {
    let child = data.cachedChild(at: Cursor.valueType)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TypeSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `valueType` replaced.
  /// - param newChild: The new `valueType` to replace the node's
  ///                   current `valueType`, if present.
  public func withValueType(
    _ newChild: TypeSyntax?) -> DictionaryTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.type)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.valueType)
    return DictionaryTypeSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var rightSquareBracket: TokenSyntax {
    let child = data.cachedChild(at: Cursor.rightSquareBracket)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `rightSquareBracket` replaced.
  /// - param newChild: The new `rightSquareBracket` to replace the node's
  ///                   current `rightSquareBracket`, if present.
  public func withRightSquareBracket(
    _ newChild: TokenSyntax?) -> DictionaryTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightSquareBracket)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.rightSquareBracket)
    return DictionaryTypeSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `DictionaryTypeSyntax` nodes are equal to each other.
  public static func ==(lhs: DictionaryTypeSyntax, rhs: DictionaryTypeSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct MetatypeTypeSyntax: TypeSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case baseType
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case period
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case typeOrProtocol
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `MetatypeTypeSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 3)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _baseType = raw[Cursor.type]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_baseType.kind == .type,
                 "expected child of kind .type, " +
                 "got \(_baseType.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _period = raw[Cursor.periodToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _periodTokenKind = _period.tokenKind else {
      fatalError("expected token child, got \(_period.kind)")
    }
    precondition([.period].contains(_periodTokenKind),
      "expected one of [.period] for 'period' " + 
      "in node of kind metatypeType")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _typeOrProtocol = raw[Cursor.identifierToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _typeOrProtocolTokenKind = _typeOrProtocol.tokenKind else {
      fatalError("expected token child, got \(_typeOrProtocol.kind)")
    }
    precondition([.identifier].contains(_typeOrProtocolTokenKind),
      "expected one of [.identifier] for 'typeOrProtocol' " + 
      "in node of kind metatypeType")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var baseType: TypeSyntax {
    let child = data.cachedChild(at: Cursor.baseType)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TypeSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `baseType` replaced.
  /// - param newChild: The new `baseType` to replace the node's
  ///                   current `baseType`, if present.
  public func withBaseType(
    _ newChild: TypeSyntax?) -> MetatypeTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.type)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.baseType)
    return MetatypeTypeSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var period: TokenSyntax {
    let child = data.cachedChild(at: Cursor.period)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `period` replaced.
  /// - param newChild: The new `period` to replace the node's
  ///                   current `period`, if present.
  public func withPeriod(
    _ newChild: TokenSyntax?) -> MetatypeTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.period)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.period)
    return MetatypeTypeSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var typeOrProtocol: TokenSyntax {
    let child = data.cachedChild(at: Cursor.typeOrProtocol)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `typeOrProtocol` replaced.
  /// - param newChild: The new `typeOrProtocol` to replace the node's
  ///                   current `typeOrProtocol`, if present.
  public func withTypeOrProtocol(
    _ newChild: TokenSyntax?) -> MetatypeTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.typeOrProtocol)
    return MetatypeTypeSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `MetatypeTypeSyntax` nodes are equal to each other.
  public static func ==(lhs: MetatypeTypeSyntax, rhs: MetatypeTypeSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct OptionalTypeSyntax: TypeSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case wrappedType
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case questionMark
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `OptionalTypeSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 2)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _wrappedType = raw[Cursor.type]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_wrappedType.kind == .type,
                 "expected child of kind .type, " +
                 "got \(_wrappedType.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _questionMark = raw[Cursor.postfixQuestionMarkToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _questionMarkTokenKind = _questionMark.tokenKind else {
      fatalError("expected token child, got \(_questionMark.kind)")
    }
    precondition([.postfixQuestionMark].contains(_questionMarkTokenKind),
      "expected one of [.postfixQuestionMark] for 'questionMark' " + 
      "in node of kind optionalType")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var wrappedType: TypeSyntax {
    let child = data.cachedChild(at: Cursor.wrappedType)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TypeSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `wrappedType` replaced.
  /// - param newChild: The new `wrappedType` to replace the node's
  ///                   current `wrappedType`, if present.
  public func withWrappedType(
    _ newChild: TypeSyntax?) -> OptionalTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.type)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.wrappedType)
    return OptionalTypeSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var questionMark: TokenSyntax {
    let child = data.cachedChild(at: Cursor.questionMark)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `questionMark` replaced.
  /// - param newChild: The new `questionMark` to replace the node's
  ///                   current `questionMark`, if present.
  public func withQuestionMark(
    _ newChild: TokenSyntax?) -> OptionalTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.postfixQuestionMark)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.questionMark)
    return OptionalTypeSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `OptionalTypeSyntax` nodes are equal to each other.
  public static func ==(lhs: OptionalTypeSyntax, rhs: OptionalTypeSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct ImplicitlyUnwrappedOptionalTypeSyntax: TypeSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case wrappedType
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case exclamationMark
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `ImplicitlyUnwrappedOptionalTypeSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 2)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _wrappedType = raw[Cursor.type]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_wrappedType.kind == .type,
                 "expected child of kind .type, " +
                 "got \(_wrappedType.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _exclamationMark = raw[Cursor.exclamationMarkToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _exclamationMarkTokenKind = _exclamationMark.tokenKind else {
      fatalError("expected token child, got \(_exclamationMark.kind)")
    }
    precondition([.exclamationMark].contains(_exclamationMarkTokenKind),
      "expected one of [.exclamationMark] for 'exclamationMark' " + 
      "in node of kind implicitlyUnwrappedOptionalType")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var wrappedType: TypeSyntax {
    let child = data.cachedChild(at: Cursor.wrappedType)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TypeSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `wrappedType` replaced.
  /// - param newChild: The new `wrappedType` to replace the node's
  ///                   current `wrappedType`, if present.
  public func withWrappedType(
    _ newChild: TypeSyntax?) -> ImplicitlyUnwrappedOptionalTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.type)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.wrappedType)
    return ImplicitlyUnwrappedOptionalTypeSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var exclamationMark: TokenSyntax {
    let child = data.cachedChild(at: Cursor.exclamationMark)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `exclamationMark` replaced.
  /// - param newChild: The new `exclamationMark` to replace the node's
  ///                   current `exclamationMark`, if present.
  public func withExclamationMark(
    _ newChild: TokenSyntax?) -> ImplicitlyUnwrappedOptionalTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.exclamationMark)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.exclamationMark)
    return ImplicitlyUnwrappedOptionalTypeSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `ImplicitlyUnwrappedOptionalTypeSyntax` nodes are equal to each other.
  public static func ==(lhs: ImplicitlyUnwrappedOptionalTypeSyntax, rhs: ImplicitlyUnwrappedOptionalTypeSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct CompositionTypeElementSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case type
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case ampersand
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `CompositionTypeElementSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 2)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _type = raw[Cursor.type]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_type.kind == .type,
                 "expected child of kind .type, " +
                 "got \(_type.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _ampersand = raw[Cursor.token]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 113)
    guard let _ampersandTokenKind = _ampersand.tokenKind else {
      fatalError("expected token child, got \(_ampersand.kind)")
    }
    precondition(["&"].contains(_ampersandTokenKind.text),
                 "expected one of '[&]', got " +
                 "'\(_ampersandTokenKind.text)'")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var type: TypeSyntax {
    let child = data.cachedChild(at: Cursor.type)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TypeSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `type` replaced.
  /// - param newChild: The new `type` to replace the node's
  ///                   current `type`, if present.
  public func withType(
    _ newChild: TypeSyntax?) -> CompositionTypeElementSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.type)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.type)
    return CompositionTypeElementSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var ampersand: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.ampersand)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `ampersand` replaced.
  /// - param newChild: The new `ampersand` to replace the node's
  ///                   current `ampersand`, if present.
  public func withAmpersand(
    _ newChild: TokenSyntax?) -> CompositionTypeElementSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.unknown(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.ampersand)
    return CompositionTypeElementSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `CompositionTypeElementSyntax` nodes are equal to each other.
  public static func ==(lhs: CompositionTypeElementSyntax, rhs: CompositionTypeElementSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct CompositionTypeSyntax: TypeSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case elements
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `CompositionTypeSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 1)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _elements = raw[Cursor.compositionTypeElementList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_elements.kind == .compositionTypeElementList,
                 "expected child of kind .compositionTypeElementList, " +
                 "got \(_elements.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var elements: CompositionTypeElementListSyntax {
    let child = data.cachedChild(at: Cursor.elements)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! CompositionTypeElementListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `CompositionTypeElement` to the node's `elements`
  /// collection.
  /// - param element: The new `CompositionTypeElement` to add to the node's
  ///                  `elements` collection.
  /// - returns: A copy of the receiver with the provided `CompositionTypeElement`
  ///            appended to its `elements` collection.
  public func addCompositionTypeElement(_ element: CompositionTypeElementSyntax) -> CompositionTypeSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.elements] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.compositionTypeElementList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.elements)
    return CompositionTypeSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `elements` replaced.
  /// - param newChild: The new `elements` to replace the node's
  ///                   current `elements`, if present.
  public func withElements(
    _ newChild: CompositionTypeElementListSyntax?) -> CompositionTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.compositionTypeElementList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.elements)
    return CompositionTypeSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `CompositionTypeSyntax` nodes are equal to each other.
  public static func ==(lhs: CompositionTypeSyntax, rhs: CompositionTypeSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct TupleTypeElementSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case inOut
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case name
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case secondName
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case colon
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case type
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case ellipsis
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case initializer
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case trailingComma
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `TupleTypeElementSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 8)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _inOut = raw[Cursor.inOutToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_inOut.kind == .inOutToken,
                 "expected child of kind .inOutToken, " +
                 "got \(_inOut.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _name = raw[Cursor.token]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _nameTokenKind = _name.tokenKind else {
      fatalError("expected token child, got \(_name.kind)")
    }
    precondition([.identifier, .wildcardKeyword].contains(_nameTokenKind),
      "expected one of [.identifier, .wildcardKeyword] for 'name' " + 
      "in node of kind tupleTypeElement")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _secondName = raw[Cursor.token]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _secondNameTokenKind = _secondName.tokenKind else {
      fatalError("expected token child, got \(_secondName.kind)")
    }
    precondition([.identifier, .wildcardKeyword].contains(_secondNameTokenKind),
      "expected one of [.identifier, .wildcardKeyword] for 'secondName' " + 
      "in node of kind tupleTypeElement")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _colon = raw[Cursor.colonToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _colonTokenKind = _colon.tokenKind else {
      fatalError("expected token child, got \(_colon.kind)")
    }
    precondition([.colon].contains(_colonTokenKind),
      "expected one of [.colon] for 'colon' " + 
      "in node of kind tupleTypeElement")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _type = raw[Cursor.type]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_type.kind == .type,
                 "expected child of kind .type, " +
                 "got \(_type.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _ellipsis = raw[Cursor.token]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_ellipsis.kind == .token,
                 "expected child of kind .token, " +
                 "got \(_ellipsis.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _initializer = raw[Cursor.initializerClause]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_initializer.kind == .initializerClause,
                 "expected child of kind .initializerClause, " +
                 "got \(_initializer.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _trailingComma = raw[Cursor.commaToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _trailingCommaTokenKind = _trailingComma.tokenKind else {
      fatalError("expected token child, got \(_trailingComma.kind)")
    }
    precondition([.comma].contains(_trailingCommaTokenKind),
      "expected one of [.comma] for 'trailingComma' " + 
      "in node of kind tupleTypeElement")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var inOut: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.inOut)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `inOut` replaced.
  /// - param newChild: The new `inOut` to replace the node's
  ///                   current `inOut`, if present.
  public func withInOut(
    _ newChild: TokenSyntax?) -> TupleTypeElementSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.unknown(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.inOut)
    return TupleTypeElementSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var name: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.name)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `name` replaced.
  /// - param newChild: The new `name` to replace the node's
  ///                   current `name`, if present.
  public func withName(
    _ newChild: TokenSyntax?) -> TupleTypeElementSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.name)
    return TupleTypeElementSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var secondName: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.secondName)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `secondName` replaced.
  /// - param newChild: The new `secondName` to replace the node's
  ///                   current `secondName`, if present.
  public func withSecondName(
    _ newChild: TokenSyntax?) -> TupleTypeElementSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.secondName)
    return TupleTypeElementSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var colon: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.colon)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `colon` replaced.
  /// - param newChild: The new `colon` to replace the node's
  ///                   current `colon`, if present.
  public func withColon(
    _ newChild: TokenSyntax?) -> TupleTypeElementSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.colon)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.colon)
    return TupleTypeElementSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var type: TypeSyntax {
    let child = data.cachedChild(at: Cursor.type)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TypeSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `type` replaced.
  /// - param newChild: The new `type` to replace the node's
  ///                   current `type`, if present.
  public func withType(
    _ newChild: TypeSyntax?) -> TupleTypeElementSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.type)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.type)
    return TupleTypeElementSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var ellipsis: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.ellipsis)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `ellipsis` replaced.
  /// - param newChild: The new `ellipsis` to replace the node's
  ///                   current `ellipsis`, if present.
  public func withEllipsis(
    _ newChild: TokenSyntax?) -> TupleTypeElementSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.unknown(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.ellipsis)
    return TupleTypeElementSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var initializer: InitializerClauseSyntax? {
    let child = data.cachedChild(at: Cursor.initializer)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? InitializerClauseSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `initializer` replaced.
  /// - param newChild: The new `initializer` to replace the node's
  ///                   current `initializer`, if present.
  public func withInitializer(
    _ newChild: InitializerClauseSyntax?) -> TupleTypeElementSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.initializerClause)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.initializer)
    return TupleTypeElementSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var trailingComma: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.trailingComma)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `trailingComma` replaced.
  /// - param newChild: The new `trailingComma` to replace the node's
  ///                   current `trailingComma`, if present.
  public func withTrailingComma(
    _ newChild: TokenSyntax?) -> TupleTypeElementSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.comma)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.trailingComma)
    return TupleTypeElementSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `TupleTypeElementSyntax` nodes are equal to each other.
  public static func ==(lhs: TupleTypeElementSyntax, rhs: TupleTypeElementSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct TupleTypeSyntax: TypeSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case leftParen
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case elements
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case rightParen
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `TupleTypeSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 3)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _leftParen = raw[Cursor.leftParenToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _leftParenTokenKind = _leftParen.tokenKind else {
      fatalError("expected token child, got \(_leftParen.kind)")
    }
    precondition([.leftParen].contains(_leftParenTokenKind),
      "expected one of [.leftParen] for 'leftParen' " + 
      "in node of kind tupleType")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _elements = raw[Cursor.tupleTypeElementList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_elements.kind == .tupleTypeElementList,
                 "expected child of kind .tupleTypeElementList, " +
                 "got \(_elements.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _rightParen = raw[Cursor.rightParenToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _rightParenTokenKind = _rightParen.tokenKind else {
      fatalError("expected token child, got \(_rightParen.kind)")
    }
    precondition([.rightParen].contains(_rightParenTokenKind),
      "expected one of [.rightParen] for 'rightParen' " + 
      "in node of kind tupleType")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var leftParen: TokenSyntax {
    let child = data.cachedChild(at: Cursor.leftParen)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `leftParen` replaced.
  /// - param newChild: The new `leftParen` to replace the node's
  ///                   current `leftParen`, if present.
  public func withLeftParen(
    _ newChild: TokenSyntax?) -> TupleTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftParen)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.leftParen)
    return TupleTypeSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var elements: TupleTypeElementListSyntax {
    let child = data.cachedChild(at: Cursor.elements)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TupleTypeElementListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `TupleTypeElement` to the node's `elements`
  /// collection.
  /// - param element: The new `TupleTypeElement` to add to the node's
  ///                  `elements` collection.
  /// - returns: A copy of the receiver with the provided `TupleTypeElement`
  ///            appended to its `elements` collection.
  public func addTupleTypeElement(_ element: TupleTypeElementSyntax) -> TupleTypeSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.elements] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.tupleTypeElementList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.elements)
    return TupleTypeSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `elements` replaced.
  /// - param newChild: The new `elements` to replace the node's
  ///                   current `elements`, if present.
  public func withElements(
    _ newChild: TupleTypeElementListSyntax?) -> TupleTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.tupleTypeElementList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.elements)
    return TupleTypeSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var rightParen: TokenSyntax {
    let child = data.cachedChild(at: Cursor.rightParen)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `rightParen` replaced.
  /// - param newChild: The new `rightParen` to replace the node's
  ///                   current `rightParen`, if present.
  public func withRightParen(
    _ newChild: TokenSyntax?) -> TupleTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightParen)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.rightParen)
    return TupleTypeSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `TupleTypeSyntax` nodes are equal to each other.
  public static func ==(lhs: TupleTypeSyntax, rhs: TupleTypeSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct FunctionTypeSyntax: TypeSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case leftParen
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case arguments
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case rightParen
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case throwsOrRethrowsKeyword
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case arrow
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case returnType
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `FunctionTypeSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 6)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _leftParen = raw[Cursor.leftParenToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _leftParenTokenKind = _leftParen.tokenKind else {
      fatalError("expected token child, got \(_leftParen.kind)")
    }
    precondition([.leftParen].contains(_leftParenTokenKind),
      "expected one of [.leftParen] for 'leftParen' " + 
      "in node of kind functionType")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _arguments = raw[Cursor.tupleTypeElementList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_arguments.kind == .tupleTypeElementList,
                 "expected child of kind .tupleTypeElementList, " +
                 "got \(_arguments.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _rightParen = raw[Cursor.rightParenToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _rightParenTokenKind = _rightParen.tokenKind else {
      fatalError("expected token child, got \(_rightParen.kind)")
    }
    precondition([.rightParen].contains(_rightParenTokenKind),
      "expected one of [.rightParen] for 'rightParen' " + 
      "in node of kind functionType")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _throwsOrRethrowsKeyword = raw[Cursor.token]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _throwsOrRethrowsKeywordTokenKind = _throwsOrRethrowsKeyword.tokenKind else {
      fatalError("expected token child, got \(_throwsOrRethrowsKeyword.kind)")
    }
    precondition([.throwsKeyword, .rethrowsKeyword, .throwKeyword].contains(_throwsOrRethrowsKeywordTokenKind),
      "expected one of [.throwsKeyword, .rethrowsKeyword, .throwKeyword] for 'throwsOrRethrowsKeyword' " + 
      "in node of kind functionType")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _arrow = raw[Cursor.arrowToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _arrowTokenKind = _arrow.tokenKind else {
      fatalError("expected token child, got \(_arrow.kind)")
    }
    precondition([.arrow].contains(_arrowTokenKind),
      "expected one of [.arrow] for 'arrow' " + 
      "in node of kind functionType")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _returnType = raw[Cursor.type]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_returnType.kind == .type,
                 "expected child of kind .type, " +
                 "got \(_returnType.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var leftParen: TokenSyntax {
    let child = data.cachedChild(at: Cursor.leftParen)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `leftParen` replaced.
  /// - param newChild: The new `leftParen` to replace the node's
  ///                   current `leftParen`, if present.
  public func withLeftParen(
    _ newChild: TokenSyntax?) -> FunctionTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftParen)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.leftParen)
    return FunctionTypeSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var arguments: TupleTypeElementListSyntax {
    let child = data.cachedChild(at: Cursor.arguments)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TupleTypeElementListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `TupleTypeElement` to the node's `arguments`
  /// collection.
  /// - param element: The new `TupleTypeElement` to add to the node's
  ///                  `arguments` collection.
  /// - returns: A copy of the receiver with the provided `TupleTypeElement`
  ///            appended to its `arguments` collection.
  public func addTupleTypeElement(_ element: TupleTypeElementSyntax) -> FunctionTypeSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.arguments] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.tupleTypeElementList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.arguments)
    return FunctionTypeSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `arguments` replaced.
  /// - param newChild: The new `arguments` to replace the node's
  ///                   current `arguments`, if present.
  public func withArguments(
    _ newChild: TupleTypeElementListSyntax?) -> FunctionTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.tupleTypeElementList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.arguments)
    return FunctionTypeSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var rightParen: TokenSyntax {
    let child = data.cachedChild(at: Cursor.rightParen)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `rightParen` replaced.
  /// - param newChild: The new `rightParen` to replace the node's
  ///                   current `rightParen`, if present.
  public func withRightParen(
    _ newChild: TokenSyntax?) -> FunctionTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightParen)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.rightParen)
    return FunctionTypeSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var throwsOrRethrowsKeyword: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.throwsOrRethrowsKeyword)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `throwsOrRethrowsKeyword` replaced.
  /// - param newChild: The new `throwsOrRethrowsKeyword` to replace the node's
  ///                   current `throwsOrRethrowsKeyword`, if present.
  public func withThrowsOrRethrowsKeyword(
    _ newChild: TokenSyntax?) -> FunctionTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.throwsKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.throwsOrRethrowsKeyword)
    return FunctionTypeSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var arrow: TokenSyntax {
    let child = data.cachedChild(at: Cursor.arrow)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `arrow` replaced.
  /// - param newChild: The new `arrow` to replace the node's
  ///                   current `arrow`, if present.
  public func withArrow(
    _ newChild: TokenSyntax?) -> FunctionTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.arrow)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.arrow)
    return FunctionTypeSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var returnType: TypeSyntax {
    let child = data.cachedChild(at: Cursor.returnType)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TypeSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `returnType` replaced.
  /// - param newChild: The new `returnType` to replace the node's
  ///                   current `returnType`, if present.
  public func withReturnType(
    _ newChild: TypeSyntax?) -> FunctionTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.type)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.returnType)
    return FunctionTypeSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `FunctionTypeSyntax` nodes are equal to each other.
  public static func ==(lhs: FunctionTypeSyntax, rhs: FunctionTypeSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct AttributedTypeSyntax: TypeSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case specifier
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case attributes
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case baseType
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `AttributedTypeSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 3)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _specifier = raw[Cursor.token]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 113)
    guard let _specifierTokenKind = _specifier.tokenKind else {
      fatalError("expected token child, got \(_specifier.kind)")
    }
    precondition(["inout", "__shared", "__owned"].contains(_specifierTokenKind.text),
                 "expected one of '[inout, __shared, __owned]', got " +
                 "'\(_specifierTokenKind.text)'")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _attributes = raw[Cursor.attributeList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_attributes.kind == .attributeList,
                 "expected child of kind .attributeList, " +
                 "got \(_attributes.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _baseType = raw[Cursor.type]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_baseType.kind == .type,
                 "expected child of kind .type, " +
                 "got \(_baseType.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var specifier: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.specifier)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `specifier` replaced.
  /// - param newChild: The new `specifier` to replace the node's
  ///                   current `specifier`, if present.
  public func withSpecifier(
    _ newChild: TokenSyntax?) -> AttributedTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.unknown(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.specifier)
    return AttributedTypeSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var attributes: AttributeListSyntax? {
    let child = data.cachedChild(at: Cursor.attributes)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? AttributeListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `Attribute` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: AttributeSyntax) -> AttributedTypeSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.attributes] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.attributeList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.attributes)
    return AttributedTypeSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `attributes` replaced.
  /// - param newChild: The new `attributes` to replace the node's
  ///                   current `attributes`, if present.
  public func withAttributes(
    _ newChild: AttributeListSyntax?) -> AttributedTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.attributeList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.attributes)
    return AttributedTypeSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var baseType: TypeSyntax {
    let child = data.cachedChild(at: Cursor.baseType)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TypeSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `baseType` replaced.
  /// - param newChild: The new `baseType` to replace the node's
  ///                   current `baseType`, if present.
  public func withBaseType(
    _ newChild: TypeSyntax?) -> AttributedTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.type)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.baseType)
    return AttributedTypeSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `AttributedTypeSyntax` nodes are equal to each other.
  public static func ==(lhs: AttributedTypeSyntax, rhs: AttributedTypeSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct GenericArgumentSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case argumentType
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case trailingComma
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `GenericArgumentSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 2)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _argumentType = raw[Cursor.type]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_argumentType.kind == .type,
                 "expected child of kind .type, " +
                 "got \(_argumentType.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _trailingComma = raw[Cursor.commaToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _trailingCommaTokenKind = _trailingComma.tokenKind else {
      fatalError("expected token child, got \(_trailingComma.kind)")
    }
    precondition([.comma].contains(_trailingCommaTokenKind),
      "expected one of [.comma] for 'trailingComma' " + 
      "in node of kind genericArgument")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var argumentType: TypeSyntax {
    let child = data.cachedChild(at: Cursor.argumentType)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TypeSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `argumentType` replaced.
  /// - param newChild: The new `argumentType` to replace the node's
  ///                   current `argumentType`, if present.
  public func withArgumentType(
    _ newChild: TypeSyntax?) -> GenericArgumentSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.type)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.argumentType)
    return GenericArgumentSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var trailingComma: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.trailingComma)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `trailingComma` replaced.
  /// - param newChild: The new `trailingComma` to replace the node's
  ///                   current `trailingComma`, if present.
  public func withTrailingComma(
    _ newChild: TokenSyntax?) -> GenericArgumentSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.comma)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.trailingComma)
    return GenericArgumentSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `GenericArgumentSyntax` nodes are equal to each other.
  public static func ==(lhs: GenericArgumentSyntax, rhs: GenericArgumentSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct GenericArgumentClauseSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case leftAngleBracket
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case arguments
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case rightAngleBracket
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `GenericArgumentClauseSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 3)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _leftAngleBracket = raw[Cursor.leftAngleToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _leftAngleBracketTokenKind = _leftAngleBracket.tokenKind else {
      fatalError("expected token child, got \(_leftAngleBracket.kind)")
    }
    precondition([.leftAngle].contains(_leftAngleBracketTokenKind),
      "expected one of [.leftAngle] for 'leftAngleBracket' " + 
      "in node of kind genericArgumentClause")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _arguments = raw[Cursor.genericArgumentList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_arguments.kind == .genericArgumentList,
                 "expected child of kind .genericArgumentList, " +
                 "got \(_arguments.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _rightAngleBracket = raw[Cursor.rightAngleToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _rightAngleBracketTokenKind = _rightAngleBracket.tokenKind else {
      fatalError("expected token child, got \(_rightAngleBracket.kind)")
    }
    precondition([.rightAngle].contains(_rightAngleBracketTokenKind),
      "expected one of [.rightAngle] for 'rightAngleBracket' " + 
      "in node of kind genericArgumentClause")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var leftAngleBracket: TokenSyntax {
    let child = data.cachedChild(at: Cursor.leftAngleBracket)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `leftAngleBracket` replaced.
  /// - param newChild: The new `leftAngleBracket` to replace the node's
  ///                   current `leftAngleBracket`, if present.
  public func withLeftAngleBracket(
    _ newChild: TokenSyntax?) -> GenericArgumentClauseSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftAngle)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.leftAngleBracket)
    return GenericArgumentClauseSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var arguments: GenericArgumentListSyntax {
    let child = data.cachedChild(at: Cursor.arguments)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! GenericArgumentListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `GenericArgument` to the node's `arguments`
  /// collection.
  /// - param element: The new `GenericArgument` to add to the node's
  ///                  `arguments` collection.
  /// - returns: A copy of the receiver with the provided `GenericArgument`
  ///            appended to its `arguments` collection.
  public func addGenericArgument(_ element: GenericArgumentSyntax) -> GenericArgumentClauseSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.arguments] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.genericArgumentList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.arguments)
    return GenericArgumentClauseSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `arguments` replaced.
  /// - param newChild: The new `arguments` to replace the node's
  ///                   current `arguments`, if present.
  public func withArguments(
    _ newChild: GenericArgumentListSyntax?) -> GenericArgumentClauseSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.genericArgumentList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.arguments)
    return GenericArgumentClauseSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var rightAngleBracket: TokenSyntax {
    let child = data.cachedChild(at: Cursor.rightAngleBracket)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `rightAngleBracket` replaced.
  /// - param newChild: The new `rightAngleBracket` to replace the node's
  ///                   current `rightAngleBracket`, if present.
  public func withRightAngleBracket(
    _ newChild: TokenSyntax?) -> GenericArgumentClauseSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightAngle)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.rightAngleBracket)
    return GenericArgumentClauseSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `GenericArgumentClauseSyntax` nodes are equal to each other.
  public static func ==(lhs: GenericArgumentClauseSyntax, rhs: GenericArgumentClauseSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct TypeAnnotationSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case colon
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case type
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `TypeAnnotationSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 2)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _colon = raw[Cursor.colonToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _colonTokenKind = _colon.tokenKind else {
      fatalError("expected token child, got \(_colon.kind)")
    }
    precondition([.colon].contains(_colonTokenKind),
      "expected one of [.colon] for 'colon' " + 
      "in node of kind typeAnnotation")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _type = raw[Cursor.type]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_type.kind == .type,
                 "expected child of kind .type, " +
                 "got \(_type.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var colon: TokenSyntax {
    let child = data.cachedChild(at: Cursor.colon)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `colon` replaced.
  /// - param newChild: The new `colon` to replace the node's
  ///                   current `colon`, if present.
  public func withColon(
    _ newChild: TokenSyntax?) -> TypeAnnotationSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.colon)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.colon)
    return TypeAnnotationSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var type: TypeSyntax {
    let child = data.cachedChild(at: Cursor.type)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TypeSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `type` replaced.
  /// - param newChild: The new `type` to replace the node's
  ///                   current `type`, if present.
  public func withType(
    _ newChild: TypeSyntax?) -> TypeAnnotationSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.type)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.type)
    return TypeAnnotationSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `TypeAnnotationSyntax` nodes are equal to each other.
  public static func ==(lhs: TypeAnnotationSyntax, rhs: TypeAnnotationSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct EnumCasePatternSyntax: PatternSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case type
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case period
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case caseName
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case associatedTuple
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `EnumCasePatternSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 4)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _type = raw[Cursor.type]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_type.kind == .type,
                 "expected child of kind .type, " +
                 "got \(_type.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _period = raw[Cursor.periodToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _periodTokenKind = _period.tokenKind else {
      fatalError("expected token child, got \(_period.kind)")
    }
    precondition([.period].contains(_periodTokenKind),
      "expected one of [.period] for 'period' " + 
      "in node of kind enumCasePattern")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _caseName = raw[Cursor.identifierToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _caseNameTokenKind = _caseName.tokenKind else {
      fatalError("expected token child, got \(_caseName.kind)")
    }
    precondition([.identifier].contains(_caseNameTokenKind),
      "expected one of [.identifier] for 'caseName' " + 
      "in node of kind enumCasePattern")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _associatedTuple = raw[Cursor.tuplePattern]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_associatedTuple.kind == .tuplePattern,
                 "expected child of kind .tuplePattern, " +
                 "got \(_associatedTuple.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var type: TypeSyntax? {
    let child = data.cachedChild(at: Cursor.type)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TypeSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `type` replaced.
  /// - param newChild: The new `type` to replace the node's
  ///                   current `type`, if present.
  public func withType(
    _ newChild: TypeSyntax?) -> EnumCasePatternSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.type)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.type)
    return EnumCasePatternSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var period: TokenSyntax {
    let child = data.cachedChild(at: Cursor.period)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `period` replaced.
  /// - param newChild: The new `period` to replace the node's
  ///                   current `period`, if present.
  public func withPeriod(
    _ newChild: TokenSyntax?) -> EnumCasePatternSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.period)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.period)
    return EnumCasePatternSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var caseName: TokenSyntax {
    let child = data.cachedChild(at: Cursor.caseName)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `caseName` replaced.
  /// - param newChild: The new `caseName` to replace the node's
  ///                   current `caseName`, if present.
  public func withCaseName(
    _ newChild: TokenSyntax?) -> EnumCasePatternSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.caseName)
    return EnumCasePatternSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var associatedTuple: TuplePatternSyntax? {
    let child = data.cachedChild(at: Cursor.associatedTuple)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TuplePatternSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `associatedTuple` replaced.
  /// - param newChild: The new `associatedTuple` to replace the node's
  ///                   current `associatedTuple`, if present.
  public func withAssociatedTuple(
    _ newChild: TuplePatternSyntax?) -> EnumCasePatternSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.tuplePattern)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.associatedTuple)
    return EnumCasePatternSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `EnumCasePatternSyntax` nodes are equal to each other.
  public static func ==(lhs: EnumCasePatternSyntax, rhs: EnumCasePatternSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct IsTypePatternSyntax: PatternSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case isKeyword
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case type
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `IsTypePatternSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 2)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _isKeyword = raw[Cursor.isToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _isKeywordTokenKind = _isKeyword.tokenKind else {
      fatalError("expected token child, got \(_isKeyword.kind)")
    }
    precondition([.isKeyword].contains(_isKeywordTokenKind),
      "expected one of [.isKeyword] for 'isKeyword' " + 
      "in node of kind isTypePattern")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _type = raw[Cursor.type]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_type.kind == .type,
                 "expected child of kind .type, " +
                 "got \(_type.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var isKeyword: TokenSyntax {
    let child = data.cachedChild(at: Cursor.isKeyword)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `isKeyword` replaced.
  /// - param newChild: The new `isKeyword` to replace the node's
  ///                   current `isKeyword`, if present.
  public func withIsKeyword(
    _ newChild: TokenSyntax?) -> IsTypePatternSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.isKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.isKeyword)
    return IsTypePatternSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var type: TypeSyntax {
    let child = data.cachedChild(at: Cursor.type)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TypeSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `type` replaced.
  /// - param newChild: The new `type` to replace the node's
  ///                   current `type`, if present.
  public func withType(
    _ newChild: TypeSyntax?) -> IsTypePatternSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.type)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.type)
    return IsTypePatternSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `IsTypePatternSyntax` nodes are equal to each other.
  public static func ==(lhs: IsTypePatternSyntax, rhs: IsTypePatternSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct OptionalPatternSyntax: PatternSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case subPattern
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case questionMark
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `OptionalPatternSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 2)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _subPattern = raw[Cursor.pattern]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_subPattern.kind == .pattern,
                 "expected child of kind .pattern, " +
                 "got \(_subPattern.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _questionMark = raw[Cursor.postfixQuestionMarkToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _questionMarkTokenKind = _questionMark.tokenKind else {
      fatalError("expected token child, got \(_questionMark.kind)")
    }
    precondition([.postfixQuestionMark].contains(_questionMarkTokenKind),
      "expected one of [.postfixQuestionMark] for 'questionMark' " + 
      "in node of kind optionalPattern")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var subPattern: PatternSyntax {
    let child = data.cachedChild(at: Cursor.subPattern)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! PatternSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `subPattern` replaced.
  /// - param newChild: The new `subPattern` to replace the node's
  ///                   current `subPattern`, if present.
  public func withSubPattern(
    _ newChild: PatternSyntax?) -> OptionalPatternSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.pattern)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.subPattern)
    return OptionalPatternSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var questionMark: TokenSyntax {
    let child = data.cachedChild(at: Cursor.questionMark)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `questionMark` replaced.
  /// - param newChild: The new `questionMark` to replace the node's
  ///                   current `questionMark`, if present.
  public func withQuestionMark(
    _ newChild: TokenSyntax?) -> OptionalPatternSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.postfixQuestionMark)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.questionMark)
    return OptionalPatternSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `OptionalPatternSyntax` nodes are equal to each other.
  public static func ==(lhs: OptionalPatternSyntax, rhs: OptionalPatternSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct IdentifierPatternSyntax: PatternSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case identifier
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `IdentifierPatternSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 1)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _identifier = raw[Cursor.identifierToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _identifierTokenKind = _identifier.tokenKind else {
      fatalError("expected token child, got \(_identifier.kind)")
    }
    precondition([.identifier].contains(_identifierTokenKind),
      "expected one of [.identifier] for 'identifier' " + 
      "in node of kind identifierPattern")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var identifier: TokenSyntax {
    let child = data.cachedChild(at: Cursor.identifier)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `identifier` replaced.
  /// - param newChild: The new `identifier` to replace the node's
  ///                   current `identifier`, if present.
  public func withIdentifier(
    _ newChild: TokenSyntax?) -> IdentifierPatternSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.identifier)
    return IdentifierPatternSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `IdentifierPatternSyntax` nodes are equal to each other.
  public static func ==(lhs: IdentifierPatternSyntax, rhs: IdentifierPatternSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct AsTypePatternSyntax: PatternSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case pattern
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case asKeyword
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case type
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `AsTypePatternSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 3)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _pattern = raw[Cursor.pattern]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_pattern.kind == .pattern,
                 "expected child of kind .pattern, " +
                 "got \(_pattern.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _asKeyword = raw[Cursor.asToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _asKeywordTokenKind = _asKeyword.tokenKind else {
      fatalError("expected token child, got \(_asKeyword.kind)")
    }
    precondition([.asKeyword].contains(_asKeywordTokenKind),
      "expected one of [.asKeyword] for 'asKeyword' " + 
      "in node of kind asTypePattern")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _type = raw[Cursor.type]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_type.kind == .type,
                 "expected child of kind .type, " +
                 "got \(_type.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var pattern: PatternSyntax {
    let child = data.cachedChild(at: Cursor.pattern)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! PatternSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `pattern` replaced.
  /// - param newChild: The new `pattern` to replace the node's
  ///                   current `pattern`, if present.
  public func withPattern(
    _ newChild: PatternSyntax?) -> AsTypePatternSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.pattern)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.pattern)
    return AsTypePatternSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var asKeyword: TokenSyntax {
    let child = data.cachedChild(at: Cursor.asKeyword)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `asKeyword` replaced.
  /// - param newChild: The new `asKeyword` to replace the node's
  ///                   current `asKeyword`, if present.
  public func withAsKeyword(
    _ newChild: TokenSyntax?) -> AsTypePatternSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.asKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.asKeyword)
    return AsTypePatternSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var type: TypeSyntax {
    let child = data.cachedChild(at: Cursor.type)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TypeSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `type` replaced.
  /// - param newChild: The new `type` to replace the node's
  ///                   current `type`, if present.
  public func withType(
    _ newChild: TypeSyntax?) -> AsTypePatternSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.type)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.type)
    return AsTypePatternSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `AsTypePatternSyntax` nodes are equal to each other.
  public static func ==(lhs: AsTypePatternSyntax, rhs: AsTypePatternSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct TuplePatternSyntax: PatternSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case leftParen
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case elements
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case rightParen
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `TuplePatternSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 3)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _leftParen = raw[Cursor.leftParenToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _leftParenTokenKind = _leftParen.tokenKind else {
      fatalError("expected token child, got \(_leftParen.kind)")
    }
    precondition([.leftParen].contains(_leftParenTokenKind),
      "expected one of [.leftParen] for 'leftParen' " + 
      "in node of kind tuplePattern")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _elements = raw[Cursor.tuplePatternElementList]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_elements.kind == .tuplePatternElementList,
                 "expected child of kind .tuplePatternElementList, " +
                 "got \(_elements.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _rightParen = raw[Cursor.rightParenToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _rightParenTokenKind = _rightParen.tokenKind else {
      fatalError("expected token child, got \(_rightParen.kind)")
    }
    precondition([.rightParen].contains(_rightParenTokenKind),
      "expected one of [.rightParen] for 'rightParen' " + 
      "in node of kind tuplePattern")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var leftParen: TokenSyntax {
    let child = data.cachedChild(at: Cursor.leftParen)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `leftParen` replaced.
  /// - param newChild: The new `leftParen` to replace the node's
  ///                   current `leftParen`, if present.
  public func withLeftParen(
    _ newChild: TokenSyntax?) -> TuplePatternSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftParen)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.leftParen)
    return TuplePatternSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var elements: TuplePatternElementListSyntax {
    let child = data.cachedChild(at: Cursor.elements)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TuplePatternElementListSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 151)

  /// Adds the provided `TuplePatternElement` to the node's `elements`
  /// collection.
  /// - param element: The new `TuplePatternElement` to add to the node's
  ///                  `elements` collection.
  /// - returns: A copy of the receiver with the provided `TuplePatternElement`
  ///            appended to its `elements` collection.
  public func addTuplePatternElement(_ element: TuplePatternElementSyntax) -> TuplePatternSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.elements] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.node(SyntaxKind.tuplePatternElementList,
                                  [element.raw], .present)
    }
    let (root, newData) = data.replacingChild(collection,
                                              at: Cursor.elements)
    return TuplePatternSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `elements` replaced.
  /// - param newChild: The new `elements` to replace the node's
  ///                   current `elements`, if present.
  public func withElements(
    _ newChild: TuplePatternElementListSyntax?) -> TuplePatternSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.tuplePatternElementList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.elements)
    return TuplePatternSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var rightParen: TokenSyntax {
    let child = data.cachedChild(at: Cursor.rightParen)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `rightParen` replaced.
  /// - param newChild: The new `rightParen` to replace the node's
  ///                   current `rightParen`, if present.
  public func withRightParen(
    _ newChild: TokenSyntax?) -> TuplePatternSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightParen)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.rightParen)
    return TuplePatternSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `TuplePatternSyntax` nodes are equal to each other.
  public static func ==(lhs: TuplePatternSyntax, rhs: TuplePatternSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct WildcardPatternSyntax: PatternSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case wildcard
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case typeAnnotation
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `WildcardPatternSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 2)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _wildcard = raw[Cursor.wildcardToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _wildcardTokenKind = _wildcard.tokenKind else {
      fatalError("expected token child, got \(_wildcard.kind)")
    }
    precondition([.wildcardKeyword].contains(_wildcardTokenKind),
      "expected one of [.wildcardKeyword] for 'wildcard' " + 
      "in node of kind wildcardPattern")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _typeAnnotation = raw[Cursor.typeAnnotation]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_typeAnnotation.kind == .typeAnnotation,
                 "expected child of kind .typeAnnotation, " +
                 "got \(_typeAnnotation.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var wildcard: TokenSyntax {
    let child = data.cachedChild(at: Cursor.wildcard)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `wildcard` replaced.
  /// - param newChild: The new `wildcard` to replace the node's
  ///                   current `wildcard`, if present.
  public func withWildcard(
    _ newChild: TokenSyntax?) -> WildcardPatternSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.wildcardKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.wildcard)
    return WildcardPatternSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var typeAnnotation: TypeAnnotationSyntax? {
    let child = data.cachedChild(at: Cursor.typeAnnotation)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TypeAnnotationSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `typeAnnotation` replaced.
  /// - param newChild: The new `typeAnnotation` to replace the node's
  ///                   current `typeAnnotation`, if present.
  public func withTypeAnnotation(
    _ newChild: TypeAnnotationSyntax?) -> WildcardPatternSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.typeAnnotation)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.typeAnnotation)
    return WildcardPatternSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `WildcardPatternSyntax` nodes are equal to each other.
  public static func ==(lhs: WildcardPatternSyntax, rhs: WildcardPatternSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct TuplePatternElementSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case labelName
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case labelColon
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case pattern
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case trailingComma
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `TuplePatternElementSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 4)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _labelName = raw[Cursor.identifierToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _labelNameTokenKind = _labelName.tokenKind else {
      fatalError("expected token child, got \(_labelName.kind)")
    }
    precondition([.identifier].contains(_labelNameTokenKind),
      "expected one of [.identifier] for 'labelName' " + 
      "in node of kind tuplePatternElement")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _labelColon = raw[Cursor.colonToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _labelColonTokenKind = _labelColon.tokenKind else {
      fatalError("expected token child, got \(_labelColon.kind)")
    }
    precondition([.colon].contains(_labelColonTokenKind),
      "expected one of [.colon] for 'labelColon' " + 
      "in node of kind tuplePatternElement")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _pattern = raw[Cursor.pattern]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_pattern.kind == .pattern,
                 "expected child of kind .pattern, " +
                 "got \(_pattern.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _trailingComma = raw[Cursor.commaToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _trailingCommaTokenKind = _trailingComma.tokenKind else {
      fatalError("expected token child, got \(_trailingComma.kind)")
    }
    precondition([.comma].contains(_trailingCommaTokenKind),
      "expected one of [.comma] for 'trailingComma' " + 
      "in node of kind tuplePatternElement")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var labelName: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.labelName)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `labelName` replaced.
  /// - param newChild: The new `labelName` to replace the node's
  ///                   current `labelName`, if present.
  public func withLabelName(
    _ newChild: TokenSyntax?) -> TuplePatternElementSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.labelName)
    return TuplePatternElementSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var labelColon: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.labelColon)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `labelColon` replaced.
  /// - param newChild: The new `labelColon` to replace the node's
  ///                   current `labelColon`, if present.
  public func withLabelColon(
    _ newChild: TokenSyntax?) -> TuplePatternElementSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.colon)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.labelColon)
    return TuplePatternElementSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var pattern: PatternSyntax {
    let child = data.cachedChild(at: Cursor.pattern)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! PatternSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `pattern` replaced.
  /// - param newChild: The new `pattern` to replace the node's
  ///                   current `pattern`, if present.
  public func withPattern(
    _ newChild: PatternSyntax?) -> TuplePatternElementSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.pattern)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.pattern)
    return TuplePatternElementSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var trailingComma: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.trailingComma)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `trailingComma` replaced.
  /// - param newChild: The new `trailingComma` to replace the node's
  ///                   current `trailingComma`, if present.
  public func withTrailingComma(
    _ newChild: TokenSyntax?) -> TuplePatternElementSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.comma)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.trailingComma)
    return TuplePatternElementSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `TuplePatternElementSyntax` nodes are equal to each other.
  public static func ==(lhs: TuplePatternElementSyntax, rhs: TuplePatternElementSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct ExpressionPatternSyntax: PatternSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case expression
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `ExpressionPatternSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 1)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _expression = raw[Cursor.expr]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_expression.kind == .expr,
                 "expected child of kind .expr, " +
                 "got \(_expression.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var expression: ExprSyntax {
    let child = data.cachedChild(at: Cursor.expression)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! ExprSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `expression` replaced.
  /// - param newChild: The new `expression` to replace the node's
  ///                   current `expression`, if present.
  public func withExpression(
    _ newChild: ExprSyntax?) -> ExpressionPatternSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.expression)
    return ExpressionPatternSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `ExpressionPatternSyntax` nodes are equal to each other.
  public static func ==(lhs: ExpressionPatternSyntax, rhs: ExpressionPatternSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct ValueBindingPatternSyntax: PatternSyntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case letOrVarKeyword
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case valuePattern
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `ValueBindingPatternSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 2)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _letOrVarKeyword = raw[Cursor.token]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _letOrVarKeywordTokenKind = _letOrVarKeyword.tokenKind else {
      fatalError("expected token child, got \(_letOrVarKeyword.kind)")
    }
    precondition([.letKeyword, .varKeyword].contains(_letOrVarKeywordTokenKind),
      "expected one of [.letKeyword, .varKeyword] for 'letOrVarKeyword' " + 
      "in node of kind valueBindingPattern")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _valuePattern = raw[Cursor.pattern]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_valuePattern.kind == .pattern,
                 "expected child of kind .pattern, " +
                 "got \(_valuePattern.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var letOrVarKeyword: TokenSyntax {
    let child = data.cachedChild(at: Cursor.letOrVarKeyword)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `letOrVarKeyword` replaced.
  /// - param newChild: The new `letOrVarKeyword` to replace the node's
  ///                   current `letOrVarKeyword`, if present.
  public func withLetOrVarKeyword(
    _ newChild: TokenSyntax?) -> ValueBindingPatternSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.letKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.letOrVarKeyword)
    return ValueBindingPatternSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var valuePattern: PatternSyntax {
    let child = data.cachedChild(at: Cursor.valuePattern)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! PatternSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `valuePattern` replaced.
  /// - param newChild: The new `valuePattern` to replace the node's
  ///                   current `valuePattern`, if present.
  public func withValuePattern(
    _ newChild: PatternSyntax?) -> ValueBindingPatternSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.pattern)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.valuePattern)
    return ValueBindingPatternSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `ValueBindingPatternSyntax` nodes are equal to each other.
  public static func ==(lhs: ValueBindingPatternSyntax, rhs: ValueBindingPatternSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 70)
/// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 70)
/// A single argument to an `@available` argument like `*`, `iOS 10.1`,          or `message: "This has been deprecated"`.
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 70)
/// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct AvailabilityArgumentSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case entry
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case trailingComma
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `AvailabilityArgumentSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 2)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _entry = raw[Cursor.syntax]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_entry.kind == .syntax,
                 "expected child of kind .syntax, " +
                 "got \(_entry.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _trailingComma = raw[Cursor.commaToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _trailingCommaTokenKind = _trailingComma.tokenKind else {
      fatalError("expected token child, got \(_trailingComma.kind)")
    }
    precondition([.comma].contains(_trailingCommaTokenKind),
      "expected one of [.comma] for 'trailingComma' " + 
      "in node of kind availabilityArgument")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// The actual argument
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var entry: Syntax {
    let child = data.cachedChild(at: Cursor.entry)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) 
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `entry` replaced.
  /// - param newChild: The new `entry` to replace the node's
  ///                   current `entry`, if present.
  public func withEntry(
    _ newChild: Syntax?) -> AvailabilityArgumentSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.unknown)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.entry)
    return AvailabilityArgumentSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// A trailing comma if the argument is followed by another                    argument
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var trailingComma: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.trailingComma)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `trailingComma` replaced.
  /// - param newChild: The new `trailingComma` to replace the node's
  ///                   current `trailingComma`, if present.
  public func withTrailingComma(
    _ newChild: TokenSyntax?) -> AvailabilityArgumentSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.comma)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.trailingComma)
    return AvailabilityArgumentSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `AvailabilityArgumentSyntax` nodes are equal to each other.
  public static func ==(lhs: AvailabilityArgumentSyntax, rhs: AvailabilityArgumentSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 70)
/// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 70)
/// A argument to an `@available` attribute that consists of a label and          a value, e.g. `message: "This has been deprecated"`.
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 70)
/// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct AvailabilityLabeledArgumentSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case label
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case colon
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case value
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `AvailabilityLabeledArgumentSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 3)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _label = raw[Cursor.identifierToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _labelTokenKind = _label.tokenKind else {
      fatalError("expected token child, got \(_label.kind)")
    }
    precondition([.identifier].contains(_labelTokenKind),
      "expected one of [.identifier] for 'label' " + 
      "in node of kind availabilityLabeledArgument")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _colon = raw[Cursor.colonToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _colonTokenKind = _colon.tokenKind else {
      fatalError("expected token child, got \(_colon.kind)")
    }
    precondition([.colon].contains(_colonTokenKind),
      "expected one of [.colon] for 'colon' " + 
      "in node of kind availabilityLabeledArgument")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _value = raw[Cursor.syntax]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_value.kind == .syntax,
                 "expected child of kind .syntax, " +
                 "got \(_value.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// The label of the argument
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var label: TokenSyntax {
    let child = data.cachedChild(at: Cursor.label)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `label` replaced.
  /// - param newChild: The new `label` to replace the node's
  ///                   current `label`, if present.
  public func withLabel(
    _ newChild: TokenSyntax?) -> AvailabilityLabeledArgumentSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.label)
    return AvailabilityLabeledArgumentSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// The colon separating label and value
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var colon: TokenSyntax {
    let child = data.cachedChild(at: Cursor.colon)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `colon` replaced.
  /// - param newChild: The new `colon` to replace the node's
  ///                   current `colon`, if present.
  public func withColon(
    _ newChild: TokenSyntax?) -> AvailabilityLabeledArgumentSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.colon)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.colon)
    return AvailabilityLabeledArgumentSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// The value of this labeled argument
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var value: Syntax {
    let child = data.cachedChild(at: Cursor.value)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) 
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `value` replaced.
  /// - param newChild: The new `value` to replace the node's
  ///                   current `value`, if present.
  public func withValue(
    _ newChild: Syntax?) -> AvailabilityLabeledArgumentSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.unknown)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.value)
    return AvailabilityLabeledArgumentSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `AvailabilityLabeledArgumentSyntax` nodes are equal to each other.
  public static func ==(lhs: AvailabilityLabeledArgumentSyntax, rhs: AvailabilityLabeledArgumentSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 70)
/// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 70)
/// An argument to `@available` that restricts the availability on a          certain platform to a version, e.g. `iOS 10` or `swift 3.4`.
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 70)
/// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct AvailabilityVersionRestrictionSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case platform
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case version
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `AvailabilityVersionRestrictionSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 2)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _platform = raw[Cursor.identifierToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _platformTokenKind = _platform.tokenKind else {
      fatalError("expected token child, got \(_platform.kind)")
    }
    precondition([.identifier].contains(_platformTokenKind),
      "expected one of [.identifier] for 'platform' " + 
      "in node of kind availabilityVersionRestriction")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _version = raw[Cursor.versionTuple]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_version.kind == .versionTuple,
                 "expected child of kind .versionTuple, " +
                 "got \(_version.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// The name of the OS on which the availability should be                    restricted or 'swift' if the availability should be                    restricted based on a Swift version.
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var platform: TokenSyntax {
    let child = data.cachedChild(at: Cursor.platform)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `platform` replaced.
  /// - param newChild: The new `platform` to replace the node's
  ///                   current `platform`, if present.
  public func withPlatform(
    _ newChild: TokenSyntax?) -> AvailabilityVersionRestrictionSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.platform)
    return AvailabilityVersionRestrictionSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var version: VersionTupleSyntax {
    let child = data.cachedChild(at: Cursor.version)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as! VersionTupleSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `version` replaced.
  /// - param newChild: The new `version` to replace the node's
  ///                   current `version`, if present.
  public func withVersion(
    _ newChild: VersionTupleSyntax?) -> AvailabilityVersionRestrictionSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.versionTuple)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.version)
    return AvailabilityVersionRestrictionSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `AvailabilityVersionRestrictionSyntax` nodes are equal to each other.
  public static func ==(lhs: AvailabilityVersionRestrictionSyntax, rhs: AvailabilityVersionRestrictionSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 68)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 70)
/// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 70)
/// A version number of the form major.minor.patch in which the minor          and patch part may be ommited.
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 70)
/// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 72)
public struct VersionTupleSyntax: Syntax, _SyntaxBase, Hashable {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 74)
  enum Cursor: Int {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case majorMinor
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case patchPeriod
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 76)
    case patchVersion
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 78)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 80)

  let _root: SyntaxData
  unowned let _data: SyntaxData 

  /// Creates a `VersionTupleSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
#if DEBUG
    validate()
#endif
  }

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 94)
#if DEBUG
  func validate() {
      if isMissing { return }
    precondition(raw.layout.count == 3)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _majorMinor = raw[Cursor.syntax]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 120)
    precondition(_majorMinor.kind == .syntax,
                 "expected child of kind .syntax, " +
                 "got \(_majorMinor.kind)")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _patchPeriod = raw[Cursor.periodToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _patchPeriodTokenKind = _patchPeriod.tokenKind else {
      fatalError("expected token child, got \(_patchPeriod.kind)")
    }
    precondition([.period].contains(_patchPeriodTokenKind),
      "expected one of [.period] for 'patchPeriod' " + 
      "in node of kind versionTuple")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 100)
    let _patchVersion = raw[Cursor.integerLiteralToken]
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 104)
    guard let _patchVersionTokenKind = _patchVersion.tokenKind else {
      fatalError("expected token child, got \(_patchVersion.kind)")
    }
    precondition([.integerLiteral].contains(_patchVersionTokenKind),
      "expected one of [.integerLiteral] for 'patchVersion' " + 
      "in node of kind versionTuple")
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 125)
  }
#endif
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// In case the version consists only of the major version, an                    integer literal that specifies the major version. In case                    the version consists of major and minor version number, a                    floating literal in which the decimal part is interpreted                    as the minor version.
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var majorMinor: Syntax {
    let child = data.cachedChild(at: Cursor.majorMinor)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) 
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `majorMinor` replaced.
  /// - param newChild: The new `majorMinor` to replace the node's
  ///                   current `majorMinor`, if present.
  public func withMajorMinor(
    _ newChild: Syntax?) -> VersionTupleSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.unknown)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.majorMinor)
    return VersionTupleSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// If the version contains a patch number, the period                    separating the minor from the patch number.
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var patchPeriod: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.patchPeriod)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `patchPeriod` replaced.
  /// - param newChild: The new `patchPeriod` to replace the node's
  ///                   current `patchPeriod`, if present.
  public func withPatchPeriod(
    _ newChild: TokenSyntax?) -> VersionTupleSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.period)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.patchPeriod)
    return VersionTupleSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// The patch version if specified.
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 138)
  /// 
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 140)
  public var patchVersion: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.patchVersion)
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 143)
    if child == nil { return nil }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 145)
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 171)

  /// Returns a copy of the receiver with its `patchVersion` replaced.
  /// - param newChild: The new `patchVersion` to replace the node's
  ///                   current `patchVersion`, if present.
  public func withPatchVersion(
    _ newChild: TokenSyntax?) -> VersionTupleSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.integerLiteral(""))
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.patchVersion)
    return VersionTupleSyntax(root: root, data: newData)
  }
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 183)

  /// Determines if two `VersionTupleSyntax` nodes are equal to each other.
  public static func ==(lhs: VersionTupleSyntax, rhs: VersionTupleSyntax) -> Bool {
    return lhs._data === rhs._data
  }

  /// A unique hash value for this node.
  public var hashValue: Int {
    return ObjectIdentifier(_data).hashValue
  }
}

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 197)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 199)
public protocol DeclGroupSyntax: Syntax {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 205)
  var attributes: AttributeListSyntax? { get }
  func withAttributes(_ newChild: AttributeListSyntax?) -> Self
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 205)
  var modifiers: ModifierListSyntax? { get }
  func withModifiers(_ newChild: ModifierListSyntax?) -> Self
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 205)
  var members: MemberDeclBlockSyntax { get }
  func withMembers(_ newChild: MemberDeclBlockSyntax?) -> Self
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 208)
}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 199)
public protocol BracedSyntax: Syntax {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 205)
  var leftBrace: TokenSyntax { get }
  func withLeftBrace(_ newChild: TokenSyntax?) -> Self
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 205)
  var rightBrace: TokenSyntax { get }
  func withRightBrace(_ newChild: TokenSyntax?) -> Self
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 208)
}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 199)
public protocol IdentifiedDeclSyntax: Syntax {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 205)
  var identifier: TokenSyntax { get }
  func withIdentifier(_ newChild: TokenSyntax?) -> Self
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 208)
}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 199)
public protocol WithCodeBlockSyntax: Syntax {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 205)
  var body: CodeBlockSyntax { get }
  func withBody(_ newChild: CodeBlockSyntax?) -> Self
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 208)
}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 199)
public protocol ParenthesizedSyntax: Syntax {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 205)
  var leftParen: TokenSyntax { get }
  func withLeftParen(_ newChild: TokenSyntax?) -> Self
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 205)
  var rightParen: TokenSyntax { get }
  func withRightParen(_ newChild: TokenSyntax?) -> Self
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 208)
}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 199)
public protocol WithTrailingCommaSyntax: Syntax {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 205)
  var trailingComma: TokenSyntax? { get }
  func withTrailingComma(_ newChild: TokenSyntax?) -> Self
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 208)
}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 199)
public protocol LabeledSyntax: Syntax {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 205)
  var labelName: TokenSyntax? { get }
  func withLabelName(_ newChild: TokenSyntax?) -> Self
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 205)
  var labelColon: TokenSyntax? { get }
  func withLabelColon(_ newChild: TokenSyntax?) -> Self
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 208)
}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 199)
public protocol WithStatementsSyntax: Syntax {
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 205)
  var statements: CodeBlockItemListSyntax { get }
  func withStatements(_ newChild: CodeBlockItemListSyntax?) -> Self
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 208)
}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 210)

// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 219)
extension CodeBlockSyntax: BracedSyntax, WithStatementsSyntax {}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 219)
extension DeclNameArgumentsSyntax: ParenthesizedSyntax {}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 219)
extension TupleExprSyntax: ParenthesizedSyntax {}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 219)
extension FunctionCallArgumentSyntax: WithTrailingCommaSyntax {}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 219)
extension TupleElementSyntax: WithTrailingCommaSyntax {}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 219)
extension ArrayElementSyntax: WithTrailingCommaSyntax {}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 219)
extension DictionaryElementSyntax: WithTrailingCommaSyntax {}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 219)
extension ClosureCaptureItemSyntax: WithTrailingCommaSyntax {}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 219)
extension ClosureParamSyntax: WithTrailingCommaSyntax {}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 219)
extension ClosureExprSyntax: BracedSyntax, WithStatementsSyntax {}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 219)
extension ExpressionSegmentSyntax: ParenthesizedSyntax {}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 219)
extension ObjcKeyPathExprSyntax: ParenthesizedSyntax {}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 219)
extension ObjcSelectorExprSyntax: ParenthesizedSyntax {}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 219)
extension ObjectLiteralExprSyntax: ParenthesizedSyntax {}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 219)
extension TypealiasDeclSyntax: IdentifiedDeclSyntax {}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 219)
extension AssociatedtypeDeclSyntax: IdentifiedDeclSyntax {}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 219)
extension ParameterClauseSyntax: ParenthesizedSyntax {}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 219)
extension PoundErrorDeclSyntax: ParenthesizedSyntax {}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 219)
extension PoundWarningDeclSyntax: ParenthesizedSyntax {}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 219)
extension PoundSourceLocationSyntax: ParenthesizedSyntax {}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 219)
extension InheritedTypeSyntax: WithTrailingCommaSyntax {}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 219)
extension ClassDeclSyntax: DeclGroupSyntax, IdentifiedDeclSyntax {}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 219)
extension StructDeclSyntax: DeclGroupSyntax, IdentifiedDeclSyntax {}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 219)
extension ProtocolDeclSyntax: DeclGroupSyntax, IdentifiedDeclSyntax {}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 219)
extension ExtensionDeclSyntax: DeclGroupSyntax {}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 219)
extension MemberDeclBlockSyntax: BracedSyntax {}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 219)
extension SourceFileSyntax: WithStatementsSyntax {}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 219)
extension FunctionParameterSyntax: WithTrailingCommaSyntax {}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 219)
extension FunctionDeclSyntax: IdentifiedDeclSyntax {}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 219)
extension AccessorParameterSyntax: ParenthesizedSyntax {}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 219)
extension AccessorBlockSyntax: BracedSyntax {}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 219)
extension PatternBindingSyntax: WithTrailingCommaSyntax {}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 219)
extension EnumCaseElementSyntax: WithTrailingCommaSyntax {}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 219)
extension EnumDeclSyntax: IdentifiedDeclSyntax {}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 219)
extension OperatorDeclSyntax: IdentifiedDeclSyntax {}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 219)
extension PrecedenceGroupDeclSyntax: IdentifiedDeclSyntax {}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 219)
extension LabeledSpecializeEntrySyntax: WithTrailingCommaSyntax {}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 219)
extension WhileStmtSyntax: WithCodeBlockSyntax, LabeledSyntax {}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 219)
extension DeferStmtSyntax: WithCodeBlockSyntax {}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 219)
extension RepeatWhileStmtSyntax: WithCodeBlockSyntax, LabeledSyntax {}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 219)
extension GuardStmtSyntax: WithCodeBlockSyntax {}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 219)
extension ForInStmtSyntax: WithCodeBlockSyntax, LabeledSyntax {}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 219)
extension SwitchStmtSyntax: BracedSyntax, LabeledSyntax {}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 219)
extension DoStmtSyntax: WithCodeBlockSyntax, LabeledSyntax {}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 219)
extension ConditionElementSyntax: WithTrailingCommaSyntax {}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 219)
extension IfStmtSyntax: WithCodeBlockSyntax, LabeledSyntax {}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 219)
extension ElseBlockSyntax: WithCodeBlockSyntax {}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 219)
extension SwitchCaseSyntax: WithStatementsSyntax {}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 219)
extension CaseItemSyntax: WithTrailingCommaSyntax {}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 219)
extension SameTypeRequirementSyntax: WithTrailingCommaSyntax {}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 219)
extension GenericParameterSyntax: WithTrailingCommaSyntax {}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 219)
extension ConformanceRequirementSyntax: WithTrailingCommaSyntax {}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 219)
extension TupleTypeElementSyntax: WithTrailingCommaSyntax {}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 219)
extension TupleTypeSyntax: ParenthesizedSyntax {}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 219)
extension FunctionTypeSyntax: ParenthesizedSyntax {}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 219)
extension GenericArgumentSyntax: WithTrailingCommaSyntax {}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 219)
extension TuplePatternSyntax: ParenthesizedSyntax {}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 219)
extension TuplePatternElementSyntax: WithTrailingCommaSyntax, LabeledSyntax {}
// ###sourceLocation(file: "/Users/alex/Documents/swift-src/swift-syntax/Sources/SwiftSyntax/SyntaxNodes.swift.gyb", line: 222)

/// MARK: Convenience methods

extension StructDeclSyntax {
  /// Creates a new StructDeclSyntax with the provided name as its identifier.
  /// - param name: The new struct's name.
  /// - returns: A new StructDeclSyntax with the same fields as the receiver,
  ///            but with the provided identifier.
  func withIdentifier(_ name: String) -> StructDeclSyntax {
    let newToken = SyntaxFactory.makeIdentifier(name,
      leadingTrivia: identifier.leadingTrivia,
      trailingTrivia: identifier.trailingTrivia)
    return withIdentifier(newToken)
  }
}
